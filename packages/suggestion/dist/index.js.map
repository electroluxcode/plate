{"version":3,"sources":["../src/index.ts","../src/lib/BaseSuggestionPlugin.ts","../src/lib/utils/getSuggestionKeys.ts","../src/lib/utils/getSuggestionId.ts","../src/lib/utils/getSuggestionNodeEntries.ts","../src/lib/utils/getActiveSuggestionDescriptions.ts","../src/lib/withSuggestion.ts","../src/lib/queries/findSuggestionNode.ts","../src/lib/queries/findSuggestionProps.ts","../src/lib/transforms/addMarkSuggestion.ts","../src/lib/transforms/deleteSuggestion.ts","../src/lib/transforms/setSuggestionNodes.ts","../src/lib/transforms/deleteFragmentSuggestion.ts","../src/lib/transforms/insertFragmentSuggestion.ts","../src/lib/transforms/insertTextSuggestion.ts","../src/lib/transforms/removeMarkSuggestion.ts","../src/lib/transforms/removeNodesSuggestion.ts","../src/lib/diffToSuggestions.ts","../src/lib/transforms/acceptSuggestion.ts","../src/lib/transforms/getSuggestionProps.ts","../src/lib/transforms/rejectSuggestion.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import {\n  type EditorNodesOptions,\n  type NodeEntry,\n  type PluginConfig,\n  type TElement,\n  type TInlineSuggestionData,\n  type TSuggestionElement,\n  type TSuggestionText,\n  createTSlatePlugin,\n  ElementApi,\n  getAt,\n  KEYS,\n  TextApi,\n} from 'platejs';\n\nimport { getSuggestionKey, getSuggestionKeyId } from './utils';\nimport { withSuggestion } from './withSuggestion';\n\nexport type BaseSuggestionConfig = PluginConfig<\n  'suggestion',\n  {\n    currentUserId: string | null;\n    isSuggesting: boolean;\n    // onAdd?: (value: WithPartial<TSuggestion, 'id' | 'userId'>) => void;\n    // onRemove?: (id: string) => void;\n    // onUpdate?: (id: string, value: Partial<TSuggestion>) => void;\n  },\n  {\n    suggestion: {\n      dataList: (node: TSuggestionText) => TInlineSuggestionData[];\n      isBlockSuggestion: (node: TElement) => node is TSuggestionElement;\n      node: (\n        options?: EditorNodesOptions & { id?: string; isText?: boolean }\n      ) => NodeEntry<TSuggestionElement | TSuggestionText> | undefined;\n      nodeId: (node: TElement | TSuggestionText) => string | undefined;\n      nodes: (\n        options?: EditorNodesOptions\n      ) => NodeEntry<TElement | TSuggestionText>[];\n      suggestionData: (\n        node: TElement | TSuggestionText\n      ) => TInlineSuggestionData | TSuggestionElement['suggestion'] | undefined;\n      withoutSuggestions: (fn: () => void) => void;\n    };\n  }\n>;\n\nexport const BaseSuggestionPlugin = createTSlatePlugin<BaseSuggestionConfig>({\n  key: KEYS.suggestion,\n  node: { isLeaf: true },\n  options: {\n    currentUserId: 'alice',\n    isSuggesting: false,\n  },\n  rules: { selection: { affinity: 'outward' } },\n})\n  .overrideEditor(withSuggestion)\n  .extendApi<BaseSuggestionConfig['api']['suggestion']>(\n    ({ api, editor, getOption, setOption, type }) => ({\n      dataList: (node: TSuggestionText): TInlineSuggestionData[] => {\n        return Object.keys(node)\n          .filter((key) => {\n            return key.startsWith(`${KEYS.suggestion}_`);\n          })\n          .map((key) => node[key] as TInlineSuggestionData);\n      },\n      isBlockSuggestion: (node): node is TSuggestionElement =>\n        ElementApi.isElement(node) && 'suggestion' in node,\n      node: (options = {}) => {\n        const { id, isText, ...rest } = options;\n        const result = editor.api.node<TSuggestionElement | TSuggestionText>({\n          match: (n) => {\n            if (!n[type]) return false;\n            if (isText && !TextApi.isText(n)) return false;\n            if (id) {\n              if (TextApi.isText(n)) {\n                return !!n[getSuggestionKey(id)];\n              }\n              if (\n                ElementApi.isElement(n) &&\n                api.suggestion.isBlockSuggestion(n)\n              ) {\n                return n.suggestion.id === id;\n              }\n            }\n\n            return true;\n          },\n          ...rest,\n        });\n\n        return result;\n      },\n      nodeId: (node) => {\n        if (TextApi.isText(node)) {\n          const keyId = getSuggestionKeyId(node);\n\n          if (!keyId) return;\n\n          return keyId.replace(`${type}_`, '');\n        }\n\n        if (api.suggestion.isBlockSuggestion(node)) {\n          return node.suggestion.id;\n        }\n      },\n      nodes: (options = {}) => {\n        const at = getAt(editor, options.at) ?? [];\n\n        return [\n          ...editor.api.nodes<TElement | TSuggestionText>({\n            ...options,\n            at,\n            mode: 'all',\n            match: (n) => n[type],\n          }),\n        ];\n      },\n      suggestionData: (node) => {\n        if (TextApi.isText(node)) {\n          const keyId = getSuggestionKeyId(node);\n\n          if (!keyId) return;\n\n          return node[keyId] as TInlineSuggestionData | undefined;\n        }\n\n        if (api.suggestion.isBlockSuggestion(node)) {\n          return node.suggestion;\n        }\n      },\n      withoutSuggestions: (fn) => {\n        const prev = getOption('isSuggesting');\n        setOption('isSuggesting', false);\n        fn();\n        setOption('isSuggesting', prev);\n      },\n    })\n  );\n","import {\n  type SlateEditor,\n  type TNode,\n  type TText,\n  isDefined,\n  KEYS,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getInlineSuggestionData } from './getSuggestionId';\n\nexport const getSuggestionKey = (id = '0'): string =>\n  `${KEYS.suggestion}_${id}`;\n\nexport const isSuggestionKey = (key: string) =>\n  key.startsWith(`${KEYS.suggestion}_`);\n\nexport const getSuggestionKeys = (node: TNode) => {\n  const keys: string[] = [];\n\n  Object.keys(node).forEach((key) => {\n    if (isSuggestionKey(key)) keys.push(key);\n  });\n\n  return keys;\n};\n\nexport const getSuggestionUserIdByKey = (key?: string | null) =>\n  isDefined(key) ? key.split(`${KEYS.suggestion}_`)[1] : null;\n\nexport const getSuggestionUserIds = (node: TNode) => {\n  return getSuggestionKeys(node).map(\n    (key) => getSuggestionUserIdByKey(key) as string\n  );\n};\n\nexport const getSuggestionUserId = (node: TNode) => {\n  return getSuggestionUserIds(node)[0];\n};\n\nexport const isCurrentUserSuggestion = (editor: SlateEditor, node: TText) => {\n  const { currentUserId } = editor.getOptions(BaseSuggestionPlugin);\n\n  return getInlineSuggestionData(node)?.userId === currentUserId;\n};\n","import type { TInlineSuggestionData, TText } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\n// the last id is the active id\nexport const getSuggestionKeyId = (node: TText) => {\n  const ids: string[] = Object.keys(node).filter((key) => {\n    return key.startsWith(`${KEYS.suggestion}_`);\n  });\n\n  return ids.at(-1);\n};\n\nexport const getInlineSuggestionData = (node: TText) => {\n  const keyId = getSuggestionKeyId(node);\n\n  if (!keyId) return;\n\n  return node[keyId] as TInlineSuggestionData | undefined;\n};\n\nexport const keyId2SuggestionId = (keyId: string) => {\n  return keyId.replace(`${KEYS.suggestion}_`, '');\n};\n","import {\n  type EditorNodesOptions,\n  type SlateEditor,\n  type TSuggestionText,\n  type ValueOf,\n  combineMatchOptions,\n} from 'platejs';\n\nexport const getSuggestionNodeEntries = <E extends SlateEditor>(\n  editor: E,\n  suggestionId: string,\n  { at = [], ...options }: EditorNodesOptions<ValueOf<E>> = {}\n) =>\n  editor.api.nodes<TSuggestionText>({\n    at,\n    ...options,\n    match: combineMatchOptions(\n      editor,\n      (n) => n.suggestionId === suggestionId,\n      options\n    ),\n  });\n","import type { SlateEditor } from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getSuggestionKey, getSuggestionUserIds } from './getSuggestionKeys';\nimport { getSuggestionNodeEntries } from './getSuggestionNodeEntries';\n\nexport type TSuggestionCommonDescription = {\n  suggestionId: string;\n  userId: string;\n};\n\nexport type TSuggestionDeletionDescription = {\n  deletedText: string;\n  type: 'deletion';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionDescription =\n  | TSuggestionDeletionDescription\n  | TSuggestionInsertionDescription\n  | TSuggestionReplacementDescription;\n\n// TODO: Move to ../types\nexport type TSuggestionInsertionDescription = {\n  insertedText: string;\n  type: 'insertion';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionReplacementDescription = {\n  deletedText: string;\n  insertedText: string;\n  type: 'replacement';\n} & TSuggestionCommonDescription;\n\n/**\n * Get the suggestion descriptions of the selected node. A node can have\n * multiple suggestions (multiple users). Each description maps to a user\n * suggestion.\n */\nexport const getActiveSuggestionDescriptions = (\n  editor: SlateEditor\n): TSuggestionDescription[] => {\n  const aboveEntry = editor.getApi(BaseSuggestionPlugin).suggestion.node({\n    isText: true,\n  });\n\n  if (!aboveEntry) return [];\n\n  const aboveNode = aboveEntry[0];\n  const suggestionId = editor\n    .getApi(BaseSuggestionPlugin)\n    .suggestion.nodeId(aboveNode);\n\n  if (!suggestionId) return [];\n\n  const userIds = getSuggestionUserIds(aboveNode);\n\n  return userIds.map((userId) => {\n    const nodes = Array.from(\n      getSuggestionNodeEntries(editor, suggestionId, {\n        match: (n: any) => n[getSuggestionKey(userId)],\n      })\n    ).map(([node]) => node);\n    const insertions = nodes.filter((node) => !node.suggestionDeletion);\n    const deletions = nodes.filter((node) => node.suggestionDeletion);\n    const insertedText = insertions.map((node) => node.text).join('');\n    const deletedText = deletions.map((node) => node.text).join('');\n\n    if (insertions.length > 0 && deletions.length > 0) {\n      return {\n        deletedText,\n        insertedText,\n        suggestionId,\n        type: 'replacement',\n        userId,\n      };\n    }\n    if (deletions.length > 0) {\n      return {\n        deletedText,\n        suggestionId,\n        type: 'deletion',\n        userId,\n      };\n    }\n\n    return {\n      insertedText,\n      suggestionId,\n      type: 'insertion',\n      userId,\n    };\n  });\n};\n","import {\n  type OverrideEditor,\n  type TSuggestionElement,\n  KEYS,\n  nanoid,\n  TextApi,\n} from 'platejs';\n\nimport {\n  type BaseSuggestionConfig,\n  BaseSuggestionPlugin,\n} from './BaseSuggestionPlugin';\nimport { findSuggestionProps } from './queries';\nimport { addMarkSuggestion } from './transforms/addMarkSuggestion';\nimport { deleteFragmentSuggestion } from './transforms/deleteFragmentSuggestion';\nimport { deleteSuggestion } from './transforms/deleteSuggestion';\nimport { insertFragmentSuggestion } from './transforms/insertFragmentSuggestion';\nimport { insertTextSuggestion } from './transforms/insertTextSuggestion';\nimport { removeMarkSuggestion } from './transforms/removeMarkSuggestion';\nimport { removeNodesSuggestion } from './transforms/removeNodesSuggestion';\nimport { getInlineSuggestionData, getSuggestionKeyId } from './utils/index';\n\nexport const withSuggestion: OverrideEditor<BaseSuggestionConfig> = ({\n  api,\n  editor,\n  getOptions,\n  tf: {\n    addMark,\n    apply,\n    deleteBackward,\n    deleteForward,\n    deleteFragment,\n    insertBreak,\n    insertFragment,\n    insertNodes,\n    insertText,\n    normalizeNode,\n    removeMark,\n    removeNodes,\n  },\n}) => ({\n  transforms: {\n    addMark(key, value) {\n      if (getOptions().isSuggesting && api.isExpanded()) {\n        return addMarkSuggestion(editor, key, value);\n      }\n\n      return addMark(key, value);\n    },\n    apply(operation) {\n      return apply(operation);\n    },\n    deleteBackward(unit) {\n      const selection = editor.selection!;\n      const pointTarget = editor.api.before(selection, { unit });\n\n      if (getOptions().isSuggesting) {\n        const node = editor.api.above<TSuggestionElement>();\n        // without set suggestion when delete backward in block suggestion\n        if (node?.[0][KEYS.suggestion] && !node?.[0].suggestion.isLineBreak) {\n          return deleteBackward(unit);\n        }\n\n        if (!pointTarget) return;\n\n        deleteSuggestion(\n          editor,\n          { anchor: selection.anchor, focus: pointTarget },\n          { reverse: true }\n        );\n\n        return;\n      } else {\n        // remove line break when across blocks\n        if (pointTarget) {\n          const isCrossBlock = editor.api.isAt({\n            at: { anchor: selection.anchor, focus: pointTarget },\n            blocks: true,\n          });\n\n          if (isCrossBlock) {\n            editor.tf.unsetNodes([KEYS.suggestion], {\n              at: pointTarget,\n            });\n          }\n        }\n      }\n\n      deleteBackward(unit);\n    },\n    deleteForward(unit) {\n      if (getOptions().isSuggesting) {\n        const selection = editor.selection!;\n        const pointTarget = editor.api.after(selection, { unit });\n\n        if (!pointTarget) return;\n\n        deleteSuggestion(editor, {\n          anchor: selection.anchor,\n          focus: pointTarget,\n        });\n\n        return;\n      }\n\n      deleteForward(unit);\n    },\n\n    deleteFragment(direction) {\n      if (getOptions().isSuggesting) {\n        deleteFragmentSuggestion(editor, { reverse: true });\n\n        return;\n      }\n\n      deleteFragment(direction);\n    },\n\n    insertBreak() {\n      if (getOptions().isSuggesting) {\n        const [node, path] = editor.api.above()!;\n\n        if (path.length > 1 || node.type !== editor.getType(KEYS.p)) {\n          return insertTextSuggestion(editor, '\\n');\n        }\n\n        const { id, createdAt } = findSuggestionProps(editor, {\n          at: editor.selection!,\n          type: 'insert',\n        });\n\n        insertBreak();\n\n        editor.tf.withoutMerging(() => {\n          editor.tf.setNodes(\n            {\n              [KEYS.suggestion]: {\n                id,\n                createdAt,\n                isLineBreak: true,\n                type: 'insert',\n                userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n              },\n            },\n            { at: path }\n          );\n        });\n\n        return;\n      }\n\n      insertBreak();\n    },\n\n    insertFragment(fragment) {\n      if (getOptions().isSuggesting) {\n        insertFragmentSuggestion(editor, fragment, { insertFragment });\n\n        return;\n      }\n\n      insertFragment(fragment);\n    },\n\n    insertNodes(nodes, options) {\n      if (getOptions().isSuggesting) {\n        const nodesArray = Array.isArray(nodes) ? nodes : [nodes];\n\n        // TODO: options\n        if (nodesArray.some((n) => n.type === 'slash_input')) {\n          api.suggestion.withoutSuggestions(() => {\n            insertNodes(nodes, options);\n          });\n\n          return;\n        }\n\n        const suggestionNodes = nodesArray.map((node) => {\n          return {\n            ...node,\n            [KEYS.suggestion]: {\n              id: nanoid(),\n              createdAt: Date.now(),\n              type: 'insert',\n              userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n            },\n          };\n        });\n\n        return insertNodes(suggestionNodes, options);\n      }\n\n      return insertNodes(nodes, options);\n    },\n\n    insertText(text, options) {\n      if (getOptions().isSuggesting) {\n        const node = editor.api.above<TSuggestionElement>();\n\n        if (node?.[0][KEYS.suggestion] && !node?.[0].suggestion.isLineBreak) {\n          return insertText(text, options);\n        }\n\n        insertTextSuggestion(editor, text);\n\n        return;\n      }\n\n      insertText(text, options);\n    },\n\n    normalizeNode(entry) {\n      api.suggestion.withoutSuggestions(() => {\n        const [node, path] = entry;\n\n        if (\n          node[KEYS.suggestion] && // Unset suggestion when there is no suggestion id\n          TextApi.isText(node) &&\n          !getSuggestionKeyId(node)\n        ) {\n          editor.tf.unsetNodes([KEYS.suggestion, 'suggestionData'], {\n            at: path,\n          });\n\n          return;\n        }\n        // Unset suggestion when there is no suggestion user id\n        if (\n          node[KEYS.suggestion] &&\n          TextApi.isText(node) &&\n          !getInlineSuggestionData(node)?.userId\n        ) {\n          if (getInlineSuggestionData(node)?.type === 'remove') {\n            // Unset deletions\n            editor.tf.unsetNodes([KEYS.suggestion, getSuggestionKeyId(node)!], {\n              at: path,\n            });\n          } else {\n            // Remove additions\n            editor.tf.removeNodes({ at: path });\n          }\n\n          return;\n        }\n\n        normalizeNode(entry);\n      });\n    },\n    removeMark(key) {\n      if (getOptions().isSuggesting && api.isExpanded()) {\n        return removeMarkSuggestion(editor, key);\n      }\n\n      return removeMark(key);\n    },\n    // Remove nodes by block selection\n    removeNodes(options) {\n      if (getOptions().isSuggesting) {\n        const nodes = [...editor.api.nodes(options)];\n\n        if (nodes.some(([n]) => n.type === 'slash_input')) {\n          api.suggestion.withoutSuggestions(() => {\n            removeNodes(options);\n          });\n\n          return;\n        }\n\n        return removeNodesSuggestion(editor, nodes);\n      }\n\n      return removeNodes(options);\n    },\n  },\n});\n","import {\n  type EditorNodesOptions,\n  type SlateEditor,\n  type TSuggestionText,\n  type ValueOf,\n  combineMatchOptions,\n  KEYS,\n  TextApi,\n} from 'platejs';\n\nexport const findInlineSuggestionNode = <E extends SlateEditor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>> = {}\n) =>\n  editor.api.node<TSuggestionText>({\n    ...options,\n    match: combineMatchOptions(\n      editor,\n      (n) => TextApi.isText(n) && (n as any)[KEYS.suggestion],\n      options\n    ),\n  });\n","import {\n  type NodeEntry,\n  type Point,\n  type SlateEditor,\n  type TLocation,\n  type TSuggestionElement,\n  type TSuggestionText,\n  nanoid,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getInlineSuggestionData, isCurrentUserSuggestion } from '../utils';\n\nexport const findSuggestionProps = (\n  editor: SlateEditor,\n  { at, type }: { at: TLocation; type: 'insert' | 'remove' | 'update' }\n): { id: string; createdAt: number } => {\n  const defaultProps = {\n    id: nanoid(),\n    createdAt: Date.now(),\n  };\n\n  const api = editor.getApi(BaseSuggestionPlugin);\n\n  let entry = api.suggestion.node({\n    at,\n    isText: true,\n  }) as NodeEntry<TSuggestionText> | undefined;\n\n  if (!entry) {\n    let start: Point;\n    let end: Point;\n\n    try {\n      [start, end] = editor.api.edges(at)!;\n    } catch {\n      return defaultProps;\n    }\n\n    const nextPoint = editor.api.after(end);\n\n    if (nextPoint) {\n      entry = api.suggestion.node({\n        at: nextPoint,\n        isText: true,\n      }) as NodeEntry<TSuggestionText> | undefined;\n\n      if (!entry) {\n        const prevPoint = editor.api.before(start);\n\n        if (prevPoint) {\n          entry = api.suggestion.node({\n            at: prevPoint,\n            isText: true,\n          }) as NodeEntry<TSuggestionText> | undefined;\n        }\n        // <p>111111<insert_break></p>\n        // <p><cursor /></p>\n        // in this case we need to find the previous parent node\n        // TODO: test\n        if (!entry && editor.api.isStart(start, at)) {\n          const _at = prevPoint ?? at;\n\n          const lineBreak = editor.api.above<TSuggestionElement>({ at: _at });\n\n          const lineBreakData = lineBreak?.[0].suggestion;\n\n          if (lineBreakData?.isLineBreak) {\n            return {\n              id: lineBreakData?.id ?? nanoid(),\n              createdAt: lineBreakData?.createdAt ?? Date.now(),\n            };\n          }\n        }\n      }\n    }\n  }\n  // same type and same user merge suggestions\n  if (\n    entry &&\n    getInlineSuggestionData(entry[0])?.type === type &&\n    isCurrentUserSuggestion(editor, entry[0])\n  ) {\n    return {\n      id: api.suggestion.nodeId(entry[0]) ?? nanoid(),\n      createdAt: getInlineSuggestionData(entry[0])?.createdAt ?? Date.now(),\n    };\n  }\n\n  return defaultProps;\n};\n","import { type SlateEditor, type TNode, KEYS, nanoid, TextApi } from 'platejs';\n\nimport { getInlineSuggestionData, getSuggestionKey } from '../..';\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\n\nconst getAddMarkProps = () => {\n  const defaultProps = {\n    id: nanoid(),\n    createdAt: Date.now(),\n  };\n\n  return defaultProps;\n};\n\nexport const addMarkSuggestion = (\n  editor: SlateEditor,\n  key: string,\n  value: any\n) => {\n  editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n    const { id, createdAt } = getAddMarkProps();\n\n    const match = (n: TNode) => {\n      if (!TextApi.isText(n)) return false;\n      // if the node is already marked as a suggestion, we don't want to remove it unless it's a removeMark suggestion\n      if (n[KEYS.suggestion]) {\n        const data = getInlineSuggestionData(n);\n\n        if (data?.type === 'update') {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n\n    editor.tf.setNodes(\n      {\n        [key]: value,\n        [getSuggestionKey(id)]: {\n          id: id,\n          createdAt: createdAt,\n          newProperties: {\n            [key]: value,\n          },\n          type: 'update',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId,\n        },\n        [KEYS.suggestion]: true,\n      },\n      {\n        match,\n        split: true,\n      }\n    );\n  });\n};\n","import {\n  type Point,\n  type SlateEditor,\n  type TElement,\n  type TRange,\n  type TSuggestionElement,\n  ElementApi,\n  KEYS,\n  PathApi,\n  PointApi,\n  TextApi,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { findSuggestionProps } from '../queries/';\nimport { getInlineSuggestionData, isCurrentUserSuggestion } from '../utils';\nimport { setSuggestionNodes } from './setSuggestionNodes';\n\n/**\n * Suggest deletion one character at a time until target point is reached.\n * Suggest additions are safely deleted.\n */\nexport const deleteSuggestion = (\n  editor: SlateEditor,\n  at: TRange,\n  {\n    reverse,\n  }: {\n    reverse?: boolean;\n  } = {}\n) => {\n  let resId: string | undefined;\n\n  editor.tf.withoutNormalizing(() => {\n    const { anchor: from, focus: to } = at;\n\n    const { id, createdAt: createdAt } = findSuggestionProps(editor, {\n      at: from,\n      type: 'remove',\n    });\n\n    resId = id;\n\n    const toRef = editor.api.pointRef(to);\n\n    let pointCurrent: Point | undefined;\n\n    while (true) {\n      pointCurrent = editor.selection?.anchor;\n\n      if (!pointCurrent) break;\n\n      const pointTarget = toRef.current;\n\n      if (!pointTarget) break;\n      // don't delete across blocks\n      if (\n        !editor.api.isAt({\n          at: { anchor: pointCurrent, focus: pointTarget },\n          blocks: true,\n        })\n      ) {\n        // always 0 when across blocks\n        const str = editor.api.string(\n          reverse\n            ? {\n                anchor: pointTarget,\n                focus: pointCurrent,\n              }\n            : {\n                anchor: pointCurrent,\n                focus: pointTarget,\n              }\n        );\n\n        if (str.length === 0) break;\n      }\n\n      const getPoint = reverse ? editor.api.before : editor.api.after;\n\n      const pointNext: Point | undefined = getPoint(pointCurrent, {\n        unit: 'character',\n      });\n\n      if (!pointNext) break;\n\n      let range: TRange = reverse\n        ? {\n            anchor: pointNext,\n            focus: pointCurrent,\n          }\n        : {\n            anchor: pointCurrent,\n            focus: pointNext,\n          };\n      range = editor.api.unhangRange(range, { character: true });\n\n      // if the current point is in block addition suggestion, delete block\n      const entryBlock = editor.api.node<TElement>({\n        at: pointCurrent,\n        block: true,\n        match: (n) =>\n          n[KEYS.suggestion] &&\n          TextApi.isText(n) &&\n          getInlineSuggestionData(n)?.type === 'insert' &&\n          isCurrentUserSuggestion(editor, n),\n      });\n\n      if (\n        entryBlock &&\n        editor.api.isStart(pointCurrent, entryBlock[1]) &&\n        editor.api.isEmpty(entryBlock[0] as any)\n      ) {\n        editor.tf.removeNodes({\n          at: entryBlock[1],\n        });\n\n        continue;\n      }\n      // if the range is across blocks, delete the line break\n      if (editor.api.isAt({ at: range, blocks: true })) {\n        const previousAboveNode = editor.api.above({ at: range.anchor });\n\n        if (previousAboveNode && ElementApi.isElement(previousAboveNode[0])) {\n          const isBlockSuggestion = editor\n            .getApi(BaseSuggestionPlugin)\n            .suggestion.isBlockSuggestion(previousAboveNode[0]);\n\n          if (isBlockSuggestion) {\n            const node = previousAboveNode[0] as TSuggestionElement;\n\n            if (node.suggestion.type === 'insert') {\n              editor\n                .getApi(BaseSuggestionPlugin)\n                .suggestion.withoutSuggestions(() => {\n                  editor.tf.unsetNodes([KEYS.suggestion], {\n                    at: previousAboveNode[1],\n                  });\n                  editor.tf.mergeNodes({\n                    at: PathApi.next(previousAboveNode[1]),\n                  });\n                });\n            }\n            if (node.suggestion.type === 'remove') {\n              editor.tf.move({\n                reverse,\n                unit: 'character',\n              });\n            }\n            break;\n          }\n\n          if (!isBlockSuggestion) {\n            editor.tf.setNodes(\n              {\n                [KEYS.suggestion]: {\n                  id,\n                  createdAt,\n                  type: 'remove',\n                  userId:\n                    editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n                },\n              },\n              { at: previousAboveNode[1] }\n            );\n            editor.tf.move({\n              reverse,\n              unit: 'character',\n            });\n            break;\n          }\n        }\n\n        break;\n      }\n      // move selection if still the same\n      if (PointApi.equals(pointCurrent, editor.selection!.anchor)) {\n        editor.tf.move({\n          reverse,\n          unit: 'character',\n        });\n      }\n\n      // if the current point is in addition suggestion, delete\n      const entryText = editor.getApi(BaseSuggestionPlugin).suggestion.node({\n        at: range,\n        isText: true,\n        match: (n) =>\n          TextApi.isText(n) &&\n          getInlineSuggestionData(n)?.type === 'insert' &&\n          isCurrentUserSuggestion(editor, n),\n      });\n\n      if (entryText) {\n        editor.tf.delete({ at: range, unit: 'character' });\n\n        continue;\n      }\n\n      setSuggestionNodes(editor, {\n        at: range,\n        createdAt: createdAt as number,\n        suggestionDeletion: true,\n        suggestionId: id,\n      });\n    }\n  });\n\n  return resId;\n};\n","import {\n  type SetNodesOptions,\n  type SlateEditor,\n  type TInlineSuggestionData,\n  type TSuggestionText,\n  ElementApi,\n  getAt,\n  KEYS,\n  nanoid,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getSuggestionKey } from '../utils';\n\nexport const setSuggestionNodes = (\n  editor: SlateEditor,\n  options?: {\n    createdAt?: number;\n    suggestionDeletion?: boolean;\n    suggestionId?: string;\n  } & SetNodesOptions\n) => {\n  const at = getAt(editor, options?.at) ?? editor.selection;\n\n  if (!at) return;\n\n  const { suggestionId = nanoid() } = options ?? {};\n\n  // TODO: get all inline nodes to be set\n  const _nodeEntries = editor.api.nodes({\n    match: (n) => ElementApi.isElement(n) && editor.api.isInline(n),\n    ...options,\n  });\n  const nodeEntries = [..._nodeEntries];\n\n  editor.tf.withoutNormalizing(() => {\n    const data: TInlineSuggestionData = {\n      id: suggestionId,\n      createdAt: options?.createdAt ?? Date.now(),\n      type: 'remove',\n      userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n    };\n\n    const props = {\n      [getSuggestionKey(suggestionId)]: data,\n      [KEYS.suggestion]: true,\n    };\n\n    editor.tf.setNodes(props, {\n      at,\n      marks: true,\n    });\n\n    nodeEntries.forEach(([, path]) => {\n      editor.tf.setNodes<TSuggestionText>(props, {\n        at: path,\n        match: (n) => ElementApi.isElement(n) && editor.api.isInline(n),\n        ...options,\n      });\n    });\n  });\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { deleteSuggestion } from './deleteSuggestion';\n\nexport const deleteFragmentSuggestion = (\n  editor: SlateEditor,\n  { reverse }: { reverse?: boolean } = {}\n) => {\n  let resId: string | undefined;\n\n  editor.tf.withoutNormalizing(() => {\n    const selection = editor.selection!;\n\n    const [start, end] = editor.api.edges(selection)!;\n\n    if (reverse) {\n      editor.tf.collapse({ edge: 'end' });\n      resId = deleteSuggestion(\n        editor,\n        { anchor: end, focus: start },\n        { reverse: true }\n      );\n    } else {\n      editor.tf.collapse({ edge: 'start' });\n      resId = deleteSuggestion(editor, { anchor: start, focus: end });\n    }\n  });\n\n  return resId;\n};\n","import { type Descendant, type SlateEditor, KEYS, TextApi } from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { findSuggestionProps } from '../queries';\nimport { getSuggestionKey, getSuggestionKeys } from '../utils/index';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\n\nexport const insertFragmentSuggestion = (\n  editor: SlateEditor,\n  fragment: Descendant[],\n  {\n    insertFragment = editor.tf.insertFragment,\n  }: {\n    insertFragment?: (fragment: Descendant[]) => void;\n  } = {}\n) => {\n  editor.tf.withoutNormalizing(() => {\n    deleteFragmentSuggestion(editor);\n\n    const { id, createdAt: createdAt } = findSuggestionProps(editor, {\n      at: editor.selection!,\n      type: 'insert',\n    });\n\n    fragment.forEach((n) => {\n      if (TextApi.isText(n)) {\n        if (!n[KEYS.suggestion]) {\n          // Add suggestion mark\n          n[KEYS.suggestion] = true;\n        }\n\n        // remove the other suggestion data\n        const otherUserKeys = getSuggestionKeys(n);\n        otherUserKeys.forEach((key) => {\n          delete n[key];\n        });\n\n        n[getSuggestionKey(id)] = {\n          id,\n          createdAt,\n          type: 'insert',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n        };\n      } else {\n        n[KEYS.suggestion] = {\n          id,\n          createdAt,\n          type: 'insert',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n        };\n      }\n    });\n\n    editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n      insertFragment(fragment);\n    });\n  });\n};\n","import type { SlateEditor, TSuggestionText } from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { findSuggestionProps } from '../queries';\nimport { getSuggestionKey } from '../utils';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\n\nexport const insertTextSuggestion = (editor: SlateEditor, text: string) => {\n  editor.tf.withoutNormalizing(() => {\n    let resId: string | undefined;\n    const { id, createdAt: createdAt } = findSuggestionProps(editor, {\n      at: editor.selection!,\n      type: 'insert',\n    });\n\n    if (editor.api.isExpanded()) {\n      resId = deleteFragmentSuggestion(editor);\n    }\n\n    editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n      editor.tf.insertNodes<TSuggestionText>(\n        {\n          [getSuggestionKey(resId ?? id)]: {\n            id: resId ?? id,\n            createdAt: createdAt,\n            type: 'insert',\n            userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n          },\n          suggestion: true,\n          text,\n        },\n        {\n          at: editor.selection!,\n          select: true,\n        }\n      );\n    });\n  });\n};\n","import { type SlateEditor, type TNode, KEYS, nanoid, TextApi } from 'platejs';\n\nimport { getInlineSuggestionData, getSuggestionKey } from '../..';\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\n\nconst getRemoveMarkProps = () => {\n  const defaultProps = {\n    id: nanoid(),\n    createdAt: Date.now(),\n  };\n\n  return defaultProps;\n};\n\n// TODO remove mark when the text is already marked as a bold by suggestion\nexport const removeMarkSuggestion = (editor: SlateEditor, key: string) => {\n  editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n    const { id, createdAt } = getRemoveMarkProps();\n\n    const match = (n: TNode) => {\n      if (!TextApi.isText(n)) return false;\n      // if the node is already marked as a suggestion, we don't want to remove it unless it's a removeMark suggestion\n      if (n[KEYS.suggestion]) {\n        const data = getInlineSuggestionData(n);\n\n        if (data?.type === 'update') {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n\n    editor.tf.unsetNodes(key, {\n      match,\n    });\n\n    editor.tf.setNodes(\n      {\n        [getSuggestionKey(id)]: {\n          id: id,\n          createdAt: createdAt,\n          properties: {\n            [key]: undefined,\n          },\n          type: 'update',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId,\n        },\n        [KEYS.suggestion]: true,\n      },\n      {\n        match,\n      }\n    );\n  });\n};\n","import type { NodeEntry, SlateEditor, TElement, Text } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { findSuggestionProps } from '../queries';\n\nexport const removeNodesSuggestion = (\n  editor: SlateEditor,\n  nodes: NodeEntry<TElement | Text>[]\n) => {\n  if (nodes.length === 0) return;\n\n  const { id, createdAt } = findSuggestionProps(editor, {\n    at: editor.selection!,\n    type: 'remove',\n  });\n\n  nodes.forEach(([, blockPath]) => {\n    editor.tf.setNodes(\n      {\n        [KEYS.suggestion]: {\n          id,\n          createdAt,\n          type: 'remove',\n        },\n      },\n      { at: blockPath }\n    );\n  });\n};\n","import { type ComputeDiffOptions, computeDiff } from '@platejs/diff';\nimport {\n  type Descendant,\n  type SlateEditor,\n  type ValueOf,\n  ElementApi,\n  KEYS,\n  nanoid,\n  TextApi,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from './BaseSuggestionPlugin';\nimport { getSuggestionProps } from './transforms';\nimport { getSuggestionKey } from './utils';\n\nexport function diffToSuggestions<E extends SlateEditor>(\n  editor: E,\n  doc0: Descendant[],\n  doc1: Descendant[],\n  {\n    getDeleteProps = () =>\n      getSuggestionProps(editor, nanoid(), {\n        suggestionDeletion: true,\n      }),\n    getInsertProps = () => getSuggestionProps(editor, nanoid()),\n    getUpdateProps = (_node, _properties, newProperties) =>\n      getSuggestionProps(editor, nanoid(), {\n        suggestionUpdate: newProperties,\n      }),\n    isInline = editor.api.isInline,\n    ...options\n  }: Partial<ComputeDiffOptions> = {}\n): ValueOf<E> {\n  const values = computeDiff(doc0, doc1, {\n    getDeleteProps,\n    getInsertProps,\n    getUpdateProps,\n    isInline,\n    ...options,\n  }) as ValueOf<E>;\n\n  // Recursively traverse all nodes to process elements and their children\n  const traverseNodes = (nodes: Descendant[]): Descendant[] => {\n    return nodes.map((node, index) => {\n      if (ElementApi.isElement(node) && 'children' in node) {\n        // If the node is an element with children, recursively process its children\n        return {\n          ...node,\n          children: traverseNodes(node.children),\n        };\n      }\n\n      if (TextApi.isText(node) && node[KEYS.suggestion]) {\n        const api = editor.getApi(BaseSuggestionPlugin);\n        const currentNodeData = api.suggestion.suggestionData(node as any);\n\n        if (currentNodeData?.type === 'insert') {\n          // Get the previous node if it exists\n          const previousNode = index > 0 ? nodes[index - 1] : null;\n\n          if (previousNode?.[KEYS.suggestion]) {\n            const previousData = api.suggestion.suggestionData(\n              previousNode as any\n            );\n\n            if (previousData?.type === 'remove') {\n              // Create a new node with the updated suggestion data\n              const updatedNode = {\n                ...node,\n                [getSuggestionKey(previousData.id)]: {\n                  ...currentNodeData,\n                  id: previousData.id,\n                  createdAt: previousData.createdAt,\n                },\n              };\n\n              // Return the updated node instead of modifying the original\n\n              const key = getSuggestionKey(currentNodeData.id);\n              delete updatedNode[key];\n\n              return updatedNode;\n            }\n          }\n        }\n\n        return node;\n      }\n      return node;\n    });\n  };\n\n  return traverseNodes(values) as ValueOf<E>;\n}\n","import {\n  type SlateEditor,\n  type TSuggestionElement,\n  type TSuggestionText,\n  ElementApi,\n  KEYS,\n  PathApi,\n  TextApi,\n} from 'platejs';\n\nimport type { TResolvedSuggestion } from '../types';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getInlineSuggestionData } from '../utils';\n\nexport const acceptSuggestion = (\n  editor: SlateEditor,\n  description: TResolvedSuggestion\n) => {\n  editor.tf.withoutNormalizing(() => {\n    const mergeNodes = [\n      ...editor.api.nodes({\n        at: [],\n        match: (n) => {\n          if (!ElementApi.isElement(n)) return false;\n\n          if (\n            editor.getApi(BaseSuggestionPlugin).suggestion.isBlockSuggestion(n)\n          ) {\n            const suggestionElement = n as TSuggestionElement;\n            return (\n              suggestionElement.suggestion.type === 'remove' &&\n              suggestionElement.suggestion.isLineBreak &&\n              suggestionElement.suggestion.id === description.suggestionId\n            );\n          }\n\n          return false;\n        },\n      }),\n    ];\n\n    mergeNodes.reverse().forEach(([, path]) => {\n      editor.tf.mergeNodes({ at: PathApi.next(path) });\n    });\n\n    editor.tf.unsetNodes([description.keyId, KEYS.suggestion], {\n      at: [],\n      mode: 'all',\n      match: (n) => {\n        if (TextApi.isText(n)) {\n          const suggestionDataList = editor\n            .getApi(BaseSuggestionPlugin)\n            .suggestion.dataList(n as TSuggestionText);\n          const includeUpdate = suggestionDataList.some(\n            (data) => data.type === 'update'\n          );\n\n          if (includeUpdate) {\n            return suggestionDataList.some(\n              (d) => d.id === description.suggestionId\n            );\n          } else {\n            const suggestionData = getInlineSuggestionData(n);\n\n            if (suggestionData)\n              return (\n                suggestionData.type === 'insert' &&\n                suggestionData.id === description.suggestionId\n              );\n          }\n\n          return false;\n        }\n        if (\n          ElementApi.isElement(n) &&\n          editor.getApi(BaseSuggestionPlugin).suggestion.isBlockSuggestion(n)\n        ) {\n          const suggestionElement = n as TSuggestionElement;\n          const suggestionData = suggestionElement.suggestion;\n\n          if (suggestionData) {\n            const isLineBreak = suggestionData.isLineBreak;\n\n            if (isLineBreak)\n              return suggestionData.id === description.suggestionId;\n\n            return (\n              suggestionData.type === 'insert' &&\n              suggestionData.id === description.suggestionId\n            );\n          }\n        }\n\n        return false;\n      },\n    });\n\n    editor.tf.removeNodes({\n      at: [],\n      mode: 'all',\n      match: (n) => {\n        if (TextApi.isText(n)) {\n          const suggestionData = getInlineSuggestionData(n);\n\n          if (suggestionData) {\n            return (\n              suggestionData.type === 'remove' &&\n              suggestionData.id === description.suggestionId\n            );\n          }\n\n          return false;\n        }\n\n        if (\n          ElementApi.isElement(n) &&\n          editor.getApi(BaseSuggestionPlugin).suggestion.isBlockSuggestion(n)\n        ) {\n          const suggestionElement = n as TSuggestionElement;\n          const suggestionData = suggestionElement.suggestion;\n\n          if (suggestionData) {\n            const isLineBreak = suggestionData.isLineBreak;\n\n            return (\n              suggestionData.type === 'remove' &&\n              suggestionData.id === description.suggestionId &&\n              !isLineBreak\n            );\n          }\n        }\n\n        return false;\n      },\n    });\n  });\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getSuggestionKey } from '../utils/index';\n\nexport const getSuggestionProps = (\n  editor: SlateEditor,\n  id: string,\n  {\n    createdAt = Date.now(),\n    suggestionDeletion,\n    suggestionUpdate,\n  }: {\n    createdAt?: number;\n    suggestionDeletion?: boolean;\n    suggestionUpdate?: any;\n  } = {}\n) => {\n  const type = suggestionDeletion\n    ? 'remove'\n    : suggestionUpdate\n      ? 'update'\n      : 'insert';\n\n  const res = {\n    [getSuggestionKey(id)]: {\n      id,\n      createdAt,\n      type,\n      userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n    },\n    [KEYS.suggestion]: true,\n  };\n\n  return res;\n};\n","import {\n  type SlateEditor,\n  type TSuggestionElement,\n  type TSuggestionText,\n  type TText,\n  ElementApi,\n  KEYS,\n  PathApi,\n  TextApi,\n} from 'platejs';\n\nimport type { TResolvedSuggestion } from '../types';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getInlineSuggestionData, getSuggestionKey } from '../utils';\n\nexport const rejectSuggestion = (\n  editor: SlateEditor,\n  description: TResolvedSuggestion\n) => {\n  editor.tf.withoutNormalizing(() => {\n    const mergeNodes = [\n      ...editor.api.nodes({\n        at: [],\n        match: (n) => {\n          if (!ElementApi.isElement(n)) return false;\n\n          if (\n            editor.getApi(BaseSuggestionPlugin).suggestion.isBlockSuggestion(n)\n          ) {\n            const suggestionElement = n as TSuggestionElement;\n            return (\n              suggestionElement.suggestion.type === 'insert' &&\n              suggestionElement.suggestion.isLineBreak &&\n              suggestionElement.suggestion.id === description.suggestionId\n            );\n          }\n\n          return false;\n        },\n      }),\n    ];\n\n    mergeNodes.reverse().forEach(([, path]) => {\n      editor.tf.mergeNodes({ at: PathApi.next(path) });\n    });\n\n    editor.tf.unsetNodes([description.keyId, KEYS.suggestion], {\n      at: [],\n      mode: 'all',\n      match: (n) => {\n        if (TextApi.isText(n)) {\n          const node = n as TSuggestionText;\n          const suggestionData = getInlineSuggestionData(node);\n\n          if (suggestionData)\n            return (\n              suggestionData.type === 'remove' &&\n              suggestionData.id === description.suggestionId\n            );\n\n          return false;\n        }\n        if (\n          ElementApi.isElement(n) &&\n          editor.getApi(BaseSuggestionPlugin).suggestion.isBlockSuggestion(n)\n        ) {\n          const suggestionElement = n as TSuggestionElement;\n          const isLineBreak = suggestionElement.suggestion.isLineBreak;\n\n          if (isLineBreak)\n            return suggestionElement.suggestion.id === description.suggestionId;\n\n          return (\n            suggestionElement.suggestion.type === 'remove' &&\n            suggestionElement.suggestion.id === description.suggestionId\n          );\n        }\n\n        return false;\n      },\n    });\n\n    editor.tf.removeNodes({\n      at: [],\n      mode: 'all',\n      match: (n) => {\n        if (TextApi.isText(n)) {\n          const node = n as TSuggestionText;\n\n          const suggestionData = getInlineSuggestionData(node);\n\n          if (suggestionData)\n            return (\n              suggestionData.type === 'insert' &&\n              suggestionData.id === description.suggestionId\n            );\n\n          return false;\n        }\n\n        if (\n          ElementApi.isElement(n) &&\n          editor.getApi(BaseSuggestionPlugin).suggestion.isBlockSuggestion(n)\n        ) {\n          const suggestionElement = n as TSuggestionElement;\n          return (\n            suggestionElement.suggestion.type === 'insert' &&\n            suggestionElement.suggestion.id === description.suggestionId &&\n            !suggestionElement.suggestion.isLineBreak\n          );\n        }\n\n        return false;\n      },\n    });\n\n    const updateNodes = [\n      ...editor.api.nodes<TText>({\n        at: [],\n        match: (n) => {\n          if (ElementApi.isElement(n)) return false;\n          if (TextApi.isText(n)) {\n            const datalist = editor\n              .getApi(BaseSuggestionPlugin)\n              .suggestion.dataList(n as TSuggestionText);\n\n            if (datalist.length > 0)\n              return datalist.some(\n                (data) =>\n                  data.type === 'update' && data.id === description.suggestionId\n              );\n\n            return false;\n          }\n        },\n      }),\n    ];\n\n    updateNodes.forEach(([node, path]) => {\n      const datalist = editor\n        .getApi(BaseSuggestionPlugin)\n        .suggestion.dataList(node as TSuggestionText);\n      const targetData = datalist.find(\n        (data) => data.type === 'update' && data.id === description.suggestionId\n      );\n\n      if (!targetData) return;\n      if ('newProperties' in targetData) {\n        const unsetProps = Object.keys(targetData.newProperties).filter(\n          (key) => targetData.newProperties[key]\n        );\n\n        editor.tf.unsetNodes([...unsetProps], {\n          at: path,\n        });\n      }\n      if ('properties' in targetData) {\n        const addProps = Object.keys(targetData.properties).filter(\n          (key) => !targetData.properties[key]\n        );\n\n        editor.tf.setNodes(\n          Object.fromEntries(addProps.map((key) => [key, true])),\n          {\n            at: path,\n          }\n        );\n      }\n\n      // remove targetData\n      editor.tf.unsetNodes([getSuggestionKey(targetData.id)], {\n        at: path,\n      });\n    });\n  });\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAA,mBAaO;;;ACbP,IAAAC,kBAMO;;;ACJP,qBAAqB;AAGd,IAAM,qBAAqB,CAAC,SAAgB;AACjD,QAAM,MAAgB,OAAO,KAAK,IAAI,EAAE,OAAO,CAAC,QAAQ;AACtD,WAAO,IAAI,WAAW,GAAG,oBAAK,UAAU,GAAG;AAAA,EAC7C,CAAC;AAED,SAAO,IAAI,GAAG,EAAE;AAClB;AAEO,IAAM,0BAA0B,CAAC,SAAgB;AACtD,QAAM,QAAQ,mBAAmB,IAAI;AAErC,MAAI,CAAC,MAAO;AAEZ,SAAO,KAAK,KAAK;AACnB;AAEO,IAAM,qBAAqB,CAAC,UAAkB;AACnD,SAAO,MAAM,QAAQ,GAAG,oBAAK,UAAU,KAAK,EAAE;AAChD;;;ADZO,IAAM,mBAAmB,CAAC,KAAK,QACpC,GAAG,qBAAK,UAAU,IAAI,EAAE;AAEnB,IAAM,kBAAkB,CAAC,QAC9B,IAAI,WAAW,GAAG,qBAAK,UAAU,GAAG;AAE/B,IAAM,oBAAoB,CAAC,SAAgB;AAChD,QAAM,OAAiB,CAAC;AAExB,SAAO,KAAK,IAAI,EAAE,QAAQ,CAAC,QAAQ;AACjC,QAAI,gBAAgB,GAAG,EAAG,MAAK,KAAK,GAAG;AAAA,EACzC,CAAC;AAED,SAAO;AACT;AAEO,IAAM,2BAA2B,CAAC,YACvC,2BAAU,GAAG,IAAI,IAAI,MAAM,GAAG,qBAAK,UAAU,GAAG,EAAE,CAAC,IAAI;AAElD,IAAM,uBAAuB,CAAC,SAAgB;AACnD,SAAO,kBAAkB,IAAI,EAAE;AAAA,IAC7B,CAAC,QAAQ,yBAAyB,GAAG;AAAA,EACvC;AACF;AAEO,IAAM,sBAAsB,CAAC,SAAgB;AAClD,SAAO,qBAAqB,IAAI,EAAE,CAAC;AACrC;AAEO,IAAM,0BAA0B,CAAC,QAAqB,SAAgB;AAC3E,QAAM,EAAE,cAAc,IAAI,OAAO,WAAW,oBAAoB;AAEhE,SAAO,wBAAwB,IAAI,GAAG,WAAW;AACnD;;;AE5CA,IAAAC,kBAMO;AAEA,IAAM,2BAA2B,CACtC,QACA,cACA,EAAE,KAAK,CAAC,GAAG,GAAG,QAAQ,IAAoC,CAAC,MAE3D,OAAO,IAAI,MAAuB;AAAA,EAChC;AAAA,EACA,GAAG;AAAA,EACH,WAAO;AAAA,IACL;AAAA,IACA,CAAC,MAAM,EAAE,iBAAiB;AAAA,IAC1B;AAAA,EACF;AACF,CAAC;;;ACiBI,IAAM,kCAAkC,CAC7C,WAC6B;AAC7B,QAAM,aAAa,OAAO,OAAO,oBAAoB,EAAE,WAAW,KAAK;AAAA,IACrE,QAAQ;AAAA,EACV,CAAC;AAED,MAAI,CAAC,WAAY,QAAO,CAAC;AAEzB,QAAM,YAAY,WAAW,CAAC;AAC9B,QAAM,eAAe,OAClB,OAAO,oBAAoB,EAC3B,WAAW,OAAO,SAAS;AAE9B,MAAI,CAAC,aAAc,QAAO,CAAC;AAE3B,QAAM,UAAU,qBAAqB,SAAS;AAE9C,SAAO,QAAQ,IAAI,CAAC,WAAW;AAC7B,UAAM,QAAQ,MAAM;AAAA,MAClB,yBAAyB,QAAQ,cAAc;AAAA,QAC7C,OAAO,CAAC,MAAW,EAAE,iBAAiB,MAAM,CAAC;AAAA,MAC/C,CAAC;AAAA,IACH,EAAE,IAAI,CAAC,CAAC,IAAI,MAAM,IAAI;AACtB,UAAM,aAAa,MAAM,OAAO,CAAC,SAAS,CAAC,KAAK,kBAAkB;AAClE,UAAM,YAAY,MAAM,OAAO,CAAC,SAAS,KAAK,kBAAkB;AAChE,UAAM,eAAe,WAAW,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE,KAAK,EAAE;AAChE,UAAM,cAAc,UAAU,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE,KAAK,EAAE;AAE9D,QAAI,WAAW,SAAS,KAAK,UAAU,SAAS,GAAG;AACjD,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN;AAAA,MACF;AAAA,IACF;AACA,QAAI,UAAU,SAAS,GAAG;AACxB,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;AC5FA,IAAAC,mBAMO;;;ACNP,IAAAC,kBAQO;AAEA,IAAM,2BAA2B,CACtC,QACA,UAA0C,CAAC,MAE3C,OAAO,IAAI,KAAsB;AAAA,EAC/B,GAAG;AAAA,EACH,WAAO;AAAA,IACL;AAAA,IACA,CAAC,MAAM,wBAAQ,OAAO,CAAC,KAAM,EAAU,qBAAK,UAAU;AAAA,IACtD;AAAA,EACF;AACF,CAAC;;;ACrBH,IAAAC,kBAQO;AAKA,IAAM,sBAAsB,CACjC,QACA,EAAE,IAAI,KAAK,MAC2B;AACtC,QAAM,eAAe;AAAA,IACnB,QAAI,wBAAO;AAAA,IACX,WAAW,KAAK,IAAI;AAAA,EACtB;AAEA,QAAM,MAAM,OAAO,OAAO,oBAAoB;AAE9C,MAAI,QAAQ,IAAI,WAAW,KAAK;AAAA,IAC9B;AAAA,IACA,QAAQ;AAAA,EACV,CAAC;AAED,MAAI,CAAC,OAAO;AACV,QAAI;AACJ,QAAI;AAEJ,QAAI;AACF,OAAC,OAAO,GAAG,IAAI,OAAO,IAAI,MAAM,EAAE;AAAA,IACpC,QAAQ;AACN,aAAO;AAAA,IACT;AAEA,UAAM,YAAY,OAAO,IAAI,MAAM,GAAG;AAEtC,QAAI,WAAW;AACb,cAAQ,IAAI,WAAW,KAAK;AAAA,QAC1B,IAAI;AAAA,QACJ,QAAQ;AAAA,MACV,CAAC;AAED,UAAI,CAAC,OAAO;AACV,cAAM,YAAY,OAAO,IAAI,OAAO,KAAK;AAEzC,YAAI,WAAW;AACb,kBAAQ,IAAI,WAAW,KAAK;AAAA,YAC1B,IAAI;AAAA,YACJ,QAAQ;AAAA,UACV,CAAC;AAAA,QACH;AAKA,YAAI,CAAC,SAAS,OAAO,IAAI,QAAQ,OAAO,EAAE,GAAG;AAC3C,gBAAM,MAAM,aAAa;AAEzB,gBAAM,YAAY,OAAO,IAAI,MAA0B,EAAE,IAAI,IAAI,CAAC;AAElE,gBAAM,gBAAgB,YAAY,CAAC,EAAE;AAErC,cAAI,eAAe,aAAa;AAC9B,mBAAO;AAAA,cACL,IAAI,eAAe,UAAM,wBAAO;AAAA,cAChC,WAAW,eAAe,aAAa,KAAK,IAAI;AAAA,YAClD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MACE,SACA,wBAAwB,MAAM,CAAC,CAAC,GAAG,SAAS,QAC5C,wBAAwB,QAAQ,MAAM,CAAC,CAAC,GACxC;AACA,WAAO;AAAA,MACL,IAAI,IAAI,WAAW,OAAO,MAAM,CAAC,CAAC,SAAK,wBAAO;AAAA,MAC9C,WAAW,wBAAwB,MAAM,CAAC,CAAC,GAAG,aAAa,KAAK,IAAI;AAAA,IACtE;AAAA,EACF;AAEA,SAAO;AACT;;;AC1FA,IAAAC,kBAAoE;AAKpE,IAAM,kBAAkB,MAAM;AAC5B,QAAM,eAAe;AAAA,IACnB,QAAI,wBAAO;AAAA,IACX,WAAW,KAAK,IAAI;AAAA,EACtB;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB,CAC/B,QACA,KACA,UACG;AACH,SAAO,OAAO,oBAAoB,EAAE,WAAW,mBAAmB,MAAM;AACtE,UAAM,EAAE,IAAI,UAAU,IAAI,gBAAgB;AAE1C,UAAM,QAAQ,CAAC,MAAa;AAC1B,UAAI,CAAC,wBAAQ,OAAO,CAAC,EAAG,QAAO;AAE/B,UAAI,EAAE,qBAAK,UAAU,GAAG;AACtB,cAAM,OAAO,wBAAwB,CAAC;AAEtC,YAAI,MAAM,SAAS,UAAU;AAC3B,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IACT;AAEA,WAAO,GAAG;AAAA,MACR;AAAA,QACE,CAAC,GAAG,GAAG;AAAA,QACP,CAAC,iBAAiB,EAAE,CAAC,GAAG;AAAA,UACtB;AAAA,UACA;AAAA,UACA,eAAe;AAAA,YACb,CAAC,GAAG,GAAG;AAAA,UACT;AAAA,UACA,MAAM;AAAA,UACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,QAClD;AAAA,QACA,CAAC,qBAAK,UAAU,GAAG;AAAA,MACrB;AAAA,MACA;AAAA,QACE;AAAA,QACA,OAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;AC1DA,IAAAC,kBAWO;;;ACXP,IAAAC,kBASO;AAKA,IAAM,qBAAqB,CAChC,QACA,YAKG;AACH,QAAM,SAAK,uBAAM,QAAQ,SAAS,EAAE,KAAK,OAAO;AAEhD,MAAI,CAAC,GAAI;AAET,QAAM,EAAE,mBAAe,wBAAO,EAAE,IAAI,WAAW,CAAC;AAGhD,QAAM,eAAe,OAAO,IAAI,MAAM;AAAA,IACpC,OAAO,CAAC,MAAM,2BAAW,UAAU,CAAC,KAAK,OAAO,IAAI,SAAS,CAAC;AAAA,IAC9D,GAAG;AAAA,EACL,CAAC;AACD,QAAM,cAAc,CAAC,GAAG,YAAY;AAEpC,SAAO,GAAG,mBAAmB,MAAM;AACjC,UAAM,OAA8B;AAAA,MAClC,IAAI;AAAA,MACJ,WAAW,SAAS,aAAa,KAAK,IAAI;AAAA,MAC1C,MAAM;AAAA,MACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,IAClD;AAEA,UAAM,QAAQ;AAAA,MACZ,CAAC,iBAAiB,YAAY,CAAC,GAAG;AAAA,MAClC,CAAC,qBAAK,UAAU,GAAG;AAAA,IACrB;AAEA,WAAO,GAAG,SAAS,OAAO;AAAA,MACxB;AAAA,MACA,OAAO;AAAA,IACT,CAAC;AAED,gBAAY,QAAQ,CAAC,CAAC,EAAE,IAAI,MAAM;AAChC,aAAO,GAAG,SAA0B,OAAO;AAAA,QACzC,IAAI;AAAA,QACJ,OAAO,CAAC,MAAM,2BAAW,UAAU,CAAC,KAAK,OAAO,IAAI,SAAS,CAAC;AAAA,QAC9D,GAAG;AAAA,MACL,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH;;;ADvCO,IAAM,mBAAmB,CAC9B,QACA,IACA;AAAA,EACE;AACF,IAEI,CAAC,MACF;AACH,MAAI;AAEJ,SAAO,GAAG,mBAAmB,MAAM;AACjC,UAAM,EAAE,QAAQ,MAAM,OAAO,GAAG,IAAI;AAEpC,UAAM,EAAE,IAAI,UAAqB,IAAI,oBAAoB,QAAQ;AAAA,MAC/D,IAAI;AAAA,MACJ,MAAM;AAAA,IACR,CAAC;AAED,YAAQ;AAER,UAAM,QAAQ,OAAO,IAAI,SAAS,EAAE;AAEpC,QAAI;AAEJ,WAAO,MAAM;AACX,qBAAe,OAAO,WAAW;AAEjC,UAAI,CAAC,aAAc;AAEnB,YAAM,cAAc,MAAM;AAE1B,UAAI,CAAC,YAAa;AAElB,UACE,CAAC,OAAO,IAAI,KAAK;AAAA,QACf,IAAI,EAAE,QAAQ,cAAc,OAAO,YAAY;AAAA,QAC/C,QAAQ;AAAA,MACV,CAAC,GACD;AAEA,cAAM,MAAM,OAAO,IAAI;AAAA,UACrB,UACI;AAAA,YACE,QAAQ;AAAA,YACR,OAAO;AAAA,UACT,IACA;AAAA,YACE,QAAQ;AAAA,YACR,OAAO;AAAA,UACT;AAAA,QACN;AAEA,YAAI,IAAI,WAAW,EAAG;AAAA,MACxB;AAEA,YAAM,WAAW,UAAU,OAAO,IAAI,SAAS,OAAO,IAAI;AAE1D,YAAM,YAA+B,SAAS,cAAc;AAAA,QAC1D,MAAM;AAAA,MACR,CAAC;AAED,UAAI,CAAC,UAAW;AAEhB,UAAI,QAAgB,UAChB;AAAA,QACE,QAAQ;AAAA,QACR,OAAO;AAAA,MACT,IACA;AAAA,QACE,QAAQ;AAAA,QACR,OAAO;AAAA,MACT;AACJ,cAAQ,OAAO,IAAI,YAAY,OAAO,EAAE,WAAW,KAAK,CAAC;AAGzD,YAAM,aAAa,OAAO,IAAI,KAAe;AAAA,QAC3C,IAAI;AAAA,QACJ,OAAO;AAAA,QACP,OAAO,CAAC,MACN,EAAE,qBAAK,UAAU,KACjB,wBAAQ,OAAO,CAAC,KAChB,wBAAwB,CAAC,GAAG,SAAS,YACrC,wBAAwB,QAAQ,CAAC;AAAA,MACrC,CAAC;AAED,UACE,cACA,OAAO,IAAI,QAAQ,cAAc,WAAW,CAAC,CAAC,KAC9C,OAAO,IAAI,QAAQ,WAAW,CAAC,CAAQ,GACvC;AACA,eAAO,GAAG,YAAY;AAAA,UACpB,IAAI,WAAW,CAAC;AAAA,QAClB,CAAC;AAED;AAAA,MACF;AAEA,UAAI,OAAO,IAAI,KAAK,EAAE,IAAI,OAAO,QAAQ,KAAK,CAAC,GAAG;AAChD,cAAM,oBAAoB,OAAO,IAAI,MAAM,EAAE,IAAI,MAAM,OAAO,CAAC;AAE/D,YAAI,qBAAqB,2BAAW,UAAU,kBAAkB,CAAC,CAAC,GAAG;AACnE,gBAAM,oBAAoB,OACvB,OAAO,oBAAoB,EAC3B,WAAW,kBAAkB,kBAAkB,CAAC,CAAC;AAEpD,cAAI,mBAAmB;AACrB,kBAAM,OAAO,kBAAkB,CAAC;AAEhC,gBAAI,KAAK,WAAW,SAAS,UAAU;AACrC,qBACG,OAAO,oBAAoB,EAC3B,WAAW,mBAAmB,MAAM;AACnC,uBAAO,GAAG,WAAW,CAAC,qBAAK,UAAU,GAAG;AAAA,kBACtC,IAAI,kBAAkB,CAAC;AAAA,gBACzB,CAAC;AACD,uBAAO,GAAG,WAAW;AAAA,kBACnB,IAAI,wBAAQ,KAAK,kBAAkB,CAAC,CAAC;AAAA,gBACvC,CAAC;AAAA,cACH,CAAC;AAAA,YACL;AACA,gBAAI,KAAK,WAAW,SAAS,UAAU;AACrC,qBAAO,GAAG,KAAK;AAAA,gBACb;AAAA,gBACA,MAAM;AAAA,cACR,CAAC;AAAA,YACH;AACA;AAAA,UACF;AAEA,cAAI,CAAC,mBAAmB;AACtB,mBAAO,GAAG;AAAA,cACR;AAAA,gBACE,CAAC,qBAAK,UAAU,GAAG;AAAA,kBACjB;AAAA,kBACA;AAAA,kBACA,MAAM;AAAA,kBACN,QACE,OAAO,WAAW,oBAAoB,EAAE;AAAA,gBAC5C;AAAA,cACF;AAAA,cACA,EAAE,IAAI,kBAAkB,CAAC,EAAE;AAAA,YAC7B;AACA,mBAAO,GAAG,KAAK;AAAA,cACb;AAAA,cACA,MAAM;AAAA,YACR,CAAC;AACD;AAAA,UACF;AAAA,QACF;AAEA;AAAA,MACF;AAEA,UAAI,yBAAS,OAAO,cAAc,OAAO,UAAW,MAAM,GAAG;AAC3D,eAAO,GAAG,KAAK;AAAA,UACb;AAAA,UACA,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAGA,YAAM,YAAY,OAAO,OAAO,oBAAoB,EAAE,WAAW,KAAK;AAAA,QACpE,IAAI;AAAA,QACJ,QAAQ;AAAA,QACR,OAAO,CAAC,MACN,wBAAQ,OAAO,CAAC,KAChB,wBAAwB,CAAC,GAAG,SAAS,YACrC,wBAAwB,QAAQ,CAAC;AAAA,MACrC,CAAC;AAED,UAAI,WAAW;AACb,eAAO,GAAG,OAAO,EAAE,IAAI,OAAO,MAAM,YAAY,CAAC;AAEjD;AAAA,MACF;AAEA,yBAAmB,QAAQ;AAAA,QACzB,IAAI;AAAA,QACJ;AAAA,QACA,oBAAoB;AAAA,QACpB,cAAc;AAAA,MAChB,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AAED,SAAO;AACT;;;AE7MO,IAAM,2BAA2B,CACtC,QACA,EAAE,QAAQ,IAA2B,CAAC,MACnC;AACH,MAAI;AAEJ,SAAO,GAAG,mBAAmB,MAAM;AACjC,UAAM,YAAY,OAAO;AAEzB,UAAM,CAAC,OAAO,GAAG,IAAI,OAAO,IAAI,MAAM,SAAS;AAE/C,QAAI,SAAS;AACX,aAAO,GAAG,SAAS,EAAE,MAAM,MAAM,CAAC;AAClC,cAAQ;AAAA,QACN;AAAA,QACA,EAAE,QAAQ,KAAK,OAAO,MAAM;AAAA,QAC5B,EAAE,SAAS,KAAK;AAAA,MAClB;AAAA,IACF,OAAO;AACL,aAAO,GAAG,SAAS,EAAE,MAAM,QAAQ,CAAC;AACpC,cAAQ,iBAAiB,QAAQ,EAAE,QAAQ,OAAO,OAAO,IAAI,CAAC;AAAA,IAChE;AAAA,EACF,CAAC;AAED,SAAO;AACT;;;AC7BA,IAAAC,kBAAiE;AAO1D,IAAM,2BAA2B,CACtC,QACA,UACA;AAAA,EACE,iBAAiB,OAAO,GAAG;AAC7B,IAEI,CAAC,MACF;AACH,SAAO,GAAG,mBAAmB,MAAM;AACjC,6BAAyB,MAAM;AAE/B,UAAM,EAAE,IAAI,UAAqB,IAAI,oBAAoB,QAAQ;AAAA,MAC/D,IAAI,OAAO;AAAA,MACX,MAAM;AAAA,IACR,CAAC;AAED,aAAS,QAAQ,CAAC,MAAM;AACtB,UAAI,wBAAQ,OAAO,CAAC,GAAG;AACrB,YAAI,CAAC,EAAE,qBAAK,UAAU,GAAG;AAEvB,YAAE,qBAAK,UAAU,IAAI;AAAA,QACvB;AAGA,cAAM,gBAAgB,kBAAkB,CAAC;AACzC,sBAAc,QAAQ,CAAC,QAAQ;AAC7B,iBAAO,EAAE,GAAG;AAAA,QACd,CAAC;AAED,UAAE,iBAAiB,EAAE,CAAC,IAAI;AAAA,UACxB;AAAA,UACA;AAAA,UACA,MAAM;AAAA,UACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,QAClD;AAAA,MACF,OAAO;AACL,UAAE,qBAAK,UAAU,IAAI;AAAA,UACnB;AAAA,UACA;AAAA,UACA,MAAM;AAAA,UACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,QAClD;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO,OAAO,oBAAoB,EAAE,WAAW,mBAAmB,MAAM;AACtE,qBAAe,QAAQ;AAAA,IACzB,CAAC;AAAA,EACH,CAAC;AACH;;;AClDO,IAAM,uBAAuB,CAAC,QAAqB,SAAiB;AACzE,SAAO,GAAG,mBAAmB,MAAM;AACjC,QAAI;AACJ,UAAM,EAAE,IAAI,UAAqB,IAAI,oBAAoB,QAAQ;AAAA,MAC/D,IAAI,OAAO;AAAA,MACX,MAAM;AAAA,IACR,CAAC;AAED,QAAI,OAAO,IAAI,WAAW,GAAG;AAC3B,cAAQ,yBAAyB,MAAM;AAAA,IACzC;AAEA,WAAO,OAAO,oBAAoB,EAAE,WAAW,mBAAmB,MAAM;AACtE,aAAO,GAAG;AAAA,QACR;AAAA,UACE,CAAC,iBAAiB,SAAS,EAAE,CAAC,GAAG;AAAA,YAC/B,IAAI,SAAS;AAAA,YACb;AAAA,YACA,MAAM;AAAA,YACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,UAClD;AAAA,UACA,YAAY;AAAA,UACZ;AAAA,QACF;AAAA,QACA;AAAA,UACE,IAAI,OAAO;AAAA,UACX,QAAQ;AAAA,QACV;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;;;ACtCA,IAAAC,mBAAoE;AAKpE,IAAM,qBAAqB,MAAM;AAC/B,QAAM,eAAe;AAAA,IACnB,QAAI,yBAAO;AAAA,IACX,WAAW,KAAK,IAAI;AAAA,EACtB;AAEA,SAAO;AACT;AAGO,IAAM,uBAAuB,CAAC,QAAqB,QAAgB;AACxE,SAAO,OAAO,oBAAoB,EAAE,WAAW,mBAAmB,MAAM;AACtE,UAAM,EAAE,IAAI,UAAU,IAAI,mBAAmB;AAE7C,UAAM,QAAQ,CAAC,MAAa;AAC1B,UAAI,CAAC,yBAAQ,OAAO,CAAC,EAAG,QAAO;AAE/B,UAAI,EAAE,sBAAK,UAAU,GAAG;AACtB,cAAM,OAAO,wBAAwB,CAAC;AAEtC,YAAI,MAAM,SAAS,UAAU;AAC3B,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IACT;AAEA,WAAO,GAAG,WAAW,KAAK;AAAA,MACxB;AAAA,IACF,CAAC;AAED,WAAO,GAAG;AAAA,MACR;AAAA,QACE,CAAC,iBAAiB,EAAE,CAAC,GAAG;AAAA,UACtB;AAAA,UACA;AAAA,UACA,YAAY;AAAA,YACV,CAAC,GAAG,GAAG;AAAA,UACT;AAAA,UACA,MAAM;AAAA,UACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,QAClD;AAAA,QACA,CAAC,sBAAK,UAAU,GAAG;AAAA,MACrB;AAAA,MACA;AAAA,QACE;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;ACvDA,IAAAC,mBAAqB;AAId,IAAM,wBAAwB,CACnC,QACA,UACG;AACH,MAAI,MAAM,WAAW,EAAG;AAExB,QAAM,EAAE,IAAI,UAAU,IAAI,oBAAoB,QAAQ;AAAA,IACpD,IAAI,OAAO;AAAA,IACX,MAAM;AAAA,EACR,CAAC;AAED,QAAM,QAAQ,CAAC,CAAC,EAAE,SAAS,MAAM;AAC/B,WAAO,GAAG;AAAA,MACR;AAAA,QACE,CAAC,sBAAK,UAAU,GAAG;AAAA,UACjB;AAAA,UACA;AAAA,UACA,MAAM;AAAA,QACR;AAAA,MACF;AAAA,MACA,EAAE,IAAI,UAAU;AAAA,IAClB;AAAA,EACF,CAAC;AACH;;;AVPO,IAAM,iBAAuD,CAAC;AAAA,EACnE;AAAA,EACA;AAAA,EACA;AAAA,EACA,IAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF,OAAO;AAAA,EACL,YAAY;AAAA,IACV,QAAQ,KAAK,OAAO;AAClB,UAAI,WAAW,EAAE,gBAAgB,IAAI,WAAW,GAAG;AACjD,eAAO,kBAAkB,QAAQ,KAAK,KAAK;AAAA,MAC7C;AAEA,aAAO,QAAQ,KAAK,KAAK;AAAA,IAC3B;AAAA,IACA,MAAM,WAAW;AACf,aAAO,MAAM,SAAS;AAAA,IACxB;AAAA,IACA,eAAe,MAAM;AACnB,YAAM,YAAY,OAAO;AACzB,YAAM,cAAc,OAAO,IAAI,OAAO,WAAW,EAAE,KAAK,CAAC;AAEzD,UAAI,WAAW,EAAE,cAAc;AAC7B,cAAM,OAAO,OAAO,IAAI,MAA0B;AAElD,YAAI,OAAO,CAAC,EAAE,sBAAK,UAAU,KAAK,CAAC,OAAO,CAAC,EAAE,WAAW,aAAa;AACnE,iBAAO,eAAe,IAAI;AAAA,QAC5B;AAEA,YAAI,CAAC,YAAa;AAElB;AAAA,UACE;AAAA,UACA,EAAE,QAAQ,UAAU,QAAQ,OAAO,YAAY;AAAA,UAC/C,EAAE,SAAS,KAAK;AAAA,QAClB;AAEA;AAAA,MACF,OAAO;AAEL,YAAI,aAAa;AACf,gBAAM,eAAe,OAAO,IAAI,KAAK;AAAA,YACnC,IAAI,EAAE,QAAQ,UAAU,QAAQ,OAAO,YAAY;AAAA,YACnD,QAAQ;AAAA,UACV,CAAC;AAED,cAAI,cAAc;AAChB,mBAAO,GAAG,WAAW,CAAC,sBAAK,UAAU,GAAG;AAAA,cACtC,IAAI;AAAA,YACN,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA,qBAAe,IAAI;AAAA,IACrB;AAAA,IACA,cAAc,MAAM;AAClB,UAAI,WAAW,EAAE,cAAc;AAC7B,cAAM,YAAY,OAAO;AACzB,cAAM,cAAc,OAAO,IAAI,MAAM,WAAW,EAAE,KAAK,CAAC;AAExD,YAAI,CAAC,YAAa;AAElB,yBAAiB,QAAQ;AAAA,UACvB,QAAQ,UAAU;AAAA,UAClB,OAAO;AAAA,QACT,CAAC;AAED;AAAA,MACF;AAEA,oBAAc,IAAI;AAAA,IACpB;AAAA,IAEA,eAAe,WAAW;AACxB,UAAI,WAAW,EAAE,cAAc;AAC7B,iCAAyB,QAAQ,EAAE,SAAS,KAAK,CAAC;AAElD;AAAA,MACF;AAEA,qBAAe,SAAS;AAAA,IAC1B;AAAA,IAEA,cAAc;AACZ,UAAI,WAAW,EAAE,cAAc;AAC7B,cAAM,CAAC,MAAM,IAAI,IAAI,OAAO,IAAI,MAAM;AAEtC,YAAI,KAAK,SAAS,KAAK,KAAK,SAAS,OAAO,QAAQ,sBAAK,CAAC,GAAG;AAC3D,iBAAO,qBAAqB,QAAQ,IAAI;AAAA,QAC1C;AAEA,cAAM,EAAE,IAAI,UAAU,IAAI,oBAAoB,QAAQ;AAAA,UACpD,IAAI,OAAO;AAAA,UACX,MAAM;AAAA,QACR,CAAC;AAED,oBAAY;AAEZ,eAAO,GAAG,eAAe,MAAM;AAC7B,iBAAO,GAAG;AAAA,YACR;AAAA,cACE,CAAC,sBAAK,UAAU,GAAG;AAAA,gBACjB;AAAA,gBACA;AAAA,gBACA,aAAa;AAAA,gBACb,MAAM;AAAA,gBACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,cAClD;AAAA,YACF;AAAA,YACA,EAAE,IAAI,KAAK;AAAA,UACb;AAAA,QACF,CAAC;AAED;AAAA,MACF;AAEA,kBAAY;AAAA,IACd;AAAA,IAEA,eAAe,UAAU;AACvB,UAAI,WAAW,EAAE,cAAc;AAC7B,iCAAyB,QAAQ,UAAU,EAAE,eAAe,CAAC;AAE7D;AAAA,MACF;AAEA,qBAAe,QAAQ;AAAA,IACzB;AAAA,IAEA,YAAY,OAAO,SAAS;AAC1B,UAAI,WAAW,EAAE,cAAc;AAC7B,cAAM,aAAa,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAGxD,YAAI,WAAW,KAAK,CAAC,MAAM,EAAE,SAAS,aAAa,GAAG;AACpD,cAAI,WAAW,mBAAmB,MAAM;AACtC,wBAAY,OAAO,OAAO;AAAA,UAC5B,CAAC;AAED;AAAA,QACF;AAEA,cAAM,kBAAkB,WAAW,IAAI,CAAC,SAAS;AAC/C,iBAAO;AAAA,YACL,GAAG;AAAA,YACH,CAAC,sBAAK,UAAU,GAAG;AAAA,cACjB,QAAI,yBAAO;AAAA,cACX,WAAW,KAAK,IAAI;AAAA,cACpB,MAAM;AAAA,cACN,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,YAClD;AAAA,UACF;AAAA,QACF,CAAC;AAED,eAAO,YAAY,iBAAiB,OAAO;AAAA,MAC7C;AAEA,aAAO,YAAY,OAAO,OAAO;AAAA,IACnC;AAAA,IAEA,WAAW,MAAM,SAAS;AACxB,UAAI,WAAW,EAAE,cAAc;AAC7B,cAAM,OAAO,OAAO,IAAI,MAA0B;AAElD,YAAI,OAAO,CAAC,EAAE,sBAAK,UAAU,KAAK,CAAC,OAAO,CAAC,EAAE,WAAW,aAAa;AACnE,iBAAO,WAAW,MAAM,OAAO;AAAA,QACjC;AAEA,6BAAqB,QAAQ,IAAI;AAEjC;AAAA,MACF;AAEA,iBAAW,MAAM,OAAO;AAAA,IAC1B;AAAA,IAEA,cAAc,OAAO;AACnB,UAAI,WAAW,mBAAmB,MAAM;AACtC,cAAM,CAAC,MAAM,IAAI,IAAI;AAErB,YACE,KAAK,sBAAK,UAAU;AAAA,QACpB,yBAAQ,OAAO,IAAI,KACnB,CAAC,mBAAmB,IAAI,GACxB;AACA,iBAAO,GAAG,WAAW,CAAC,sBAAK,YAAY,gBAAgB,GAAG;AAAA,YACxD,IAAI;AAAA,UACN,CAAC;AAED;AAAA,QACF;AAEA,YACE,KAAK,sBAAK,UAAU,KACpB,yBAAQ,OAAO,IAAI,KACnB,CAAC,wBAAwB,IAAI,GAAG,QAChC;AACA,cAAI,wBAAwB,IAAI,GAAG,SAAS,UAAU;AAEpD,mBAAO,GAAG,WAAW,CAAC,sBAAK,YAAY,mBAAmB,IAAI,CAAE,GAAG;AAAA,cACjE,IAAI;AAAA,YACN,CAAC;AAAA,UACH,OAAO;AAEL,mBAAO,GAAG,YAAY,EAAE,IAAI,KAAK,CAAC;AAAA,UACpC;AAEA;AAAA,QACF;AAEA,sBAAc,KAAK;AAAA,MACrB,CAAC;AAAA,IACH;AAAA,IACA,WAAW,KAAK;AACd,UAAI,WAAW,EAAE,gBAAgB,IAAI,WAAW,GAAG;AACjD,eAAO,qBAAqB,QAAQ,GAAG;AAAA,MACzC;AAEA,aAAO,WAAW,GAAG;AAAA,IACvB;AAAA;AAAA,IAEA,YAAY,SAAS;AACnB,UAAI,WAAW,EAAE,cAAc;AAC7B,cAAM,QAAQ,CAAC,GAAG,OAAO,IAAI,MAAM,OAAO,CAAC;AAE3C,YAAI,MAAM,KAAK,CAAC,CAAC,CAAC,MAAM,EAAE,SAAS,aAAa,GAAG;AACjD,cAAI,WAAW,mBAAmB,MAAM;AACtC,wBAAY,OAAO;AAAA,UACrB,CAAC;AAED;AAAA,QACF;AAEA,eAAO,sBAAsB,QAAQ,KAAK;AAAA,MAC5C;AAEA,aAAO,YAAY,OAAO;AAAA,IAC5B;AAAA,EACF;AACF;;;ALpOO,IAAM,2BAAuB,qCAAyC;AAAA,EAC3E,KAAK,sBAAK;AAAA,EACV,MAAM,EAAE,QAAQ,KAAK;AAAA,EACrB,SAAS;AAAA,IACP,eAAe;AAAA,IACf,cAAc;AAAA,EAChB;AAAA,EACA,OAAO,EAAE,WAAW,EAAE,UAAU,UAAU,EAAE;AAC9C,CAAC,EACE,eAAe,cAAc,EAC7B;AAAA,EACC,CAAC,EAAE,KAAK,QAAQ,WAAW,WAAW,KAAK,OAAO;AAAA,IAChD,UAAU,CAAC,SAAmD;AAC5D,aAAO,OAAO,KAAK,IAAI,EACpB,OAAO,CAAC,QAAQ;AACf,eAAO,IAAI,WAAW,GAAG,sBAAK,UAAU,GAAG;AAAA,MAC7C,CAAC,EACA,IAAI,CAAC,QAAQ,KAAK,GAAG,CAA0B;AAAA,IACpD;AAAA,IACA,mBAAmB,CAAC,SAClB,4BAAW,UAAU,IAAI,KAAK,gBAAgB;AAAA,IAChD,MAAM,CAAC,UAAU,CAAC,MAAM;AACtB,YAAM,EAAE,IAAI,QAAQ,GAAG,KAAK,IAAI;AAChC,YAAM,SAAS,OAAO,IAAI,KAA2C;AAAA,QACnE,OAAO,CAAC,MAAM;AACZ,cAAI,CAAC,EAAE,IAAI,EAAG,QAAO;AACrB,cAAI,UAAU,CAAC,yBAAQ,OAAO,CAAC,EAAG,QAAO;AACzC,cAAI,IAAI;AACN,gBAAI,yBAAQ,OAAO,CAAC,GAAG;AACrB,qBAAO,CAAC,CAAC,EAAE,iBAAiB,EAAE,CAAC;AAAA,YACjC;AACA,gBACE,4BAAW,UAAU,CAAC,KACtB,IAAI,WAAW,kBAAkB,CAAC,GAClC;AACA,qBAAO,EAAE,WAAW,OAAO;AAAA,YAC7B;AAAA,UACF;AAEA,iBAAO;AAAA,QACT;AAAA,QACA,GAAG;AAAA,MACL,CAAC;AAED,aAAO;AAAA,IACT;AAAA,IACA,QAAQ,CAAC,SAAS;AAChB,UAAI,yBAAQ,OAAO,IAAI,GAAG;AACxB,cAAM,QAAQ,mBAAmB,IAAI;AAErC,YAAI,CAAC,MAAO;AAEZ,eAAO,MAAM,QAAQ,GAAG,IAAI,KAAK,EAAE;AAAA,MACrC;AAEA,UAAI,IAAI,WAAW,kBAAkB,IAAI,GAAG;AAC1C,eAAO,KAAK,WAAW;AAAA,MACzB;AAAA,IACF;AAAA,IACA,OAAO,CAAC,UAAU,CAAC,MAAM;AACvB,YAAM,SAAK,wBAAM,QAAQ,QAAQ,EAAE,KAAK,CAAC;AAEzC,aAAO;AAAA,QACL,GAAG,OAAO,IAAI,MAAkC;AAAA,UAC9C,GAAG;AAAA,UACH;AAAA,UACA,MAAM;AAAA,UACN,OAAO,CAAC,MAAM,EAAE,IAAI;AAAA,QACtB,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,gBAAgB,CAAC,SAAS;AACxB,UAAI,yBAAQ,OAAO,IAAI,GAAG;AACxB,cAAM,QAAQ,mBAAmB,IAAI;AAErC,YAAI,CAAC,MAAO;AAEZ,eAAO,KAAK,KAAK;AAAA,MACnB;AAEA,UAAI,IAAI,WAAW,kBAAkB,IAAI,GAAG;AAC1C,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,IACA,oBAAoB,CAAC,OAAO;AAC1B,YAAM,OAAO,UAAU,cAAc;AACrC,gBAAU,gBAAgB,KAAK;AAC/B,SAAG;AACH,gBAAU,gBAAgB,IAAI;AAAA,IAChC;AAAA,EACF;AACF;;;AgBzIF,kBAAqD;AACrD,IAAAC,mBAQO;;;ACTP,IAAAC,mBAQO;AAOA,IAAM,mBAAmB,CAC9B,QACA,gBACG;AACH,SAAO,GAAG,mBAAmB,MAAM;AACjC,UAAM,aAAa;AAAA,MACjB,GAAG,OAAO,IAAI,MAAM;AAAA,QAClB,IAAI,CAAC;AAAA,QACL,OAAO,CAAC,MAAM;AACZ,cAAI,CAAC,4BAAW,UAAU,CAAC,EAAG,QAAO;AAErC,cACE,OAAO,OAAO,oBAAoB,EAAE,WAAW,kBAAkB,CAAC,GAClE;AACA,kBAAM,oBAAoB;AAC1B,mBACE,kBAAkB,WAAW,SAAS,YACtC,kBAAkB,WAAW,eAC7B,kBAAkB,WAAW,OAAO,YAAY;AAAA,UAEpD;AAEA,iBAAO;AAAA,QACT;AAAA,MACF,CAAC;AAAA,IACH;AAEA,eAAW,QAAQ,EAAE,QAAQ,CAAC,CAAC,EAAE,IAAI,MAAM;AACzC,aAAO,GAAG,WAAW,EAAE,IAAI,yBAAQ,KAAK,IAAI,EAAE,CAAC;AAAA,IACjD,CAAC;AAED,WAAO,GAAG,WAAW,CAAC,YAAY,OAAO,sBAAK,UAAU,GAAG;AAAA,MACzD,IAAI,CAAC;AAAA,MACL,MAAM;AAAA,MACN,OAAO,CAAC,MAAM;AACZ,YAAI,yBAAQ,OAAO,CAAC,GAAG;AACrB,gBAAM,qBAAqB,OACxB,OAAO,oBAAoB,EAC3B,WAAW,SAAS,CAAoB;AAC3C,gBAAM,gBAAgB,mBAAmB;AAAA,YACvC,CAAC,SAAS,KAAK,SAAS;AAAA,UAC1B;AAEA,cAAI,eAAe;AACjB,mBAAO,mBAAmB;AAAA,cACxB,CAAC,MAAM,EAAE,OAAO,YAAY;AAAA,YAC9B;AAAA,UACF,OAAO;AACL,kBAAM,iBAAiB,wBAAwB,CAAC;AAEhD,gBAAI;AACF,qBACE,eAAe,SAAS,YACxB,eAAe,OAAO,YAAY;AAAA,UAExC;AAEA,iBAAO;AAAA,QACT;AACA,YACE,4BAAW,UAAU,CAAC,KACtB,OAAO,OAAO,oBAAoB,EAAE,WAAW,kBAAkB,CAAC,GAClE;AACA,gBAAM,oBAAoB;AAC1B,gBAAM,iBAAiB,kBAAkB;AAEzC,cAAI,gBAAgB;AAClB,kBAAM,cAAc,eAAe;AAEnC,gBAAI;AACF,qBAAO,eAAe,OAAO,YAAY;AAE3C,mBACE,eAAe,SAAS,YACxB,eAAe,OAAO,YAAY;AAAA,UAEtC;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAED,WAAO,GAAG,YAAY;AAAA,MACpB,IAAI,CAAC;AAAA,MACL,MAAM;AAAA,MACN,OAAO,CAAC,MAAM;AACZ,YAAI,yBAAQ,OAAO,CAAC,GAAG;AACrB,gBAAM,iBAAiB,wBAAwB,CAAC;AAEhD,cAAI,gBAAgB;AAClB,mBACE,eAAe,SAAS,YACxB,eAAe,OAAO,YAAY;AAAA,UAEtC;AAEA,iBAAO;AAAA,QACT;AAEA,YACE,4BAAW,UAAU,CAAC,KACtB,OAAO,OAAO,oBAAoB,EAAE,WAAW,kBAAkB,CAAC,GAClE;AACA,gBAAM,oBAAoB;AAC1B,gBAAM,iBAAiB,kBAAkB;AAEzC,cAAI,gBAAgB;AAClB,kBAAM,cAAc,eAAe;AAEnC,mBACE,eAAe,SAAS,YACxB,eAAe,OAAO,YAAY,gBAClC,CAAC;AAAA,UAEL;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;;;ACvIA,IAAAC,mBAAqB;AAKd,IAAM,qBAAqB,CAChC,QACA,IACA;AAAA,EACE,YAAY,KAAK,IAAI;AAAA,EACrB;AAAA,EACA;AACF,IAII,CAAC,MACF;AACH,QAAM,OAAO,qBACT,WACA,mBACE,WACA;AAEN,QAAM,MAAM;AAAA,IACV,CAAC,iBAAiB,EAAE,CAAC,GAAG;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ,OAAO,WAAW,oBAAoB,EAAE;AAAA,IAClD;AAAA,IACA,CAAC,sBAAK,UAAU,GAAG;AAAA,EACrB;AAEA,SAAO;AACT;;;ACrCA,IAAAC,mBASO;AAOA,IAAM,mBAAmB,CAC9B,QACA,gBACG;AACH,SAAO,GAAG,mBAAmB,MAAM;AACjC,UAAM,aAAa;AAAA,MACjB,GAAG,OAAO,IAAI,MAAM;AAAA,QAClB,IAAI,CAAC;AAAA,QACL,OAAO,CAAC,MAAM;AACZ,cAAI,CAAC,4BAAW,UAAU,CAAC,EAAG,QAAO;AAErC,cACE,OAAO,OAAO,oBAAoB,EAAE,WAAW,kBAAkB,CAAC,GAClE;AACA,kBAAM,oBAAoB;AAC1B,mBACE,kBAAkB,WAAW,SAAS,YACtC,kBAAkB,WAAW,eAC7B,kBAAkB,WAAW,OAAO,YAAY;AAAA,UAEpD;AAEA,iBAAO;AAAA,QACT;AAAA,MACF,CAAC;AAAA,IACH;AAEA,eAAW,QAAQ,EAAE,QAAQ,CAAC,CAAC,EAAE,IAAI,MAAM;AACzC,aAAO,GAAG,WAAW,EAAE,IAAI,yBAAQ,KAAK,IAAI,EAAE,CAAC;AAAA,IACjD,CAAC;AAED,WAAO,GAAG,WAAW,CAAC,YAAY,OAAO,sBAAK,UAAU,GAAG;AAAA,MACzD,IAAI,CAAC;AAAA,MACL,MAAM;AAAA,MACN,OAAO,CAAC,MAAM;AACZ,YAAI,yBAAQ,OAAO,CAAC,GAAG;AACrB,gBAAM,OAAO;AACb,gBAAM,iBAAiB,wBAAwB,IAAI;AAEnD,cAAI;AACF,mBACE,eAAe,SAAS,YACxB,eAAe,OAAO,YAAY;AAGtC,iBAAO;AAAA,QACT;AACA,YACE,4BAAW,UAAU,CAAC,KACtB,OAAO,OAAO,oBAAoB,EAAE,WAAW,kBAAkB,CAAC,GAClE;AACA,gBAAM,oBAAoB;AAC1B,gBAAM,cAAc,kBAAkB,WAAW;AAEjD,cAAI;AACF,mBAAO,kBAAkB,WAAW,OAAO,YAAY;AAEzD,iBACE,kBAAkB,WAAW,SAAS,YACtC,kBAAkB,WAAW,OAAO,YAAY;AAAA,QAEpD;AAEA,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAED,WAAO,GAAG,YAAY;AAAA,MACpB,IAAI,CAAC;AAAA,MACL,MAAM;AAAA,MACN,OAAO,CAAC,MAAM;AACZ,YAAI,yBAAQ,OAAO,CAAC,GAAG;AACrB,gBAAM,OAAO;AAEb,gBAAM,iBAAiB,wBAAwB,IAAI;AAEnD,cAAI;AACF,mBACE,eAAe,SAAS,YACxB,eAAe,OAAO,YAAY;AAGtC,iBAAO;AAAA,QACT;AAEA,YACE,4BAAW,UAAU,CAAC,KACtB,OAAO,OAAO,oBAAoB,EAAE,WAAW,kBAAkB,CAAC,GAClE;AACA,gBAAM,oBAAoB;AAC1B,iBACE,kBAAkB,WAAW,SAAS,YACtC,kBAAkB,WAAW,OAAO,YAAY,gBAChD,CAAC,kBAAkB,WAAW;AAAA,QAElC;AAEA,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAED,UAAM,cAAc;AAAA,MAClB,GAAG,OAAO,IAAI,MAAa;AAAA,QACzB,IAAI,CAAC;AAAA,QACL,OAAO,CAAC,MAAM;AACZ,cAAI,4BAAW,UAAU,CAAC,EAAG,QAAO;AACpC,cAAI,yBAAQ,OAAO,CAAC,GAAG;AACrB,kBAAM,WAAW,OACd,OAAO,oBAAoB,EAC3B,WAAW,SAAS,CAAoB;AAE3C,gBAAI,SAAS,SAAS;AACpB,qBAAO,SAAS;AAAA,gBACd,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,OAAO,YAAY;AAAA,cACtD;AAEF,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAEA,gBAAY,QAAQ,CAAC,CAAC,MAAM,IAAI,MAAM;AACpC,YAAM,WAAW,OACd,OAAO,oBAAoB,EAC3B,WAAW,SAAS,IAAuB;AAC9C,YAAM,aAAa,SAAS;AAAA,QAC1B,CAAC,SAAS,KAAK,SAAS,YAAY,KAAK,OAAO,YAAY;AAAA,MAC9D;AAEA,UAAI,CAAC,WAAY;AACjB,UAAI,mBAAmB,YAAY;AACjC,cAAM,aAAa,OAAO,KAAK,WAAW,aAAa,EAAE;AAAA,UACvD,CAAC,QAAQ,WAAW,cAAc,GAAG;AAAA,QACvC;AAEA,eAAO,GAAG,WAAW,CAAC,GAAG,UAAU,GAAG;AAAA,UACpC,IAAI;AAAA,QACN,CAAC;AAAA,MACH;AACA,UAAI,gBAAgB,YAAY;AAC9B,cAAM,WAAW,OAAO,KAAK,WAAW,UAAU,EAAE;AAAA,UAClD,CAAC,QAAQ,CAAC,WAAW,WAAW,GAAG;AAAA,QACrC;AAEA,eAAO,GAAG;AAAA,UACR,OAAO,YAAY,SAAS,IAAI,CAAC,QAAQ,CAAC,KAAK,IAAI,CAAC,CAAC;AAAA,UACrD;AAAA,YACE,IAAI;AAAA,UACN;AAAA,QACF;AAAA,MACF;AAGA,aAAO,GAAG,WAAW,CAAC,iBAAiB,WAAW,EAAE,CAAC,GAAG;AAAA,QACtD,IAAI;AAAA,MACN,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH;;;AHjKO,SAAS,kBACd,QACA,MACA,MACA;AAAA,EACE,iBAAiB,MACf,mBAAmB,YAAQ,yBAAO,GAAG;AAAA,IACnC,oBAAoB;AAAA,EACtB,CAAC;AAAA,EACH,iBAAiB,MAAM,mBAAmB,YAAQ,yBAAO,CAAC;AAAA,EAC1D,iBAAiB,CAAC,OAAO,aAAa,kBACpC,mBAAmB,YAAQ,yBAAO,GAAG;AAAA,IACnC,kBAAkB;AAAA,EACpB,CAAC;AAAA,EACH,WAAW,OAAO,IAAI;AAAA,EACtB,GAAG;AACL,IAAiC,CAAC,GACtB;AACZ,QAAM,aAAS,yBAAY,MAAM,MAAM;AAAA,IACrC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EACL,CAAC;AAGD,QAAM,gBAAgB,CAAC,UAAsC;AAC3D,WAAO,MAAM,IAAI,CAAC,MAAM,UAAU;AAChC,UAAI,4BAAW,UAAU,IAAI,KAAK,cAAc,MAAM;AAEpD,eAAO;AAAA,UACL,GAAG;AAAA,UACH,UAAU,cAAc,KAAK,QAAQ;AAAA,QACvC;AAAA,MACF;AAEA,UAAI,yBAAQ,OAAO,IAAI,KAAK,KAAK,sBAAK,UAAU,GAAG;AACjD,cAAM,MAAM,OAAO,OAAO,oBAAoB;AAC9C,cAAM,kBAAkB,IAAI,WAAW,eAAe,IAAW;AAEjE,YAAI,iBAAiB,SAAS,UAAU;AAEtC,gBAAM,eAAe,QAAQ,IAAI,MAAM,QAAQ,CAAC,IAAI;AAEpD,cAAI,eAAe,sBAAK,UAAU,GAAG;AACnC,kBAAM,eAAe,IAAI,WAAW;AAAA,cAClC;AAAA,YACF;AAEA,gBAAI,cAAc,SAAS,UAAU;AAEnC,oBAAM,cAAc;AAAA,gBAClB,GAAG;AAAA,gBACH,CAAC,iBAAiB,aAAa,EAAE,CAAC,GAAG;AAAA,kBACnC,GAAG;AAAA,kBACH,IAAI,aAAa;AAAA,kBACjB,WAAW,aAAa;AAAA,gBAC1B;AAAA,cACF;AAIA,oBAAM,MAAM,iBAAiB,gBAAgB,EAAE;AAC/C,qBAAO,YAAY,GAAG;AAEtB,qBAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,SAAO,cAAc,MAAM;AAC7B;","names":["import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs"]}