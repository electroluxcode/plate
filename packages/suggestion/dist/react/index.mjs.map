{"version":3,"sources":["../../src/react/SuggestionPlugin.tsx","../../src/lib/BaseSuggestionPlugin.ts","../../src/lib/utils/getSuggestionKeys.ts","../../src/lib/utils/getSuggestionId.ts","../../src/lib/withSuggestion.ts","../../src/lib/queries/findSuggestionProps.ts","../../src/lib/transforms/addMarkSuggestion.ts","../../src/lib/transforms/deleteSuggestion.ts","../../src/lib/transforms/setSuggestionNodes.ts","../../src/lib/transforms/deleteFragmentSuggestion.ts","../../src/lib/transforms/insertFragmentSuggestion.ts","../../src/lib/transforms/insertTextSuggestion.ts","../../src/lib/transforms/removeMarkSuggestion.ts","../../src/lib/transforms/removeNodesSuggestion.ts"],"sourcesContent":["import { toPlatePlugin } from 'platejs/react';\n\nimport { BaseSuggestionPlugin } from '../lib/BaseSuggestionPlugin';\n\n/** @experimental Enables support for suggestions in the editor. */\nexport const SuggestionPlugin = toPlatePlugin(BaseSuggestionPlugin);\n","import {\n  type EditorNodesOptions,\n  type NodeEntry,\n  type PluginConfig,\n  type TElement,\n  type TInlineSuggestionData,\n  type TSuggestionElement,\n  type TSuggestionText,\n  createTSlatePlugin,\n  ElementApi,\n  getAt,\n  KEYS,\n  TextApi,\n} from 'platejs';\n\nimport { getSuggestionKey, getSuggestionKeyId } from './utils';\nimport { withSuggestion } from './withSuggestion';\n\nexport type BaseSuggestionConfig = PluginConfig<\n  'suggestion',\n  {\n    currentUserId: string | null;\n    isSuggesting: boolean;\n    // onAdd?: (value: WithPartial<TSuggestion, 'id' | 'userId'>) => void;\n    // onRemove?: (id: string) => void;\n    // onUpdate?: (id: string, value: Partial<TSuggestion>) => void;\n  },\n  {\n    suggestion: {\n      dataList: (node: TSuggestionText) => TInlineSuggestionData[];\n      isBlockSuggestion: (node: TElement) => node is TSuggestionElement;\n      node: (\n        options?: EditorNodesOptions & { id?: string; isText?: boolean }\n      ) => NodeEntry<TSuggestionElement | TSuggestionText> | undefined;\n      nodeId: (node: TElement | TSuggestionText) => string | undefined;\n      nodes: (\n        options?: EditorNodesOptions\n      ) => NodeEntry<TElement | TSuggestionText>[];\n      suggestionData: (\n        node: TElement | TSuggestionText\n      ) => TInlineSuggestionData | TSuggestionElement['suggestion'] | undefined;\n      withoutSuggestions: (fn: () => void) => void;\n    };\n  }\n>;\n\nexport const BaseSuggestionPlugin = createTSlatePlugin<BaseSuggestionConfig>({\n  key: KEYS.suggestion,\n  node: { isLeaf: true },\n  options: {\n    currentUserId: 'alice',\n    isSuggesting: false,\n  },\n  rules: { selection: { affinity: 'outward' } },\n})\n  .overrideEditor(withSuggestion)\n  .extendApi<BaseSuggestionConfig['api']['suggestion']>(\n    ({ api, editor, getOption, setOption, type }) => ({\n      dataList: (node: TSuggestionText): TInlineSuggestionData[] => {\n        return Object.keys(node)\n          .filter((key) => {\n            return key.startsWith(`${KEYS.suggestion}_`);\n          })\n          .map((key) => node[key] as TInlineSuggestionData);\n      },\n      isBlockSuggestion: (node): node is TSuggestionElement =>\n        ElementApi.isElement(node) && 'suggestion' in node,\n      node: (options = {}) => {\n        const { id, isText, ...rest } = options;\n        const result = editor.api.node<TSuggestionElement | TSuggestionText>({\n          match: (n) => {\n            if (!n[type]) return false;\n            if (isText && !TextApi.isText(n)) return false;\n            if (id) {\n              if (TextApi.isText(n)) {\n                return !!n[getSuggestionKey(id)];\n              }\n              if (\n                ElementApi.isElement(n) &&\n                api.suggestion.isBlockSuggestion(n)\n              ) {\n                return n.suggestion.id === id;\n              }\n            }\n\n            return true;\n          },\n          ...rest,\n        });\n\n        return result;\n      },\n      nodeId: (node) => {\n        if (TextApi.isText(node)) {\n          const keyId = getSuggestionKeyId(node);\n\n          if (!keyId) return;\n\n          return keyId.replace(`${type}_`, '');\n        }\n\n        if (api.suggestion.isBlockSuggestion(node)) {\n          return node.suggestion.id;\n        }\n      },\n      nodes: (options = {}) => {\n        const at = getAt(editor, options.at) ?? [];\n\n        return [\n          ...editor.api.nodes<TElement | TSuggestionText>({\n            ...options,\n            at,\n            mode: 'all',\n            match: (n) => n[type],\n          }),\n        ];\n      },\n      suggestionData: (node) => {\n        if (TextApi.isText(node)) {\n          const keyId = getSuggestionKeyId(node);\n\n          if (!keyId) return;\n\n          return node[keyId] as TInlineSuggestionData | undefined;\n        }\n\n        if (api.suggestion.isBlockSuggestion(node)) {\n          return node.suggestion;\n        }\n      },\n      withoutSuggestions: (fn) => {\n        const prev = getOption('isSuggesting');\n        setOption('isSuggesting', false);\n        fn();\n        setOption('isSuggesting', prev);\n      },\n    })\n  );\n","import {\n  type SlateEditor,\n  type TNode,\n  type TText,\n  isDefined,\n  KEYS,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getInlineSuggestionData } from './getSuggestionId';\n\nexport const getSuggestionKey = (id = '0'): string =>\n  `${KEYS.suggestion}_${id}`;\n\nexport const isSuggestionKey = (key: string) =>\n  key.startsWith(`${KEYS.suggestion}_`);\n\nexport const getSuggestionKeys = (node: TNode) => {\n  const keys: string[] = [];\n\n  Object.keys(node).forEach((key) => {\n    if (isSuggestionKey(key)) keys.push(key);\n  });\n\n  return keys;\n};\n\nexport const getSuggestionUserIdByKey = (key?: string | null) =>\n  isDefined(key) ? key.split(`${KEYS.suggestion}_`)[1] : null;\n\nexport const getSuggestionUserIds = (node: TNode) => {\n  return getSuggestionKeys(node).map(\n    (key) => getSuggestionUserIdByKey(key) as string\n  );\n};\n\nexport const getSuggestionUserId = (node: TNode) => {\n  return getSuggestionUserIds(node)[0];\n};\n\nexport const isCurrentUserSuggestion = (editor: SlateEditor, node: TText) => {\n  const { currentUserId } = editor.getOptions(BaseSuggestionPlugin);\n\n  return getInlineSuggestionData(node)?.userId === currentUserId;\n};\n","import type { TInlineSuggestionData, TText } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\n// the last id is the active id\nexport const getSuggestionKeyId = (node: TText) => {\n  const ids: string[] = Object.keys(node).filter((key) => {\n    return key.startsWith(`${KEYS.suggestion}_`);\n  });\n\n  return ids.at(-1);\n};\n\nexport const getInlineSuggestionData = (node: TText) => {\n  const keyId = getSuggestionKeyId(node);\n\n  if (!keyId) return;\n\n  return node[keyId] as TInlineSuggestionData | undefined;\n};\n\nexport const keyId2SuggestionId = (keyId: string) => {\n  return keyId.replace(`${KEYS.suggestion}_`, '');\n};\n","import {\n  type OverrideEditor,\n  type TSuggestionElement,\n  KEYS,\n  nanoid,\n  TextApi,\n} from 'platejs';\n\nimport {\n  type BaseSuggestionConfig,\n  BaseSuggestionPlugin,\n} from './BaseSuggestionPlugin';\nimport { findSuggestionProps } from './queries';\nimport { addMarkSuggestion } from './transforms/addMarkSuggestion';\nimport { deleteFragmentSuggestion } from './transforms/deleteFragmentSuggestion';\nimport { deleteSuggestion } from './transforms/deleteSuggestion';\nimport { insertFragmentSuggestion } from './transforms/insertFragmentSuggestion';\nimport { insertTextSuggestion } from './transforms/insertTextSuggestion';\nimport { removeMarkSuggestion } from './transforms/removeMarkSuggestion';\nimport { removeNodesSuggestion } from './transforms/removeNodesSuggestion';\nimport { getInlineSuggestionData, getSuggestionKeyId } from './utils/index';\n\nexport const withSuggestion: OverrideEditor<BaseSuggestionConfig> = ({\n  api,\n  editor,\n  getOptions,\n  tf: {\n    addMark,\n    apply,\n    deleteBackward,\n    deleteForward,\n    deleteFragment,\n    insertBreak,\n    insertFragment,\n    insertNodes,\n    insertText,\n    normalizeNode,\n    removeMark,\n    removeNodes,\n  },\n}) => ({\n  transforms: {\n    addMark(key, value) {\n      if (getOptions().isSuggesting && api.isExpanded()) {\n        return addMarkSuggestion(editor, key, value);\n      }\n\n      return addMark(key, value);\n    },\n    apply(operation) {\n      return apply(operation);\n    },\n    deleteBackward(unit) {\n      const selection = editor.selection!;\n      const pointTarget = editor.api.before(selection, { unit });\n\n      if (getOptions().isSuggesting) {\n        const node = editor.api.above<TSuggestionElement>();\n        // without set suggestion when delete backward in block suggestion\n        if (node?.[0][KEYS.suggestion] && !node?.[0].suggestion.isLineBreak) {\n          return deleteBackward(unit);\n        }\n\n        if (!pointTarget) return;\n\n        deleteSuggestion(\n          editor,\n          { anchor: selection.anchor, focus: pointTarget },\n          { reverse: true }\n        );\n\n        return;\n      } else {\n        // remove line break when across blocks\n        if (pointTarget) {\n          const isCrossBlock = editor.api.isAt({\n            at: { anchor: selection.anchor, focus: pointTarget },\n            blocks: true,\n          });\n\n          if (isCrossBlock) {\n            editor.tf.unsetNodes([KEYS.suggestion], {\n              at: pointTarget,\n            });\n          }\n        }\n      }\n\n      deleteBackward(unit);\n    },\n    deleteForward(unit) {\n      if (getOptions().isSuggesting) {\n        const selection = editor.selection!;\n        const pointTarget = editor.api.after(selection, { unit });\n\n        if (!pointTarget) return;\n\n        deleteSuggestion(editor, {\n          anchor: selection.anchor,\n          focus: pointTarget,\n        });\n\n        return;\n      }\n\n      deleteForward(unit);\n    },\n\n    deleteFragment(direction) {\n      if (getOptions().isSuggesting) {\n        deleteFragmentSuggestion(editor, { reverse: true });\n\n        return;\n      }\n\n      deleteFragment(direction);\n    },\n\n    insertBreak() {\n      if (getOptions().isSuggesting) {\n        const [node, path] = editor.api.above()!;\n\n        if (path.length > 1 || node.type !== editor.getType(KEYS.p)) {\n          return insertTextSuggestion(editor, '\\n');\n        }\n\n        const { id, createdAt } = findSuggestionProps(editor, {\n          at: editor.selection!,\n          type: 'insert',\n        });\n\n        insertBreak();\n\n        editor.tf.withoutMerging(() => {\n          editor.tf.setNodes(\n            {\n              [KEYS.suggestion]: {\n                id,\n                createdAt,\n                isLineBreak: true,\n                type: 'insert',\n                userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n              },\n            },\n            { at: path }\n          );\n        });\n\n        return;\n      }\n\n      insertBreak();\n    },\n\n    insertFragment(fragment) {\n      if (getOptions().isSuggesting) {\n        insertFragmentSuggestion(editor, fragment, { insertFragment });\n\n        return;\n      }\n\n      insertFragment(fragment);\n    },\n\n    insertNodes(nodes, options) {\n      if (getOptions().isSuggesting) {\n        const nodesArray = Array.isArray(nodes) ? nodes : [nodes];\n\n        // TODO: options\n        if (nodesArray.some((n) => n.type === 'slash_input')) {\n          api.suggestion.withoutSuggestions(() => {\n            insertNodes(nodes, options);\n          });\n\n          return;\n        }\n\n        const suggestionNodes = nodesArray.map((node) => {\n          return {\n            ...node,\n            [KEYS.suggestion]: {\n              id: nanoid(),\n              createdAt: Date.now(),\n              type: 'insert',\n              userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n            },\n          };\n        });\n\n        return insertNodes(suggestionNodes, options);\n      }\n\n      return insertNodes(nodes, options);\n    },\n\n    insertText(text, options) {\n      if (getOptions().isSuggesting) {\n        const node = editor.api.above<TSuggestionElement>();\n\n        if (node?.[0][KEYS.suggestion] && !node?.[0].suggestion.isLineBreak) {\n          return insertText(text, options);\n        }\n\n        insertTextSuggestion(editor, text);\n\n        return;\n      }\n\n      insertText(text, options);\n    },\n\n    normalizeNode(entry) {\n      api.suggestion.withoutSuggestions(() => {\n        const [node, path] = entry;\n\n        if (\n          node[KEYS.suggestion] && // Unset suggestion when there is no suggestion id\n          TextApi.isText(node) &&\n          !getSuggestionKeyId(node)\n        ) {\n          editor.tf.unsetNodes([KEYS.suggestion, 'suggestionData'], {\n            at: path,\n          });\n\n          return;\n        }\n        // Unset suggestion when there is no suggestion user id\n        if (\n          node[KEYS.suggestion] &&\n          TextApi.isText(node) &&\n          !getInlineSuggestionData(node)?.userId\n        ) {\n          if (getInlineSuggestionData(node)?.type === 'remove') {\n            // Unset deletions\n            editor.tf.unsetNodes([KEYS.suggestion, getSuggestionKeyId(node)!], {\n              at: path,\n            });\n          } else {\n            // Remove additions\n            editor.tf.removeNodes({ at: path });\n          }\n\n          return;\n        }\n\n        normalizeNode(entry);\n      });\n    },\n    removeMark(key) {\n      if (getOptions().isSuggesting && api.isExpanded()) {\n        return removeMarkSuggestion(editor, key);\n      }\n\n      return removeMark(key);\n    },\n    // Remove nodes by block selection\n    removeNodes(options) {\n      if (getOptions().isSuggesting) {\n        const nodes = [...editor.api.nodes(options)];\n\n        if (nodes.some(([n]) => n.type === 'slash_input')) {\n          api.suggestion.withoutSuggestions(() => {\n            removeNodes(options);\n          });\n\n          return;\n        }\n\n        return removeNodesSuggestion(editor, nodes);\n      }\n\n      return removeNodes(options);\n    },\n  },\n});\n","import {\n  type NodeEntry,\n  type Point,\n  type SlateEditor,\n  type TLocation,\n  type TSuggestionElement,\n  type TSuggestionText,\n  nanoid,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getInlineSuggestionData, isCurrentUserSuggestion } from '../utils';\n\nexport const findSuggestionProps = (\n  editor: SlateEditor,\n  { at, type }: { at: TLocation; type: 'insert' | 'remove' | 'update' }\n): { id: string; createdAt: number } => {\n  const defaultProps = {\n    id: nanoid(),\n    createdAt: Date.now(),\n  };\n\n  const api = editor.getApi(BaseSuggestionPlugin);\n\n  let entry = api.suggestion.node({\n    at,\n    isText: true,\n  }) as NodeEntry<TSuggestionText> | undefined;\n\n  if (!entry) {\n    let start: Point;\n    let end: Point;\n\n    try {\n      [start, end] = editor.api.edges(at)!;\n    } catch {\n      return defaultProps;\n    }\n\n    const nextPoint = editor.api.after(end);\n\n    if (nextPoint) {\n      entry = api.suggestion.node({\n        at: nextPoint,\n        isText: true,\n      }) as NodeEntry<TSuggestionText> | undefined;\n\n      if (!entry) {\n        const prevPoint = editor.api.before(start);\n\n        if (prevPoint) {\n          entry = api.suggestion.node({\n            at: prevPoint,\n            isText: true,\n          }) as NodeEntry<TSuggestionText> | undefined;\n        }\n        // <p>111111<insert_break></p>\n        // <p><cursor /></p>\n        // in this case we need to find the previous parent node\n        // TODO: test\n        if (!entry && editor.api.isStart(start, at)) {\n          const _at = prevPoint ?? at;\n\n          const lineBreak = editor.api.above<TSuggestionElement>({ at: _at });\n\n          const lineBreakData = lineBreak?.[0].suggestion;\n\n          if (lineBreakData?.isLineBreak) {\n            return {\n              id: lineBreakData?.id ?? nanoid(),\n              createdAt: lineBreakData?.createdAt ?? Date.now(),\n            };\n          }\n        }\n      }\n    }\n  }\n  // same type and same user merge suggestions\n  if (\n    entry &&\n    getInlineSuggestionData(entry[0])?.type === type &&\n    isCurrentUserSuggestion(editor, entry[0])\n  ) {\n    return {\n      id: api.suggestion.nodeId(entry[0]) ?? nanoid(),\n      createdAt: getInlineSuggestionData(entry[0])?.createdAt ?? Date.now(),\n    };\n  }\n\n  return defaultProps;\n};\n","import { type SlateEditor, type TNode, KEYS, nanoid, TextApi } from 'platejs';\n\nimport { getInlineSuggestionData, getSuggestionKey } from '../..';\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\n\nconst getAddMarkProps = () => {\n  const defaultProps = {\n    id: nanoid(),\n    createdAt: Date.now(),\n  };\n\n  return defaultProps;\n};\n\nexport const addMarkSuggestion = (\n  editor: SlateEditor,\n  key: string,\n  value: any\n) => {\n  editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n    const { id, createdAt } = getAddMarkProps();\n\n    const match = (n: TNode) => {\n      if (!TextApi.isText(n)) return false;\n      // if the node is already marked as a suggestion, we don't want to remove it unless it's a removeMark suggestion\n      if (n[KEYS.suggestion]) {\n        const data = getInlineSuggestionData(n);\n\n        if (data?.type === 'update') {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n\n    editor.tf.setNodes(\n      {\n        [key]: value,\n        [getSuggestionKey(id)]: {\n          id: id,\n          createdAt: createdAt,\n          newProperties: {\n            [key]: value,\n          },\n          type: 'update',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId,\n        },\n        [KEYS.suggestion]: true,\n      },\n      {\n        match,\n        split: true,\n      }\n    );\n  });\n};\n","import {\n  type Point,\n  type SlateEditor,\n  type TElement,\n  type TRange,\n  type TSuggestionElement,\n  ElementApi,\n  KEYS,\n  PathApi,\n  PointApi,\n  TextApi,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { findSuggestionProps } from '../queries/';\nimport { getInlineSuggestionData, isCurrentUserSuggestion } from '../utils';\nimport { setSuggestionNodes } from './setSuggestionNodes';\n\n/**\n * Suggest deletion one character at a time until target point is reached.\n * Suggest additions are safely deleted.\n */\nexport const deleteSuggestion = (\n  editor: SlateEditor,\n  at: TRange,\n  {\n    reverse,\n  }: {\n    reverse?: boolean;\n  } = {}\n) => {\n  let resId: string | undefined;\n\n  editor.tf.withoutNormalizing(() => {\n    const { anchor: from, focus: to } = at;\n\n    const { id, createdAt: createdAt } = findSuggestionProps(editor, {\n      at: from,\n      type: 'remove',\n    });\n\n    resId = id;\n\n    const toRef = editor.api.pointRef(to);\n\n    let pointCurrent: Point | undefined;\n\n    while (true) {\n      pointCurrent = editor.selection?.anchor;\n\n      if (!pointCurrent) break;\n\n      const pointTarget = toRef.current;\n\n      if (!pointTarget) break;\n      // don't delete across blocks\n      if (\n        !editor.api.isAt({\n          at: { anchor: pointCurrent, focus: pointTarget },\n          blocks: true,\n        })\n      ) {\n        // always 0 when across blocks\n        const str = editor.api.string(\n          reverse\n            ? {\n                anchor: pointTarget,\n                focus: pointCurrent,\n              }\n            : {\n                anchor: pointCurrent,\n                focus: pointTarget,\n              }\n        );\n\n        if (str.length === 0) break;\n      }\n\n      const getPoint = reverse ? editor.api.before : editor.api.after;\n\n      const pointNext: Point | undefined = getPoint(pointCurrent, {\n        unit: 'character',\n      });\n\n      if (!pointNext) break;\n\n      let range: TRange = reverse\n        ? {\n            anchor: pointNext,\n            focus: pointCurrent,\n          }\n        : {\n            anchor: pointCurrent,\n            focus: pointNext,\n          };\n      range = editor.api.unhangRange(range, { character: true });\n\n      // if the current point is in block addition suggestion, delete block\n      const entryBlock = editor.api.node<TElement>({\n        at: pointCurrent,\n        block: true,\n        match: (n) =>\n          n[KEYS.suggestion] &&\n          TextApi.isText(n) &&\n          getInlineSuggestionData(n)?.type === 'insert' &&\n          isCurrentUserSuggestion(editor, n),\n      });\n\n      if (\n        entryBlock &&\n        editor.api.isStart(pointCurrent, entryBlock[1]) &&\n        editor.api.isEmpty(entryBlock[0] as any)\n      ) {\n        editor.tf.removeNodes({\n          at: entryBlock[1],\n        });\n\n        continue;\n      }\n      // if the range is across blocks, delete the line break\n      if (editor.api.isAt({ at: range, blocks: true })) {\n        const previousAboveNode = editor.api.above({ at: range.anchor });\n\n        if (previousAboveNode && ElementApi.isElement(previousAboveNode[0])) {\n          const isBlockSuggestion = editor\n            .getApi(BaseSuggestionPlugin)\n            .suggestion.isBlockSuggestion(previousAboveNode[0]);\n\n          if (isBlockSuggestion) {\n            const node = previousAboveNode[0] as TSuggestionElement;\n\n            if (node.suggestion.type === 'insert') {\n              editor\n                .getApi(BaseSuggestionPlugin)\n                .suggestion.withoutSuggestions(() => {\n                  editor.tf.unsetNodes([KEYS.suggestion], {\n                    at: previousAboveNode[1],\n                  });\n                  editor.tf.mergeNodes({\n                    at: PathApi.next(previousAboveNode[1]),\n                  });\n                });\n            }\n            if (node.suggestion.type === 'remove') {\n              editor.tf.move({\n                reverse,\n                unit: 'character',\n              });\n            }\n            break;\n          }\n\n          if (!isBlockSuggestion) {\n            editor.tf.setNodes(\n              {\n                [KEYS.suggestion]: {\n                  id,\n                  createdAt,\n                  type: 'remove',\n                  userId:\n                    editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n                },\n              },\n              { at: previousAboveNode[1] }\n            );\n            editor.tf.move({\n              reverse,\n              unit: 'character',\n            });\n            break;\n          }\n        }\n\n        break;\n      }\n      // move selection if still the same\n      if (PointApi.equals(pointCurrent, editor.selection!.anchor)) {\n        editor.tf.move({\n          reverse,\n          unit: 'character',\n        });\n      }\n\n      // if the current point is in addition suggestion, delete\n      const entryText = editor.getApi(BaseSuggestionPlugin).suggestion.node({\n        at: range,\n        isText: true,\n        match: (n) =>\n          TextApi.isText(n) &&\n          getInlineSuggestionData(n)?.type === 'insert' &&\n          isCurrentUserSuggestion(editor, n),\n      });\n\n      if (entryText) {\n        editor.tf.delete({ at: range, unit: 'character' });\n\n        continue;\n      }\n\n      setSuggestionNodes(editor, {\n        at: range,\n        createdAt: createdAt as number,\n        suggestionDeletion: true,\n        suggestionId: id,\n      });\n    }\n  });\n\n  return resId;\n};\n","import {\n  type SetNodesOptions,\n  type SlateEditor,\n  type TInlineSuggestionData,\n  type TSuggestionText,\n  ElementApi,\n  getAt,\n  KEYS,\n  nanoid,\n} from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { getSuggestionKey } from '../utils';\n\nexport const setSuggestionNodes = (\n  editor: SlateEditor,\n  options?: {\n    createdAt?: number;\n    suggestionDeletion?: boolean;\n    suggestionId?: string;\n  } & SetNodesOptions\n) => {\n  const at = getAt(editor, options?.at) ?? editor.selection;\n\n  if (!at) return;\n\n  const { suggestionId = nanoid() } = options ?? {};\n\n  // TODO: get all inline nodes to be set\n  const _nodeEntries = editor.api.nodes({\n    match: (n) => ElementApi.isElement(n) && editor.api.isInline(n),\n    ...options,\n  });\n  const nodeEntries = [..._nodeEntries];\n\n  editor.tf.withoutNormalizing(() => {\n    const data: TInlineSuggestionData = {\n      id: suggestionId,\n      createdAt: options?.createdAt ?? Date.now(),\n      type: 'remove',\n      userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n    };\n\n    const props = {\n      [getSuggestionKey(suggestionId)]: data,\n      [KEYS.suggestion]: true,\n    };\n\n    editor.tf.setNodes(props, {\n      at,\n      marks: true,\n    });\n\n    nodeEntries.forEach(([, path]) => {\n      editor.tf.setNodes<TSuggestionText>(props, {\n        at: path,\n        match: (n) => ElementApi.isElement(n) && editor.api.isInline(n),\n        ...options,\n      });\n    });\n  });\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { deleteSuggestion } from './deleteSuggestion';\n\nexport const deleteFragmentSuggestion = (\n  editor: SlateEditor,\n  { reverse }: { reverse?: boolean } = {}\n) => {\n  let resId: string | undefined;\n\n  editor.tf.withoutNormalizing(() => {\n    const selection = editor.selection!;\n\n    const [start, end] = editor.api.edges(selection)!;\n\n    if (reverse) {\n      editor.tf.collapse({ edge: 'end' });\n      resId = deleteSuggestion(\n        editor,\n        { anchor: end, focus: start },\n        { reverse: true }\n      );\n    } else {\n      editor.tf.collapse({ edge: 'start' });\n      resId = deleteSuggestion(editor, { anchor: start, focus: end });\n    }\n  });\n\n  return resId;\n};\n","import { type Descendant, type SlateEditor, KEYS, TextApi } from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { findSuggestionProps } from '../queries';\nimport { getSuggestionKey, getSuggestionKeys } from '../utils/index';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\n\nexport const insertFragmentSuggestion = (\n  editor: SlateEditor,\n  fragment: Descendant[],\n  {\n    insertFragment = editor.tf.insertFragment,\n  }: {\n    insertFragment?: (fragment: Descendant[]) => void;\n  } = {}\n) => {\n  editor.tf.withoutNormalizing(() => {\n    deleteFragmentSuggestion(editor);\n\n    const { id, createdAt: createdAt } = findSuggestionProps(editor, {\n      at: editor.selection!,\n      type: 'insert',\n    });\n\n    fragment.forEach((n) => {\n      if (TextApi.isText(n)) {\n        if (!n[KEYS.suggestion]) {\n          // Add suggestion mark\n          n[KEYS.suggestion] = true;\n        }\n\n        // remove the other suggestion data\n        const otherUserKeys = getSuggestionKeys(n);\n        otherUserKeys.forEach((key) => {\n          delete n[key];\n        });\n\n        n[getSuggestionKey(id)] = {\n          id,\n          createdAt,\n          type: 'insert',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n        };\n      } else {\n        n[KEYS.suggestion] = {\n          id,\n          createdAt,\n          type: 'insert',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n        };\n      }\n    });\n\n    editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n      insertFragment(fragment);\n    });\n  });\n};\n","import type { SlateEditor, TSuggestionText } from 'platejs';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { findSuggestionProps } from '../queries';\nimport { getSuggestionKey } from '../utils';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\n\nexport const insertTextSuggestion = (editor: SlateEditor, text: string) => {\n  editor.tf.withoutNormalizing(() => {\n    let resId: string | undefined;\n    const { id, createdAt: createdAt } = findSuggestionProps(editor, {\n      at: editor.selection!,\n      type: 'insert',\n    });\n\n    if (editor.api.isExpanded()) {\n      resId = deleteFragmentSuggestion(editor);\n    }\n\n    editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n      editor.tf.insertNodes<TSuggestionText>(\n        {\n          [getSuggestionKey(resId ?? id)]: {\n            id: resId ?? id,\n            createdAt: createdAt,\n            type: 'insert',\n            userId: editor.getOptions(BaseSuggestionPlugin).currentUserId!,\n          },\n          suggestion: true,\n          text,\n        },\n        {\n          at: editor.selection!,\n          select: true,\n        }\n      );\n    });\n  });\n};\n","import { type SlateEditor, type TNode, KEYS, nanoid, TextApi } from 'platejs';\n\nimport { getInlineSuggestionData, getSuggestionKey } from '../..';\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\n\nconst getRemoveMarkProps = () => {\n  const defaultProps = {\n    id: nanoid(),\n    createdAt: Date.now(),\n  };\n\n  return defaultProps;\n};\n\n// TODO remove mark when the text is already marked as a bold by suggestion\nexport const removeMarkSuggestion = (editor: SlateEditor, key: string) => {\n  editor.getApi(BaseSuggestionPlugin).suggestion.withoutSuggestions(() => {\n    const { id, createdAt } = getRemoveMarkProps();\n\n    const match = (n: TNode) => {\n      if (!TextApi.isText(n)) return false;\n      // if the node is already marked as a suggestion, we don't want to remove it unless it's a removeMark suggestion\n      if (n[KEYS.suggestion]) {\n        const data = getInlineSuggestionData(n);\n\n        if (data?.type === 'update') {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n\n    editor.tf.unsetNodes(key, {\n      match,\n    });\n\n    editor.tf.setNodes(\n      {\n        [getSuggestionKey(id)]: {\n          id: id,\n          createdAt: createdAt,\n          properties: {\n            [key]: undefined,\n          },\n          type: 'update',\n          userId: editor.getOptions(BaseSuggestionPlugin).currentUserId,\n        },\n        [KEYS.suggestion]: true,\n      },\n      {\n        match,\n      }\n    );\n  });\n};\n","import type { NodeEntry, SlateEditor, TElement, Text } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { findSuggestionProps } from '../queries';\n\nexport const removeNodesSuggestion = (\n  editor: SlateEditor,\n  nodes: NodeEntry<TElement | Text>[]\n) => {\n  if (nodes.length === 0) return;\n\n  const { id, createdAt } = findSuggestionProps(editor, {\n    at: editor.selection!,\n    type: 'remove',\n  });\n\n  nodes.forEach(([, blockPath]) => {\n    editor.tf.setNodes(\n      {\n        [KEYS.suggestion]: {\n          id,\n          createdAt,\n          type: 'remove',\n        },\n      },\n      { at: blockPath }\n    );\n  });\n};\n"],"mappings":"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","names":["ElementApi","getAt","KEYS","TextApi","KEYS","KEYS","KEYS","nanoid","TextApi","KEYS","nanoid","TextApi","ElementApi","KEYS","KEYS","nanoid","nanoid","KEYS","KEYS","ElementApi","KEYS","TextApi","TextApi","KEYS","KEYS","nanoid","TextApi","nanoid","TextApi","KEYS","KEYS","KEYS","nanoid","TextApi","KEYS","KEYS","nanoid","TextApi","KEYS","ElementApi","TextApi","getAt"]}