{"version":3,"sources":["../../src/react/EquationPlugin.tsx","../../src/lib/BaseEquationPlugin.ts","../../src/lib/transforms/insertEquation.ts","../../src/lib/transforms/insertInlineEquation.ts","../../src/lib/BaseInlineEquationPlugin.ts","../../src/react/InlineEquationPlugin.tsx","../../src/react/hooks/useEquationElement.ts","../../src/react/hooks/useEquationInput.ts"],"sourcesContent":["import { toPlatePlugin } from 'platejs/react';\n\nimport { BaseEquationPlugin } from '../lib';\n\nexport const EquationPlugin = toPlatePlugin(BaseEquationPlugin);\n","import { bindFirst, createSlatePlugin, KEYS } from 'platejs';\n\nimport { insertEquation } from './transforms';\n\nimport 'katex/dist/katex.min.css';\n\nexport const BaseEquationPlugin = createSlatePlugin({\n  key: KEYS.equation,\n  node: { isElement: true, isVoid: true },\n}).extendEditorTransforms(({ editor }) => ({\n  insert: {\n    equation: bindFirst(insertEquation, editor),\n  },\n}));\n","import type {\n  InsertNodesOptions,\n  SlateEditor,\n  TEquationElement,\n} from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const insertEquation = (\n  editor: SlateEditor,\n  options?: InsertNodesOptions\n) => {\n  editor.tf.insertNodes<TEquationElement>(\n    {\n      children: [{ text: '' }],\n      texExpression: '',\n      type: editor.getType(KEYS.equation),\n    },\n    options as any\n  );\n};\n","import type {\n  InsertNodesOptions,\n  SlateEditor,\n  TEquationElement,\n} from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const insertInlineEquation = (\n  editor: SlateEditor,\n  texExpression?: string,\n  options?: InsertNodesOptions\n) => {\n  editor.tf.insertNodes<TEquationElement>(\n    {\n      children: [{ text: '' }],\n      texExpression: texExpression ?? editor.api.string(editor.selection),\n      type: editor.getType(KEYS.inlineEquation),\n    },\n    options as any\n  );\n};\n","import { bindFirst, createSlatePlugin, KEYS } from 'platejs';\n\nimport { insertInlineEquation } from './transforms';\n\nexport const BaseInlineEquationPlugin = createSlatePlugin({\n  key: KEYS.inlineEquation,\n  node: { isElement: true, isInline: true, isVoid: true },\n}).extendEditorTransforms(({ editor }) => ({\n  insert: {\n    inlineEquation: bindFirst(insertInlineEquation, editor),\n  },\n}));\n","import { toPlatePlugin } from 'platejs/react';\n\nimport { BaseInlineEquationPlugin } from '../lib';\n\nexport const InlineEquationPlugin = toPlatePlugin(BaseInlineEquationPlugin);\n","import React from 'react';\n\nimport type { TEquationElement } from 'platejs';\n\nimport katex, { type KatexOptions } from 'katex';\n\nexport const useEquationElement = ({\n  element,\n  katexRef,\n  options,\n}: {\n  element: TEquationElement;\n  katexRef: React.MutableRefObject<HTMLDivElement | null>;\n  options?: KatexOptions;\n}) => {\n  React.useEffect(() => {\n    if (!katexRef.current) return;\n\n    katex.render(element.texExpression, katexRef.current, options);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [element.texExpression]);\n};\n","import React, { useEffect, useRef } from 'react';\n\nimport { type TEquationElement, isHotkey } from 'platejs';\nimport { useEditorRef, useElement } from 'platejs/react';\n\nexport const useEquationInput = ({\n  isInline,\n  open,\n  onClose,\n}: {\n  isInline?: boolean;\n  open?: boolean;\n  onClose?: () => void;\n}) => {\n  const editor = useEditorRef();\n  const element = useElement<TEquationElement>();\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  const [expressionInput, setExpressionInput] = React.useState<string>(\n    element.texExpression\n  );\n\n  const initialExpressionRef = useRef<string>(element.texExpression);\n\n  useEffect(() => {\n    if (open) {\n      setTimeout(() => {\n        if (inputRef.current) {\n          inputRef.current.focus();\n          inputRef.current.select();\n\n          if (isInline) {\n            initialExpressionRef.current = element.texExpression;\n          }\n        }\n      }, 0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [open]);\n\n  useEffect(() => {\n    const setExpression = () => {\n      editor.tf.setNodes<TEquationElement>(\n        {\n          texExpression: expressionInput || '',\n        },\n        { at: element }\n      );\n    };\n    // When the cursor is inside an inline equation, the popover needs to open.\n    // However, during an undo operation, the cursor focuses on the inline equation, triggering the popover to open, which disrupts the normal undo process.\n    // So we need to remove the inline equation focus in one times undo.\n    // block equation will not block the undo process because it will not open the popover by focus.\n    // The disadvantage of this approach for block equation is that the popover cannot be opened using the keyboard.\n    isInline ? editor.tf.withMerging(setExpression) : setExpression();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [expressionInput]);\n\n  const onSubmit = () => {\n    onClose?.();\n  };\n\n  const onDismiss = () => {\n    if (isInline) {\n      editor.tf.setNodes(\n        {\n          texExpression: initialExpressionRef.current,\n        },\n        { at: element }\n      );\n    }\n\n    onClose?.();\n  };\n\n  return {\n    props: {\n      value: expressionInput,\n      onChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n        setExpressionInput(e.target.value);\n      },\n      onKeyDown: (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n        if (isHotkey('enter')(e)) {\n          e.preventDefault();\n          onSubmit();\n        } else if (isHotkey('escape')(e)) {\n          e.preventDefault();\n          onDismiss();\n        }\n        if (isInline) {\n          const { selectionEnd, selectionStart, value } =\n            e.target as HTMLInputElement;\n\n          // at the left edge\n          if (\n            selectionStart === 0 &&\n            selectionEnd === 0 &&\n            isHotkey('ArrowLeft')(e)\n          ) {\n            e.preventDefault();\n            editor.tf.select(element, {\n              focus: true,\n              previous: true,\n            });\n          }\n          // at the right edge\n          if (\n            selectionEnd === value.length &&\n            selectionStart === value.length &&\n            isHotkey('ArrowRight')(e)\n          ) {\n            e.preventDefault();\n            editor.tf.select(element, {\n              focus: true,\n              next: true,\n            });\n          }\n        }\n      },\n    },\n    ref: inputRef,\n    onDismiss,\n    onSubmit,\n  };\n};\n"],"mappings":"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","names":["KEYS","KEYS","KEYS","bindFirst","createSlatePlugin","KEYS","createSlatePlugin","KEYS","bindFirst","toPlatePlugin","toPlatePlugin","React"]}