{"version":3,"sources":["../src/lib/BaseCodeBlockPlugin.ts","../src/lib/deserializer/htmlDeserializerCodeBlock.ts","../src/lib/queries/getCodeLineEntry.ts","../src/lib/queries/getIndentDepth.ts","../src/lib/queries/isCodeBlockEmpty.ts","../src/lib/queries/isSelectionAtCodeBlockStart.ts","../src/lib/setCodeBlockToDecorations.ts","../src/lib/transforms/deleteStartSpace.ts","../src/lib/transforms/indentCodeLine.ts","../src/lib/transforms/insertCodeBlock.ts","../src/lib/transforms/insertCodeLine.ts","../src/lib/transforms/insertEmptyCodeBlock.ts","../src/lib/transforms/outdentCodeLine.ts","../src/lib/transforms/toggleCodeBlock.ts","../src/lib/transforms/unwrapCodeBlock.ts","../src/lib/withInsertDataCodeBlock.ts","../src/lib/withInsertFragmentCodeBlock.ts","../src/lib/withNormalizeCodeBlock.tsx","../src/lib/withCodeBlock.ts","../src/lib/formatter/jsonFormatter.ts","../src/lib/formatter/formatter.ts"],"sourcesContent":["import type { createLowlight } from 'lowlight';\n\nimport {\n  type PluginConfig,\n  type TCodeBlockElement,\n  type TElement,\n  createSlatePlugin,\n  createTSlatePlugin,\n  KEYS,\n} from 'platejs';\n\nimport { htmlDeserializerCodeBlock } from './deserializer/htmlDeserializerCodeBlock';\nimport { isCodeBlockEmpty } from './queries';\nimport {\n  CODE_LINE_TO_DECORATIONS,\n  setCodeBlockToDecorations as setCodeBlockToDecorations,\n} from './setCodeBlockToDecorations';\nimport { withCodeBlock } from './withCodeBlock';\n\nexport type CodeBlockConfig = PluginConfig<\n  'code_block',\n  {\n    /**\n     * Default language to use when no language is specified. Set to null to\n     * disable syntax highlighting by default.\n     */\n    defaultLanguage?: string | null;\n    /**\n     * Lowlight instance to use for highlighting. If not provided, syntax\n     * highlighting will be disabled.\n     */\n    lowlight?: ReturnType<typeof createLowlight> | null;\n  }\n>;\n\nexport const BaseCodeLinePlugin = createTSlatePlugin({\n  key: KEYS.codeLine,\n  node: { isElement: true, isStrictSiblings: true },\n});\n\nexport const BaseCodeSyntaxPlugin = createSlatePlugin({\n  key: KEYS.codeSyntax,\n  node: { isLeaf: true },\n});\n\nexport const BaseCodeBlockPlugin = createTSlatePlugin<CodeBlockConfig>({\n  key: KEYS.codeBlock,\n  inject: {\n    plugins: {\n      [KEYS.html]: {\n        parser: {\n          query: ({ editor }) =>\n            !editor.api.some({\n              match: { type: editor.getType(KEYS.codeLine) },\n            }),\n        },\n      },\n    },\n  },\n  node: {\n    isElement: true,\n  },\n  options: {\n    defaultLanguage: null,\n    lowlight: null,\n  },\n  parsers: { html: { deserializer: htmlDeserializerCodeBlock } },\n  plugins: [BaseCodeLinePlugin, BaseCodeSyntaxPlugin],\n  render: { as: 'pre' },\n  rules: {\n    delete: {\n      empty: 'reset',\n    },\n    match: ({ editor, rule }) => {\n      return (\n        ['break.empty', 'delete.empty'].includes(rule) &&\n        isCodeBlockEmpty(editor)\n      );\n    },\n  },\n  decorate: ({ editor, entry: [node, path], getOptions, type }) => {\n    if (!getOptions().lowlight) return [];\n\n    const codeLineType = editor.getType(KEYS.codeLine);\n\n    // Initialize decorations for the code block, we assume code line decorate will be called next.\n    if (\n      node.type === type &&\n      !CODE_LINE_TO_DECORATIONS.get((node.children as TElement[])[0])\n    ) {\n      setCodeBlockToDecorations(editor, [node as TCodeBlockElement, path]);\n    }\n\n    if (node.type === codeLineType) {\n      return CODE_LINE_TO_DECORATIONS.get(node as TElement) || [];\n    }\n\n    return [];\n  },\n})\n  .overrideEditor(withCodeBlock)\n  .extendTransforms(({ editor }) => ({\n    toggle: () => {\n      editor.tf.toggleBlock(editor.getType(KEYS.codeBlock));\n    },\n  }));\n","import type { HtmlDeserializer } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const htmlDeserializerCodeBlock: HtmlDeserializer = {\n  rules: [\n    {\n      validNodeName: 'PRE',\n    },\n    {\n      validNodeName: 'P',\n      validStyle: {\n        fontFamily: 'Consolas',\n      },\n    },\n  ],\n  parse: ({ element }) => {\n    const languageSelectorText =\n      [...element.childNodes].find(\n        (node: ChildNode) => node.nodeName === 'SELECT'\n      )?.textContent || '';\n\n    const textContent =\n      element.textContent?.replace(languageSelectorText, '') || '';\n\n    let lines = textContent.split('\\n');\n\n    if (!lines?.length) {\n      lines = [textContent];\n    }\n\n    const codeLines = lines.map((line) => ({\n      children: [{ text: line }],\n      type: KEYS.codeLine,\n    }));\n\n    return {\n      children: codeLines,\n      type: KEYS.codeBlock,\n    };\n  },\n};\n","import {\n  type ElementOf,\n  type NodeEntry,\n  type SlateEditor,\n  type TElement,\n  type TLocation,\n  ElementApi,\n  KEYS,\n} from 'platejs';\n\n/** If at (default = selection) is in ul>li>p, return li and ul node entries. */\nexport const getCodeLineEntry = <N extends ElementOf<E>, E extends SlateEditor>(\n  editor: E,\n  { at = editor.selection }: { at?: TLocation | null } = {}\n) => {\n  if (\n    at &&\n    editor.api.some({\n      at,\n      match: { type: editor.getType(KEYS.codeLine) },\n    })\n  ) {\n    const selectionParent = editor.api.parent(at);\n\n    if (!selectionParent) return;\n\n    const [, parentPath] = selectionParent;\n\n    const codeLine =\n      editor.api.above<TElement>({\n        at,\n        match: { type: editor.getType(KEYS.codeLine) },\n      }) || editor.api.parent<N>(parentPath);\n\n    if (!codeLine) return;\n\n    const [codeLineNode, codeLinePath] = codeLine;\n\n    if (\n      ElementApi.isElement(codeLineNode) &&\n      codeLineNode.type !== editor.getType(KEYS.codeLine)\n    )\n      return;\n\n    const codeBlock = editor.api.parent<N>(codeLinePath);\n\n    if (!codeBlock) return;\n\n    return {\n      codeBlock,\n      codeLine: codeLine as NodeEntry<N>,\n    };\n  }\n};\n","import type { Editor } from 'platejs';\n\nimport type { IndentCodeLineOptions } from '../transforms/indentCodeLine';\n\nexport const getIndentDepth = (\n  editor: Editor,\n  { codeLine }: IndentCodeLineOptions\n) => {\n  const [, codeLinePath] = codeLine;\n  const text = editor.api.string(codeLinePath);\n\n  return text.search(/\\S|$/);\n};\n","import { type SlateEditor, NodeApi } from 'platejs';\n\nimport { getCodeLineEntry } from './getCodeLineEntry';\n\n/** Is the selection inside an empty code block */\nexport const isCodeBlockEmpty = (editor: SlateEditor) => {\n  const { codeBlock } = getCodeLineEntry(editor) ?? {};\n\n  if (!codeBlock) return false;\n\n  const codeLines = Array.from(NodeApi.children(editor, codeBlock[1]));\n\n  if (codeLines.length === 0) return true;\n  if (codeLines.length > 1) return false;\n\n  const firstCodeLineNode = codeLines[0][0];\n\n  return !NodeApi.string(firstCodeLineNode);\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { getCodeLineEntry } from './getCodeLineEntry';\n\n/** Is the selection at the start of the first code line in a code block */\nexport const isSelectionAtCodeBlockStart = (editor: SlateEditor) => {\n  const { selection } = editor;\n\n  if (!selection || editor.api.isExpanded()) return false;\n\n  const { codeBlock } = getCodeLineEntry(editor) ?? {};\n\n  if (!codeBlock) return false;\n\n  return editor.api.isStart(selection.anchor, codeBlock[1]);\n};\n","import {\n  type DecoratedRange,\n  type NodeEntry,\n  type SlateEditor,\n  type TCodeBlockElement,\n  type TElement,\n  KEYS,\n  NodeApi,\n} from 'platejs';\n\nimport { BaseCodeBlockPlugin } from './BaseCodeBlockPlugin';\n\n// Cache for storing decorations per code line element\nexport const CODE_LINE_TO_DECORATIONS = new WeakMap<\n  TElement,\n  DecoratedRange[]\n>();\n\n// Helper function to get highlight nodes from Lowlight result\nfunction getHighlightNodes(result: any) {\n  return result.value || result.children || [];\n}\n\n// Helper function to parse nodes from Lowlight's hast tree\nfunction parseNodes(\n  nodes: any[],\n  className: string[] = []\n): { classes: string[]; text: string }[] {\n  return nodes.flatMap((node) => {\n    const classes = [\n      ...className,\n      ...(node.properties ? node.properties.className : []),\n    ];\n    if (node.children) {\n      return parseNodes(node.children, classes);\n    }\n    return { classes, text: node.value };\n  });\n}\n\n// Helper function to normalize tokens by line\nfunction normalizeTokens(tokens: { classes: string[]; text: string }[]) {\n  const lines: { classes: string[]; content: string }[][] = [[]];\n  let currentLine = lines[0];\n\n  for (const token of tokens) {\n    const tokenLines = token.text.split('\\n');\n\n    for (let i = 0; i < tokenLines.length; i++) {\n      const content = tokenLines[i];\n\n      if (content) {\n        currentLine.push({ classes: token.classes, content });\n      }\n\n      // Create a new line unless we're on the last line\n      if (i < tokenLines.length - 1) {\n        lines.push([]);\n        currentLine = lines.at(-1) as any;\n      }\n    }\n  }\n\n  return lines;\n}\n\n// Helper function to compute decorations for a code block\nexport function codeBlockToDecorations(\n  editor: SlateEditor,\n  [block, blockPath]: NodeEntry<TCodeBlockElement>\n) {\n  const { defaultLanguage, ...options } =\n    editor.getOptions(BaseCodeBlockPlugin);\n  const lowlight = options.lowlight!;\n\n  // Get all code lines and combine their text\n  const text = block.children.map((line) => NodeApi.string(line)).join('\\n');\n  const language = block.lang;\n  const effectiveLanguage = language || defaultLanguage;\n\n  let highlighted;\n  try {\n    // Skip highlighting for plaintext or when no language is specified\n    if (!effectiveLanguage || effectiveLanguage === 'plaintext') {\n      highlighted = { value: [] }; // Empty result for plaintext\n    } else if (effectiveLanguage === 'auto') {\n      highlighted = lowlight.highlightAuto(text);\n    } else {\n      highlighted = lowlight.highlight(effectiveLanguage, text);\n    }\n  } catch (error) {\n    // Verify if language is registered, fallback to plaintext if not\n    const availableLanguages = lowlight.listLanguages();\n    const isLanguageRegistered =\n      effectiveLanguage && availableLanguages.includes(effectiveLanguage);\n    if (isLanguageRegistered) {\n      editor.api.debug.error(error, 'CODE_HIGHLIGHT');\n      highlighted = { value: [] }; // Empty result on error\n    } else {\n      editor.api.debug.warn(\n        `Language \"${effectiveLanguage}\" is not registered. Falling back to plaintext`\n      );\n      highlighted = { value: [] };\n    }\n  }\n\n  // Parse and normalize tokens\n  const tokens = parseNodes(getHighlightNodes(highlighted));\n  const normalizedTokens = normalizeTokens(tokens);\n  const blockChildren = block.children as TElement[];\n\n  // Create decorations map\n  const nodeToDecorations = new Map<TElement, DecoratedRange[]>();\n\n  // Safety check: don't process more lines than we have children\n  const numLines = Math.min(normalizedTokens.length, blockChildren.length);\n\n  // Process each line's tokens\n  for (let index = 0; index < numLines; index++) {\n    const lineTokens = normalizedTokens[index];\n    const element = blockChildren[index];\n\n    if (!nodeToDecorations.has(element)) {\n      nodeToDecorations.set(element, []);\n    }\n\n    let start = 0;\n    for (const token of lineTokens) {\n      const length = token.content.length;\n      if (!length) continue;\n\n      const end = start + length;\n\n      const decoration: DecoratedRange = {\n        anchor: {\n          offset: start,\n          path: [...blockPath, index, 0],\n        },\n        className: token.classes.join(' '),\n        focus: {\n          offset: end,\n          path: [...blockPath, index, 0],\n        },\n        [KEYS.codeSyntax]: true,\n      } as any;\n\n      nodeToDecorations.get(element)!.push(decoration);\n      start = end;\n    }\n  }\n\n  return nodeToDecorations;\n}\n\nexport function setCodeBlockToDecorations(\n  editor: SlateEditor,\n  [block, blockPath]: NodeEntry<TCodeBlockElement>\n) {\n  const decorations = codeBlockToDecorations(editor, [block, blockPath]);\n\n  // Update the global cache with the new decorations\n  for (const [node, decs] of decorations.entries()) {\n    CODE_LINE_TO_DECORATIONS.set(node, decs);\n  }\n}\n\nexport function resetCodeBlockDecorations(codeBlock: TCodeBlockElement) {\n  codeBlock.children.forEach((line) => {\n    CODE_LINE_TO_DECORATIONS.delete(line as TElement);\n  });\n}\n","import type { Editor } from 'platejs';\n\nimport type { OutdentCodeLineOptions } from './outdentCodeLine';\n\n/** If there is a whitespace character at the start of the code line, delete it. */\nexport const deleteStartSpace = (\n  editor: Editor,\n  { codeLine }: OutdentCodeLineOptions\n) => {\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = editor.api.start(codeLinePath);\n  const codeLineEnd = codeLineStart && editor.api.after(codeLineStart);\n  const spaceRange =\n    codeLineEnd && editor.api.range(codeLineStart, codeLineEnd);\n  const spaceText = editor.api.string(spaceRange);\n\n  if (/\\s/.test(spaceText)) {\n    editor.tf.delete({ at: spaceRange });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { Editor, ElementEntry } from 'platejs';\n\nexport interface IndentCodeLineOptions {\n  codeBlock: ElementEntry;\n  codeLine: ElementEntry;\n  indentDepth?: number;\n}\n\n/**\n * Indent if:\n *\n * - The selection is expanded OR\n * - There are no non-whitespace characters left of the cursor Indentation = 2\n *   spaces.\n */\nexport const indentCodeLine = (\n  editor: Editor,\n  { codeLine, indentDepth = 2 }: IndentCodeLineOptions\n) => {\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = editor.api.start(codeLinePath)!;\n  const indent = ' '.repeat(indentDepth);\n\n  if (!editor.api.isExpanded()) {\n    const cursor = editor.selection?.anchor;\n    const range = editor.api.range(codeLineStart, cursor);\n    const text = editor.api.string(range);\n\n    if (/\\S/.test(text)) {\n      editor.tf.insertText(indent, { at: editor.selection! });\n\n      return;\n    }\n  }\n\n  editor.tf.insertText(indent, { at: codeLineStart });\n};\n","import type { InsertNodesOptions, SlateEditor, TElement } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\n/**\n * Insert a code block: set the node to code line and wrap it with a code block.\n * If the cursor is not at the block start, insert break before.\n */\nexport const insertCodeBlock = (\n  editor: SlateEditor,\n  insertNodesOptions: Omit<InsertNodesOptions, 'match'> = {}\n) => {\n  if (!editor.selection || editor.api.isExpanded()) return;\n\n  const matchCodeElements = (node: TElement) =>\n    node.type === KEYS.codeBlock || node.type === KEYS.codeLine;\n\n  if (\n    editor.api.some({\n      match: matchCodeElements,\n    })\n  ) {\n    return;\n  }\n  if (!editor.api.isAt({ start: true })) {\n    editor.tf.insertBreak();\n  }\n\n  editor.tf.setNodes(\n    {\n      children: [{ text: '' }],\n      type: KEYS.codeLine,\n    },\n    insertNodesOptions\n  );\n\n  editor.tf.wrapNodes<TElement>(\n    {\n      children: [],\n      type: KEYS.codeBlock,\n    },\n    insertNodesOptions\n  );\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\n/** Insert a code line starting with indentation. */\nexport const insertCodeLine = (editor: SlateEditor, indentDepth = 0) => {\n  if (editor.selection) {\n    const indent = ' '.repeat(indentDepth);\n\n    editor.tf.insertNodes({\n      children: [{ text: indent }],\n      type: editor.getType(KEYS.codeLine),\n    });\n  }\n};\n","import { type InsertNodesOptions, type SlateEditor, KEYS } from 'platejs';\n\nimport { insertCodeBlock } from './insertCodeBlock';\n\nexport interface CodeBlockInsertOptions {\n  defaultType?: string;\n  insertNodesOptions?: Omit<InsertNodesOptions, 'match'>;\n}\n\n/**\n * Called by toolbars to make sure a code-block gets inserted below a paragraph\n * rather than awkwardly splitting the current selection.\n */\nexport const insertEmptyCodeBlock = (\n  editor: SlateEditor,\n  {\n    defaultType = editor.getType(KEYS.p),\n    insertNodesOptions,\n  }: CodeBlockInsertOptions = {}\n) => {\n  if (!editor.selection) return;\n  if (\n    editor.api.isExpanded() ||\n    !editor.api.isEmpty(editor.selection, { block: true })\n  ) {\n    editor.tf.insertNodes(\n      editor.api.create.block({ children: [{ text: '' }], type: defaultType }),\n      {\n        nextBlock: true,\n        select: true,\n        ...insertNodesOptions,\n      }\n    );\n  }\n\n  insertCodeBlock(editor, insertNodesOptions);\n};\n","import type { Editor, ElementEntry } from 'platejs';\n\nimport { deleteStartSpace } from './deleteStartSpace';\n\nexport interface OutdentCodeLineOptions {\n  codeBlock: ElementEntry;\n  codeLine: ElementEntry;\n}\n\n/** Outdent the code line. Remove 2 whitespace characters if any. */\nexport const outdentCodeLine = (\n  editor: Editor,\n  { codeBlock, codeLine }: OutdentCodeLineOptions\n) => {\n  const deleted = deleteStartSpace(editor, { codeBlock, codeLine });\n  deleted && deleteStartSpace(editor, { codeBlock, codeLine });\n};\n","import type { SlateEditor, TElement } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { unwrapCodeBlock } from './unwrapCodeBlock';\n\nexport const toggleCodeBlock = (editor: SlateEditor) => {\n  if (!editor.selection) return;\n\n  const codeBlockType = editor.getType(KEYS.codeBlock);\n  const codeLineType = editor.getType(KEYS.codeLine);\n\n  const isActive = editor.api.some({\n    match: { type: codeBlockType },\n  });\n\n  editor.tf.withoutNormalizing(() => {\n    unwrapCodeBlock(editor);\n\n    if (!isActive) {\n      editor.tf.setNodes({\n        type: codeLineType,\n      });\n\n      const codeBlock = {\n        children: [],\n        type: codeBlockType,\n      };\n\n      editor.tf.wrapNodes<TElement>(codeBlock);\n    }\n  });\n};\n","import { type SlateEditor, type TLocation, KEYS, NodeApi } from 'platejs';\n\nexport const unwrapCodeBlock = (editor: SlateEditor) => {\n  if (!editor.selection) return;\n\n  const codeBlockType = editor.getType(KEYS.codeBlock);\n  const defaultType = editor.getType(KEYS.p);\n\n  editor.tf.withoutNormalizing(() => {\n    const codeBlockEntries = editor.api.nodes({\n      at: editor.selection as TLocation,\n      match: { type: codeBlockType },\n    });\n\n    const reversedCodeBlockEntries = Array.from(codeBlockEntries).reverse();\n\n    for (const codeBlockEntry of reversedCodeBlockEntries) {\n      const codeLineEntries = NodeApi.children(editor, codeBlockEntry[1]);\n\n      for (const [, path] of codeLineEntries) {\n        editor.tf.setNodes({ type: defaultType }, { at: path });\n      }\n\n      editor.tf.unwrapNodes({\n        at: codeBlockEntry[1],\n        match: { type: codeBlockType },\n        split: true,\n      });\n    }\n  });\n};\n","import type { OverrideEditor, TElement } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const withInsertDataCodeBlock: OverrideEditor = ({\n  editor,\n  tf: { insertData },\n  type: codeBlockType,\n}) => ({\n  transforms: {\n    insertData(data) {\n      const text = data.getData('text/plain');\n      const vscodeDataString = data.getData('vscode-editor-data');\n      const codeLineType = editor.getType(KEYS.codeLine);\n\n      // Handle VSCode paste with language\n      if (vscodeDataString) {\n        try {\n          const vscodeData = JSON.parse(vscodeDataString);\n          const lines = text.split('\\n');\n\n          // Check if we're in a code block\n          const [blockAbove] = editor.api.block<TElement>() ?? [];\n          const isInCodeBlock =\n            blockAbove &&\n            [codeBlockType, codeLineType].includes(blockAbove?.type);\n\n          if (isInCodeBlock) {\n            // If in code block, insert first line as text at cursor\n            if (lines[0]) {\n              editor.tf.insertText(lines[0]);\n            }\n\n            // Insert remaining lines as new code lines\n            if (lines.length > 1) {\n              const nodes = lines.slice(1).map((line) => ({\n                children: [{ text: line }],\n                type: codeLineType,\n              }));\n              editor.tf.insertNodes(nodes);\n            }\n          } else {\n            // Create new code block\n            const node = {\n              children: lines.map((line) => ({\n                children: [{ text: line }],\n                type: codeLineType,\n              })),\n              lang: vscodeData?.mode,\n              type: codeBlockType,\n            };\n\n            editor.tf.insertNodes(node, {\n              select: true,\n            });\n          }\n\n          return;\n        } catch (error) {}\n      }\n\n      // Handle plain text paste into code block only if there are line breaks\n      const [blockAbove] = editor.api.block<TElement>() ?? [];\n      if (\n        blockAbove &&\n        [codeBlockType, codeLineType].includes(blockAbove?.type) &&\n        text?.includes('\\n')\n      ) {\n        const lines = text.split('\\n');\n\n        // Insert first line as text at cursor\n        if (lines[0]) {\n          editor.tf.insertText(lines[0]);\n        }\n\n        // Insert remaining lines as new code lines\n        if (lines.length > 1) {\n          const nodes = lines.slice(1).map((line) => ({\n            children: [{ text: line }],\n            type: codeLineType,\n          }));\n          editor.tf.insertNodes(nodes);\n        }\n        return;\n      }\n\n      insertData(data);\n    },\n  },\n});\n","import { type OverrideEditor, type TElement, KEYS, NodeApi } from 'platejs';\n\nfunction extractCodeLinesFromCodeBlock(node: TElement) {\n  return node.children as TElement[];\n}\n\nexport const withInsertFragmentCodeBlock: OverrideEditor = ({\n  editor,\n  tf: { insertFragment },\n  type: codeBlockType,\n}) => ({\n  transforms: {\n    insertFragment(fragment) {\n      const [blockAbove] = editor.api.block<TElement>() ?? [];\n      const codeLineType = editor.getType(KEYS.codeLine);\n\n      function convertNodeToCodeLine(node: TElement): TElement {\n        return {\n          children: [{ text: NodeApi.string(node) }],\n          type: codeLineType,\n        };\n      }\n\n      if (\n        blockAbove &&\n        [codeBlockType, codeLineType].includes(blockAbove?.type)\n      ) {\n        return insertFragment(\n          fragment.flatMap((node) => {\n            const element = node as TElement;\n\n            return element.type === codeBlockType\n              ? extractCodeLinesFromCodeBlock(element)\n              : convertNodeToCodeLine(element);\n          })\n        );\n      }\n\n      return insertFragment(fragment);\n    },\n  },\n});\n","import {\n  type NodeEntry,\n  type OverrideEditor,\n  type TCodeBlockElement,\n  ElementApi,\n  KEYS,\n  NodeApi,\n} from 'platejs';\n\nimport type { CodeBlockConfig } from './BaseCodeBlockPlugin';\n\nimport { setCodeBlockToDecorations } from './setCodeBlockToDecorations';\n\n/** Normalize code block node to force the pre>code>div.codeline structure. */\nexport const withNormalizeCodeBlock: OverrideEditor<CodeBlockConfig> = ({\n  editor,\n  getOptions,\n  tf: { normalizeNode },\n  type,\n}) => ({\n  transforms: {\n    normalizeNode([node, path]) {\n      // Decorate is called on selection change as well, so we prefer to only run this on code block changes.\n      if (node.type === type && getOptions().lowlight) {\n        setCodeBlockToDecorations(editor, [\n          node,\n          path,\n        ] as NodeEntry<TCodeBlockElement>);\n      }\n\n      normalizeNode([node, path]);\n\n      if (!ElementApi.isElement(node)) {\n        return;\n      }\n\n      const codeBlockType = editor.getType(KEYS.codeBlock);\n      const codeLineType = editor.getType(KEYS.codeLine);\n      const isCodeBlockRoot = node.type === codeBlockType;\n\n      if (isCodeBlockRoot) {\n        // Children should all be code lines\n        const nonCodeLine = Array.from(NodeApi.children(editor, path)).find(\n          ([child]) => child.type !== codeLineType\n        );\n\n        if (nonCodeLine) {\n          editor.tf.setNodes({ type: codeLineType }, { at: nonCodeLine[1] });\n        }\n      }\n    },\n  },\n});\n","import type { OverrideEditor, TCodeBlockElement, TElement } from 'platejs';\n\nimport type { CodeBlockConfig } from './BaseCodeBlockPlugin';\n\nimport { getCodeLineEntry, getIndentDepth } from './queries';\nimport { resetCodeBlockDecorations } from './setCodeBlockToDecorations';\nimport { indentCodeLine, outdentCodeLine, unwrapCodeBlock } from './transforms';\nimport { withInsertDataCodeBlock } from './withInsertDataCodeBlock';\nimport { withInsertFragmentCodeBlock } from './withInsertFragmentCodeBlock';\nimport { withNormalizeCodeBlock } from './withNormalizeCodeBlock';\n\nexport const withCodeBlock: OverrideEditor<CodeBlockConfig> = (ctx) => {\n  const {\n    editor,\n    getOptions,\n    tf: { apply, insertBreak, resetBlock, selectAll, tab },\n    type,\n  } = ctx;\n\n  return {\n    transforms: {\n      apply(operation) {\n        if (getOptions().lowlight && operation.type === 'set_node') {\n          const entry = editor.api.node(operation.path);\n\n          if (entry?.[0].type === type && operation.newProperties?.lang) {\n            // Clear decorations for all code lines in this block\n            resetCodeBlockDecorations(entry[0] as TCodeBlockElement);\n          }\n        }\n\n        apply(operation);\n      },\n      insertBreak() {\n        const apply = () => {\n          if (!editor.selection) return;\n\n          const res = getCodeLineEntry(editor, {});\n\n          if (!res) return;\n\n          const { codeBlock, codeLine } = res;\n          const indentDepth = getIndentDepth(editor, {\n            codeBlock,\n            codeLine,\n          });\n\n          insertBreak();\n\n          indentCodeLine(editor, {\n            codeBlock,\n            codeLine,\n            indentDepth,\n          });\n\n          return true;\n        };\n\n        if (apply()) return;\n\n        insertBreak();\n      },\n      resetBlock(options) {\n        if (\n          editor.api.block({\n            at: options?.at,\n            match: { type },\n          })\n        ) {\n          unwrapCodeBlock(editor);\n          return;\n        }\n\n        return resetBlock(options);\n      },\n      selectAll: () => {\n        const apply = () => {\n          const codeBlock = editor.api.above({\n            match: { type },\n          });\n\n          if (!codeBlock) return;\n\n          if (\n            editor.api.isAt({ end: true }) &&\n            editor.api.isAt({ start: true })\n          ) {\n            return;\n          }\n\n          // Select the whole code block\n          editor.tf.select(codeBlock[1]);\n          return true;\n        };\n\n        if (apply()) return true;\n\n        return selectAll();\n      },\n      tab: (options) => {\n        const apply = () => {\n          const _codeLines = editor.api.nodes<TElement>({\n            match: { type },\n          });\n          const codeLines = Array.from(_codeLines);\n\n          if (codeLines.length > 0) {\n            const [, firstLinePath] = codeLines[0];\n            const codeBlock = editor.api.parent<TElement>(firstLinePath);\n\n            if (!codeBlock) return;\n\n            editor.tf.withoutNormalizing(() => {\n              for (const codeLine of codeLines) {\n                if (options.reverse) {\n                  outdentCodeLine(editor, { codeBlock, codeLine });\n                } else {\n                  indentCodeLine(editor, { codeBlock, codeLine });\n                }\n              }\n            });\n\n            return true; // Prevent default\n          }\n        };\n\n        if (apply()) return true;\n\n        return tab(options);\n      },\n      ...withInsertDataCodeBlock(ctx).transforms,\n      ...withInsertFragmentCodeBlock(ctx).transforms,\n      ...withNormalizeCodeBlock(ctx).transforms,\n    },\n  };\n};\n","export const formatJson = (code: string): string => {\n  try {\n    return JSON.stringify(JSON.parse(code), null, 2);\n  } catch (error) {\n    return code;\n  }\n};\n\nexport const isValidJson = (code: string): boolean => {\n  try {\n    JSON.parse(code);\n\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n","import type { Editor, TCodeBlockElement } from 'platejs';\n\nimport { formatJson, isValidJson } from './jsonFormatter';\n\nconst supportedLanguages = new Set(['json']);\n\nexport const isLangSupported = (lang?: string): boolean =>\n  Boolean(lang && supportedLanguages.has(lang));\n\nexport const isValidSyntax = (code: string, lang?: string): boolean => {\n  if (!isLangSupported(lang)) {\n    return false;\n  }\n\n  switch (lang) {\n    case 'json': {\n      return isValidJson(code);\n    }\n    default: {\n      return false;\n    }\n  }\n};\n\nexport const formatCodeBlock = (\n  editor: Editor,\n  {\n    element,\n  }: {\n    element: TCodeBlockElement;\n  }\n) => {\n  const { lang } = element;\n\n  if (!lang || !isLangSupported(lang)) {\n    return;\n  }\n\n  const code = editor.api.string(element);\n\n  if (isValidSyntax(code, lang)) {\n    const formattedCode = formatCode(code, lang);\n    editor.tf.insertText(formattedCode, { at: element });\n  }\n};\n\nconst formatCode = (code: string, lang?: string): string => {\n  switch (lang) {\n    case 'json': {\n      return formatJson(code);\n    }\n    default: {\n      return code;\n    }\n  }\n};\n"],"mappings":"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","names":["KEYS","KEYS","KEYS","NodeApi","NodeApi","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","NodeApi","KEYS","KEYS","blockAbove","KEYS","NodeApi","ElementApi","KEYS","NodeApi","ElementApi","KEYS","NodeApi","apply","KEYS"]}