{"version":3,"sources":["../src/createDataTransfer.ts","../src/getHtmlDocument.ts","../src/jsx.ts","../src/internals/creators.ts","../src/internals/tokens.ts","../src/internals/hyperscript.ts"],"sourcesContent":["export type DataTransferDataMap = Map<DataTransferDataType, unknown>;\n\nexport type DataTransferDataType = string | 'text/html' | 'text/plain';\n\nexport const createDataTransfer = (dataMap: DataTransferDataMap = new Map()) =>\n  ({\n    getData: (type: string) => dataMap.get(type) ?? '',\n    setData: (type: string, value: string) => dataMap.set(type, value),\n  }) as unknown as DataTransfer;\n","export const getHtmlDocument = (html: string) =>\n  new DOMParser().parseFromString(html, 'text/html');\n","import {\n  type HyperscriptShorthands,\n  createHyperscript as createHyperscriptBase,\n  createText as createTestText,\n} from 'slate-hyperscript';\n\nimport { createText } from './internals/creators';\nimport { createHyperscript } from './internals/hyperscript';\n\nexport { createEditor } from './internals/creators';\nexport { createHyperscript };\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace JSX {\n    interface IntrinsicElements {\n      anchor: any;\n      cursor: any;\n      editor: any;\n      element: any;\n      focus: any;\n      fragment: any;\n      ha: any;\n      haudio: any;\n      hblockquote: any;\n      hcallout: any;\n      hcodeblock: any;\n      hcodeline: any;\n      hcolumn: any;\n      hcolumngroup: any;\n      hdate: any;\n      hdefault: any;\n      hequation: any;\n      hexcalidraw: any;\n      hfile: any;\n      hh1: any;\n      hh2: any;\n      hh3: any;\n      hh4: any;\n      hh5: any;\n      hh6: any;\n      himg: any;\n      hinlineequation: any;\n      hli: any;\n      hlic: any;\n      hmediaembed: any;\n      hmention: any;\n      hmentioninput: any;\n      hnli: any;\n      hol: any;\n      hp: any;\n      hplaceholder: any;\n      htable: any;\n      htd: any;\n      htext: {\n        [key: string]: any;\n        // These optional params will show up in the autocomplete!\n        bold?: boolean;\n        children?: any;\n        code?: boolean;\n        italic?: boolean;\n        underline?: boolean;\n      };\n      hth: any;\n      htoc: any;\n      htodoli: any;\n      htoggle: any;\n      htr: any;\n      hul: any;\n      hvideo: any;\n      selection: any;\n      text: any;\n    }\n  }\n}\n\nexport const voidChildren = [{ text: '' }];\n\nexport const elements: HyperscriptShorthands = {\n  ha: { type: 'a' },\n  haudio: { children: voidChildren, type: 'audio' },\n  hblockquote: { type: 'blockquote' },\n  hcallout: { type: 'callout' },\n  hcodeblock: { type: 'code_block' },\n  hcodeline: { type: 'code_line' },\n  hcolumn: { type: 'column' },\n  hcolumngroup: { type: 'column_group' },\n  hdate: { children: voidChildren, type: 'date' },\n  hdefault: { type: 'p' },\n  hequation: { type: 'equation' },\n  hexcalidraw: { type: 'excalidraw' },\n  hfile: { children: voidChildren, type: 'file' },\n  hh1: { type: 'h1' },\n  hh2: { type: 'h2' },\n  hh3: { type: 'h3' },\n  hh4: { type: 'h4' },\n  hh5: { type: 'h5' },\n  hh6: { type: 'h6' },\n  himg: { children: voidChildren, type: 'img' },\n  hinlineequation: { type: 'inline_equation' },\n  hli: { type: 'li' },\n  hlic: { type: 'lic' },\n  hmediaembed: { children: voidChildren, type: 'media_embed' },\n  hmention: { children: voidChildren, type: 'mention' },\n  hmentioninput: { children: voidChildren, type: 'mention_input' },\n  hnli: { type: 'nli' },\n  hol: { type: 'ol' },\n  hp: { type: 'p' },\n  hplaceholder: { children: voidChildren, type: 'placeholder' },\n  htable: { type: 'table' },\n  htd: { type: 'td' },\n  hth: { type: 'th' },\n  htoc: { type: 'toc' },\n  htodoli: { type: 'action_item' },\n  htoggle: { type: 'toggle' },\n  htr: { type: 'tr' },\n  hul: { type: 'ul' },\n  hvideo: { children: voidChildren, type: 'video' },\n};\n\nexport const jsx = createHyperscript({\n  creators: {\n    htext: createTestText,\n  },\n  elements,\n});\n\nexport const jsxt = createHyperscriptBase({\n  creators: {\n    htext: createTestText,\n  },\n  elements,\n});\n\nexport const hjsx = createHyperscript({\n  creators: {\n    htext: createText,\n  },\n  elements,\n});\n","import {\n  type Descendant,\n  type Editor,\n  type TElement,\n  type TNode,\n  type TRange,\n  type TText,\n  ElementApi,\n  NodeApi,\n  RangeApi,\n  TextApi,\n} from '@platejs/slate';\n\nimport {\n  addAnchorToken,\n  addFocusToken,\n  AnchorToken,\n  FocusToken,\n  getAnchorOffset,\n  getFocusOffset,\n  Token,\n} from './tokens';\n\n/**\n * Resolve the descedants of a node by normalizing the children that can be\n * passed into a hyperscript creator function.\n */\n\nconst STRINGS = new WeakSet<TText>();\n\nconst resolveDescendants = (children: any[]): Descendant[] => {\n  const nodes: Descendant[] = [];\n\n  const addChild = (child: TNode | Token): void => {\n    if (child == null) {\n      return;\n    }\n\n    const prev = nodes.at(-1);\n\n    if (typeof child === 'string') {\n      const text = { text: child };\n      STRINGS.add(text);\n      child = text;\n    }\n    if (TextApi.isText(child)) {\n      const c = child; // HACK: fix typescript complaining\n\n      if (\n        TextApi.isText(prev) &&\n        STRINGS.has(prev) &&\n        STRINGS.has(c) &&\n        TextApi.equals(prev, c, { loose: true })\n      ) {\n        prev.text += c.text;\n      } else {\n        nodes.push(c);\n      }\n    } else if (ElementApi.isElement(child)) {\n      nodes.push(child);\n    } else if (child instanceof Token) {\n      let n = nodes.at(-1);\n\n      if (!TextApi.isText(n)) {\n        addChild('');\n        n = nodes.at(-1) as TText;\n      }\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child);\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child);\n      }\n    } else {\n      throw new TypeError(\n        `Unexpected hyperscript child object: ${child as any}`\n      );\n    }\n  };\n\n  for (const child of children.flat(Number.POSITIVE_INFINITY)) {\n    addChild(child);\n  }\n\n  return nodes;\n};\n\n/** Create an anchor token. */\nexport const createAnchor = (\n  tagName: string,\n  attributes: Record<string, any>\n): AnchorToken => new AnchorToken(attributes);\n\n/** Create an anchor and a focus token. */\nexport const createCursor = (\n  tagName: string,\n  attributes: Record<string, any>\n): Token[] => [new AnchorToken(attributes), new FocusToken(attributes)];\n\n/** Create an `TElement` object. */\nexport const createElement = (\n  tagName: string,\n  attributes: Record<string, any>,\n  children: any[]\n): TElement => ({\n  ...(attributes as any),\n  children: resolveDescendants(children),\n});\n\n/** Create a focus token. */\nexport const createFocus = (\n  tagName: string,\n  attributes: Record<string, any>\n): FocusToken => new FocusToken(attributes);\n\n/** Create a fragment. */\nexport const createFragment = (\n  tagName: string,\n  attributes: Record<string, any>,\n  children: any[]\n): Descendant[] => resolveDescendants(children);\n\n/** Create a `Selection` object. */\nexport const createSelection = (\n  tagName: string,\n  attributes: Record<string, any>,\n  children: any[]\n): TRange => {\n  const anchor: AnchorToken = children.find((c) => c instanceof AnchorToken)!;\n  const focus: FocusToken = children.find((c) => c instanceof FocusToken)!;\n\n  if (!anchor?.offset || !anchor.path) {\n    throw new Error(\n      `The <selection> hyperscript tag must have an <anchor> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    );\n  }\n  if (!focus?.offset || !focus.path) {\n    throw new Error(\n      `The <selection> hyperscript tag must have a <focus> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    );\n  }\n\n  return {\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path,\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path,\n    },\n    ...attributes,\n  };\n};\n\n/** Create a `TText` object. */\nexport const createText = (\n  tagName: string,\n  attributes: Record<string, any>,\n  children: any[]\n): TText => {\n  const nodes = resolveDescendants(children);\n\n  if (nodes.length > 1) {\n    throw new Error(\n      `The <text> hyperscript tag must only contain a single node's worth of children.`\n    );\n  }\n\n  let [node] = nodes;\n\n  if (node == null) {\n    node = { text: '' };\n  }\n  if (!TextApi.isText(node)) {\n    throw new Error(`\n    The <text> hyperscript tag can only contain text content as children.`);\n  }\n\n  // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n  STRINGS.delete(node);\n\n  Object.assign(node, attributes);\n\n  return node;\n};\n\n/** Create a top-level `Editor` object. */\nexport const createEditor =\n  (makeEditor: () => Editor) =>\n  (\n    tagName: string,\n    attributes: Record<string, any>,\n    children: any[]\n  ): Editor => {\n    const otherChildren: any[] = [];\n    let selectionChild: TRange | undefined;\n\n    for (const child of children) {\n      if (RangeApi.isRange(child)) {\n        selectionChild = child;\n      } else {\n        otherChildren.push(child);\n      }\n    }\n\n    const descendants = resolveDescendants(otherChildren) as TElement[];\n    const selection: Partial<TRange> = {};\n    const editor = makeEditor();\n    Object.assign(editor, attributes);\n    editor.children = descendants;\n\n    // Search the document's texts to see if any of them have tokens associated\n    // that need incorporated into the selection.\n    for (const [node, path] of NodeApi.texts(editor)) {\n      const anchor = getAnchorOffset(node);\n      const focus = getFocusOffset(node);\n\n      if (anchor != null) {\n        const [offset] = anchor;\n        selection.anchor = { offset, path };\n      }\n      if (focus != null) {\n        const [offset] = focus;\n        selection.focus = { offset, path };\n      }\n    }\n\n    if (selection.anchor && !selection.focus) {\n      throw new Error(\n        `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<anchor />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n      );\n    }\n    if (!selection.anchor && selection.focus) {\n      throw new Error(\n        `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<focus />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n      );\n    }\n    if (selectionChild != null) {\n      editor.selection = selectionChild;\n    } else if (RangeApi.isRange(selection)) {\n      editor.selection = selection;\n    }\n\n    return editor;\n  };\n","import type { Path, TNode, TText } from '@platejs/slate';\n\n/** A weak map to hold anchor tokens. */\n\nconst ANCHOR = new WeakMap<TNode, [number, AnchorToken]>();\n\n/** A weak map to hold focus tokens. */\n\nconst FOCUS = new WeakMap<TNode, [number, FocusToken]>();\n\n/** All tokens inherit from a single constructor for `instanceof` checking. */\n\nexport class Token {}\n\n/** Anchor tokens represent the selection's anchor point. */\n\nexport class AnchorToken extends Token {\n  offset?: number;\n  path?: Path;\n\n  constructor(\n    props: {\n      offset?: number;\n      path?: Path;\n    } = {}\n  ) {\n    super();\n    const { offset, path } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n}\n\n/** Focus tokens represent the selection's focus point. */\n\nexport class FocusToken extends Token {\n  offset?: number;\n  path?: Path;\n\n  constructor(\n    props: {\n      offset?: number;\n      path?: Path;\n    } = {}\n  ) {\n    super();\n    const { offset, path } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n}\n\n/** Add an anchor token to the end of a text node. */\n\nexport const addAnchorToken = (text: TText, token: AnchorToken) => {\n  const offset = text.text.length;\n  ANCHOR.set(text, [offset, token]);\n};\n\n/** Get the offset if a text node has an associated anchor token. */\n\nexport const getAnchorOffset = (\n  text: TText\n): [number, AnchorToken] | undefined => {\n  return ANCHOR.get(text);\n};\n\n/** Add a focus token to the end of a text node. */\n\nexport const addFocusToken = (text: TText, token: FocusToken) => {\n  const offset = text.text.length;\n  FOCUS.set(text, [offset, token]);\n};\n\n/** Get the offset if a text node has an associated focus token. */\n\nexport const getFocusOffset = (\n  text: TText\n): [number, FocusToken] | undefined => {\n  return FOCUS.get(text);\n};\n","import { type TElement, createEditor as makeEditor } from '@platejs/slate';\n\nimport {\n  createAnchor,\n  createCursor,\n  createEditor,\n  createElement,\n  createFocus,\n  createFragment,\n  createSelection,\n  createText,\n} from './creators';\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    Object.getPrototypeOf(value) === Object.prototype\n  );\n}\n\n/** The default creators for Slate objects. */\n\nconst DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor(makeEditor),\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText,\n};\n\n/**\n * `HyperscriptCreators` are dictionaries of `HyperscriptCreator` functions\n * keyed by tag name.\n */\n\ntype HyperscriptCreators<T = any> = Record<\n  string,\n  (tagName: string, attributes: Record<string, any>, children: any[]) => T\n>;\n\n/**\n * `HyperscriptShorthands` are dictionaries of properties applied to specific\n * kind of object, keyed by tag name. They allow you to easily define custom\n * hyperscript tags for your domain.\n */\n\ntype HyperscriptShorthands = Record<string, Record<string, any>>;\n\n/** Create a Slate hyperscript function with `options`. */\n\nconst createHyperscript = (\n  options: {\n    creators?: HyperscriptCreators;\n    elements?: HyperscriptShorthands;\n  } = {}\n) => {\n  const { elements = {} } = options;\n  const elementCreators = normalizeElements(elements);\n  const creators = {\n    ...DEFAULT_CREATORS,\n    ...elementCreators,\n    ...options.creators,\n  };\n\n  const jsx = createFactory(creators);\n\n  return jsx;\n};\n\n/** Create a Slate hyperscript function with `options`. */\n\nconst createFactory = <T extends HyperscriptCreators>(creators: T) => {\n  const jsx = <S extends keyof T & string>(\n    tagName: S,\n    attributes?: object,\n    ...children: any[]\n  ): ReturnType<T[S]> => {\n    for (const key in attributes) {\n      if (key.startsWith('__')) {\n        delete (attributes as any)[key];\n      }\n    }\n\n    const creator = creators[tagName];\n\n    if (!creator) {\n      throw new Error(`No hyperscript creator found for tag: <${tagName}>`);\n    }\n    if (attributes == null) {\n      attributes = {};\n    }\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children);\n      attributes = {};\n    }\n\n    children = children.filter(Boolean).flat();\n    const ret = creator(tagName, attributes, children);\n\n    return ret;\n  };\n\n  return jsx;\n};\n\n/** Normalize a dictionary of element shorthands into creator functions. */\n\nconst normalizeElements = (elements: HyperscriptShorthands) => {\n  const creators: HyperscriptCreators<TElement> = {};\n\n  for (const tagName in elements) {\n    const props = elements[tagName];\n\n    if (typeof props !== 'object') {\n      throw new TypeError(\n        `Properties specified for a hyperscript shorthand should be an object, but for the custom element <${tagName}>  tag you passed: ${props}`\n      );\n    }\n\n    creators[tagName] = (\n      tagName: string,\n      attributes: Record<string, any>,\n      children: any[]\n    ) => {\n      for (const key in attributes) {\n        if (key.startsWith('__')) {\n          delete attributes[key];\n        }\n      }\n\n      const el = createElement(\n        'element',\n        { ...props, ...attributes },\n        children\n      );\n\n      return el;\n    };\n  }\n\n  return creators;\n};\n\nexport { createHyperscript };\n"],"mappings":"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","names":["makeEditor","elements","jsx","tagName"]}