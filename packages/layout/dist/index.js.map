{"version":3,"sources":["../src/index.ts","../src/lib/BaseColumnPlugin.ts","../src/lib/withColumn.ts","../src/lib/transforms/insertColumn.ts","../src/lib/transforms/insertColumnGroup.ts","../src/lib/transforms/moveMiddleColumn.ts","../src/lib/transforms/resizeColumn.ts","../src/lib/transforms/setColumns.ts","../src/lib/utils/columnsToWidths.ts","../src/lib/transforms/toggleColumnGroup.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import { createSlatePlugin, KEYS } from 'platejs';\n\nimport { withColumn } from './withColumn';\n\nexport const BaseColumnItemPlugin = createSlatePlugin({\n  key: KEYS.column,\n  node: { isContainer: true, isElement: true, isStrictSiblings: true },\n}).overrideEditor(withColumn);\n\nexport const BaseColumnPlugin = createSlatePlugin({\n  key: KEYS.columnGroup,\n  node: { isContainer: true, isElement: true },\n  plugins: [BaseColumnItemPlugin],\n});\n","import {\n  type OverrideEditor,\n  type TColumnElement,\n  type TColumnGroupElement,\n  ElementApi,\n  KEYS,\n  PathApi,\n} from 'platejs';\n\nexport const withColumn: OverrideEditor = ({\n  editor,\n  tf: { apply, normalizeNode, selectAll },\n  type,\n}) => ({\n  transforms: {\n    normalizeNode([n, path]) {\n      // If it's a column group, ensure it has valid children\n      if (\n        ElementApi.isElement(n) &&\n        n.type === editor.getType(KEYS.columnGroup)\n      ) {\n        const node = n as TColumnGroupElement;\n\n        // If the first child is a p, unwrap it\n        const firstChild = node.children[0];\n        if (\n          node.children.length === 1 &&\n          firstChild.type === editor.getType(KEYS.p)\n        ) {\n          editor.tf.unwrapNodes({ at: PathApi.child(path, 0) });\n        }\n\n        // If no columns found, unwrap the column group\n        if (\n          !node.children.some(\n            (child) => ElementApi.isElement(child) && child.type === type\n          )\n        ) {\n          editor.tf.removeNodes({ at: path });\n\n          return;\n        }\n        // If only one column remains, unwrap the group (optional logic)\n        if (node.children.length < 2) {\n          editor.tf.withoutNormalizing(() => {\n            editor.tf.unwrapNodes({ at: path });\n            editor.tf.unwrapNodes({ at: path });\n          });\n\n          return;\n        }\n\n        // PERF: only run when the number of columns changes\n        editor.tf.withoutNormalizing(() => {\n          // Add new width normalization logic\n          const totalColumns = node.children.length;\n          let widths = node.children.map((col) => {\n            const parsed = Number.parseFloat(col.width);\n\n            return Number.isNaN(parsed) ? 0 : parsed;\n          });\n\n          const sum = widths.reduce((acc, w) => acc + w, 0);\n\n          if (sum !== 100) {\n            const diff = 100 - sum;\n            const adjustment = diff / totalColumns;\n\n            widths = widths.map((w) => w + adjustment);\n\n            // Update the columns with the new widths\n            widths.forEach((w, i) => {\n              const columnPath = path.concat([i]);\n              editor.tf.setNodes<TColumnElement>(\n                { width: `${w}%` },\n                { at: columnPath }\n              );\n            });\n          }\n        });\n      }\n      // If it's a column, ensure it has at least one block (optional)\n      if (ElementApi.isElement(n) && n.type === type) {\n        const node = n as TColumnElement;\n\n        // node.children.forEach((child, index) => {\n        //   if (TextApi.isText(child)) {\n        //     editor.tf.wrapNodes(\n        //       { children: [], type: editor.getType(KEYS.p) },\n        //       {\n        //         at: PathApi.child(path, index),\n        //       }\n        //     );\n        //   }\n        // });\n\n        if (node.children.length === 0) {\n          editor.tf.removeNodes({ at: path });\n\n          return;\n        }\n      }\n\n      return normalizeNode([n, path]);\n    },\n    selectAll: () => {\n      const apply = () => {\n        const at = editor.selection;\n\n        if (!at) return;\n\n        const column = editor.api.above({\n          match: { type: type },\n        });\n\n        if (!column) return;\n\n        let targetPath = column[1];\n\n        if (\n          editor.api.isStart(editor.api.start(at), targetPath) &&\n          editor.api.isEnd(editor.api.end(at), targetPath)\n        ) {\n          targetPath = PathApi.parent(targetPath);\n        }\n\n        if (targetPath.length === 0) return;\n\n        editor.tf.select(targetPath);\n\n        return true;\n      };\n\n      if (apply()) return true;\n\n      return selectAll();\n    },\n  },\n});\n","import type { InsertNodesOptions, SlateEditor, TColumnElement } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const insertColumn = (\n  editor: SlateEditor,\n  { width = '33%', ...options }: { width?: string } & InsertNodesOptions = {}\n) => {\n  editor.tf.insertNodes<TColumnElement>(\n    {\n      children: [editor.api.create.block()],\n      type: editor.getType(KEYS.column) as any,\n      width,\n    },\n    options as any\n  );\n};\n","import type {\n  InsertNodesOptions,\n  SlateEditor,\n  TColumnGroupElement,\n} from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const insertColumnGroup = (\n  editor: SlateEditor,\n  {\n    columns = 2,\n    select: selectProp,\n    ...options\n  }: InsertNodesOptions & {\n    columns?: number;\n  } = {}\n) => {\n  const width = 100 / columns;\n\n  editor.tf.withoutNormalizing(() => {\n    editor.tf.insertNodes<TColumnGroupElement>(\n      {\n        children: new Array(columns).fill(null).map(() => ({\n          children: [editor.api.create.block()],\n          type: editor.getType(KEYS.column) as any,\n          width: `${width}%`,\n        })),\n        type: editor.getType(KEYS.columnGroup) as any,\n      },\n      options\n    );\n\n    if (selectProp) {\n      const entry = editor.api.node({\n        at: options.at,\n        match: { type: editor.getType(KEYS.column) },\n      });\n\n      if (!entry) return;\n\n      editor.tf.select(entry[1].concat([0]));\n    }\n  });\n};\n","import {\n  type NodeEntry,\n  type SlateEditor,\n  type TColumnElement,\n  type TNode,\n  NodeApi,\n} from 'platejs';\n\n/**\n * Move the middle column to the left if direction is 'left', or to the right if\n * 'right'. If the middle node is empty, return false and remove it.\n */\nexport const moveMiddleColumn = <N extends TNode>(\n  editor: SlateEditor,\n  [node, path]: NodeEntry<N>,\n  options?: {\n    direction: 'left' | 'right';\n  }\n) => {\n  const direction = options?.direction || 'left';\n\n  if (direction === 'left') {\n    const DESCENDANT_PATH = [1];\n\n    const middleChildNode = NodeApi.get<TColumnElement>(node, DESCENDANT_PATH);\n\n    if (!middleChildNode) return false;\n\n    // Check emptiness using Api.string\n    const isEmpty = NodeApi.string(middleChildNode) === '';\n\n    const middleChildPathRef = editor.api.pathRef(path.concat(DESCENDANT_PATH));\n\n    if (isEmpty) {\n      editor.tf.removeNodes({ at: middleChildPathRef.current! });\n\n      return false;\n    }\n\n    const firstNode = NodeApi.descendant<TColumnElement>(node, [0]);\n\n    if (!firstNode) return false;\n\n    const firstLast = path.concat([0, firstNode.children.length]);\n\n    editor.tf.moveNodes({ at: middleChildPathRef.current!, to: firstLast });\n    editor.tf.unwrapNodes({ at: middleChildPathRef.current! });\n    middleChildPathRef.unref();\n  }\n};\n","import type { TColumnGroupElement } from 'platejs';\n\nexport function resizeColumn(\n  columnGroup: TColumnGroupElement,\n  columnId: string,\n  newWidthPercent: number\n): TColumnGroupElement {\n  // Convert widths to numbers for easier math\n  const widths = columnGroup.children.map((col) =>\n    col.width ? Number.parseFloat(col.width) : 0\n  );\n\n  const totalBefore = widths.reduce((sum, w) => sum + w, 0);\n\n  // fallback if columns do not sum to 100: normalize them\n  if (totalBefore === 0) {\n    // distribute evenly if no widths\n    const evenWidth = 100 / columnGroup.children.length;\n    columnGroup.children.forEach((col) => {\n      col.width = `${evenWidth}%`;\n    });\n\n    return columnGroup;\n  }\n\n  const index = columnGroup.children.findIndex((col) => col.id === columnId);\n\n  if (index === -1) return columnGroup; // Column not found\n\n  // Set the new width for the target column\n  widths[index] = newWidthPercent;\n\n  // Calculate the difference from total (ideally 100)\n  let totalAfter = widths.reduce((sum, w) => sum + w, 0);\n\n  // If total is off from 100%, adjust siblings\n  // For simplicity, assume totalAfter < 100%. Add leftover to the next column.\n  // You can make this logic more balanced if needed.\n  const diff = 100 - totalAfter;\n\n  if (diff !== 0) {\n    // Find a sibling to adjust. For a simple strategy, pick the next column.\n    const siblingIndex = (index + 1) % widths.length;\n    widths[siblingIndex] = Math.max(widths[siblingIndex] + diff, 0);\n  }\n\n  // Normalize again if rounding introduced a small error\n  totalAfter = widths.reduce((sum, w) => sum + w, 0);\n\n  if (Math.round(totalAfter) !== 100) {\n    // If you want a perfectly balanced approach:\n    // Scale all widths so they sum exactly to 100\n    const scale = 100 / totalAfter;\n\n    for (let i = 0; i < widths.length; i++) {\n      widths[i] = Number.parseFloat((widths[i] * scale).toFixed(2));\n    }\n  }\n\n  // Update the column widths\n  columnGroup.children.forEach((col, i) => {\n    col.width = `${widths[i]}%`;\n  });\n\n  return columnGroup;\n}\n","import {\n  type At,\n  type SlateEditor,\n  type TColumnElement,\n  type TColumnGroupElement,\n  NodeApi,\n} from 'platejs';\nimport { KEYS } from 'platejs';\n\nimport { columnsToWidths } from '../utils/columnsToWidths';\n\nexport const setColumns = (\n  editor: SlateEditor,\n  {\n    at,\n    columns,\n    widths,\n  }: {\n    /** Column group path */\n    at?: At;\n    columns?: number;\n    widths?: string[];\n  }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    if (!at) return;\n\n    widths = widths ?? columnsToWidths({ columns });\n\n    // If widths is empty, do nothing.\n    if (widths.length === 0) {\n      return;\n    }\n\n    const columnGroup = editor.api.node<TColumnGroupElement>(at);\n\n    if (!columnGroup) return;\n\n    const [{ children }, path] = columnGroup;\n\n    const currentCount = children.length;\n    const targetCount = widths.length;\n\n    if (currentCount === targetCount) {\n      // Same number of columns: just set widths directly\n      widths.forEach((width, i) => {\n        editor.tf.setNodes<TColumnElement>({ width }, { at: path.concat([i]) });\n      });\n\n      return;\n    }\n    if (targetCount > currentCount) {\n      // Need more columns than we have: insert extra columns at the end\n      const columnsToAdd = targetCount - currentCount;\n      const insertPath = path.concat([currentCount]);\n\n      // Insert the extra columns\n      const newColumns = new Array(columnsToAdd).fill(null).map((_, i) => ({\n        children: [editor.api.create.block()],\n        type: editor.getType(KEYS.column),\n        width: widths![currentCount + i] || `${100 / targetCount}%`,\n      }));\n\n      editor.tf.insertNodes(newColumns, { at: insertPath });\n\n      // Just ensure final widths match exactly\n      widths.forEach((width, i) => {\n        editor.tf.setNodes<TColumnElement>({ width }, { at: path.concat([i]) });\n      });\n\n      return;\n    }\n    if (targetCount < currentCount) {\n      // Need fewer columns than we have: merge extra columns into the last kept column\n      const keepColumnIndex = targetCount - 1;\n      const keepColumnPath = path.concat([keepColumnIndex]);\n      const keepColumnNode = NodeApi.get<TColumnElement>(\n        editor,\n        keepColumnPath\n      );\n\n      if (!keepColumnNode) return;\n\n      const to = keepColumnPath.concat([keepColumnNode.children.length]);\n\n      // Move content from columns beyond keepIndex into keepIndex column\n      for (let i = currentCount - 1; i > keepColumnIndex; i--) {\n        const columnPath = path.concat([i]);\n        const columnEntry = editor.api.node<TColumnElement>(columnPath);\n\n        if (!columnEntry) continue;\n\n        editor.tf.moveNodes({\n          at: columnEntry[1],\n          children: true,\n          to,\n        });\n      }\n\n      // Remove the now-empty extra columns\n      // Removing from the end to avoid path shifts\n      for (let i = currentCount - 1; i > keepColumnIndex; i--) {\n        editor.tf.removeNodes({ at: path.concat([i]) });\n      }\n\n      // Set the final widths\n      widths.forEach((width, i) => {\n        editor.tf.setNodes<TColumnElement>({ width }, { at: path.concat([i]) });\n      });\n    }\n  });\n};\n","export const columnsToWidths = ({ columns = 2 }: { columns?: number } = {}) =>\n  new Array(columns).fill(null).map(() => `${100 / columns}%`);\n","import type { ReplaceNodesOptions, SlateEditor, TElement } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { columnsToWidths } from '../utils/columnsToWidths';\nimport { setColumns } from './setColumns';\n\nexport const toggleColumnGroup = (\n  editor: SlateEditor,\n  {\n    at,\n    columns = 2,\n    widths,\n  }: Partial<ReplaceNodesOptions> & {\n    columns?: number;\n    widths?: string[];\n  } = {}\n) => {\n  const entry = editor.api.block({ at });\n  const columnGroupEntry = editor.api.block({\n    above: true,\n    at,\n    match: { type: editor.getType(KEYS.columnGroup) },\n  });\n\n  if (!entry) return;\n\n  const [node, path] = entry;\n\n  // Check if the node is already a column_group\n  if (columnGroupEntry) {\n    // Node is already a column_group, just update the columns using setColumns\n    setColumns(editor, { at: columnGroupEntry[1], columns, widths });\n  } else {\n    // Node is not a column_group, wrap it in a column_group\n    const columnWidths = widths || columnsToWidths({ columns });\n\n    const nodes = {\n      children: new Array(columns).fill(null).map((_, index) => ({\n        children: [index === 0 ? node : editor.api.create.block()],\n        type: editor.getType(KEYS.column) as any,\n        width: columnWidths[index],\n      })),\n      type: editor.getType(KEYS.columnGroup) as any,\n    } as TElement;\n\n    editor.tf.replaceNodes(nodes, {\n      at: path,\n    });\n\n    editor.tf.select(editor.api.start(path.concat([0]))!);\n  }\n};\n"],"mappings":"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","names":["import_platejs","apply","import_platejs","import_platejs","import_platejs","import_platejs","import_platejs"]}