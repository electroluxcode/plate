{"version":3,"sources":["../../src/react/ColumnPlugin.tsx","../../src/lib/BaseColumnPlugin.ts","../../src/lib/withColumn.ts","../../src/react/hooks/useDebouncePopoverOpen.ts"],"sourcesContent":["import { toPlatePlugin } from 'platejs/react';\n\nimport { BaseColumnItemPlugin, BaseColumnPlugin } from '../lib';\n\nexport const ColumnItemPlugin = toPlatePlugin(BaseColumnItemPlugin);\n\n/** Enables support for columns with React-specific features. */\nexport const ColumnPlugin = toPlatePlugin(BaseColumnPlugin, {\n  plugins: [ColumnItemPlugin],\n});\n","import { createSlatePlugin, KEYS } from 'platejs';\n\nimport { withColumn } from './withColumn';\n\nexport const BaseColumnItemPlugin = createSlatePlugin({\n  key: KEYS.column,\n  node: { isContainer: true, isElement: true, isStrictSiblings: true },\n}).overrideEditor(withColumn);\n\nexport const BaseColumnPlugin = createSlatePlugin({\n  key: KEYS.columnGroup,\n  node: { isContainer: true, isElement: true },\n  plugins: [BaseColumnItemPlugin],\n});\n","import {\n  type OverrideEditor,\n  type TColumnElement,\n  type TColumnGroupElement,\n  ElementApi,\n  KEYS,\n  PathApi,\n} from 'platejs';\n\nexport const withColumn: OverrideEditor = ({\n  editor,\n  tf: { apply, normalizeNode, selectAll },\n  type,\n}) => ({\n  transforms: {\n    normalizeNode([n, path]) {\n      // If it's a column group, ensure it has valid children\n      if (\n        ElementApi.isElement(n) &&\n        n.type === editor.getType(KEYS.columnGroup)\n      ) {\n        const node = n as TColumnGroupElement;\n\n        // If the first child is a p, unwrap it\n        const firstChild = node.children[0];\n        if (\n          node.children.length === 1 &&\n          firstChild.type === editor.getType(KEYS.p)\n        ) {\n          editor.tf.unwrapNodes({ at: PathApi.child(path, 0) });\n        }\n\n        // If no columns found, unwrap the column group\n        if (\n          !node.children.some(\n            (child) => ElementApi.isElement(child) && child.type === type\n          )\n        ) {\n          editor.tf.removeNodes({ at: path });\n\n          return;\n        }\n        // If only one column remains, unwrap the group (optional logic)\n        if (node.children.length < 2) {\n          editor.tf.withoutNormalizing(() => {\n            editor.tf.unwrapNodes({ at: path });\n            editor.tf.unwrapNodes({ at: path });\n          });\n\n          return;\n        }\n\n        // PERF: only run when the number of columns changes\n        editor.tf.withoutNormalizing(() => {\n          // Add new width normalization logic\n          const totalColumns = node.children.length;\n          let widths = node.children.map((col) => {\n            const parsed = Number.parseFloat(col.width);\n\n            return Number.isNaN(parsed) ? 0 : parsed;\n          });\n\n          const sum = widths.reduce((acc, w) => acc + w, 0);\n\n          if (sum !== 100) {\n            const diff = 100 - sum;\n            const adjustment = diff / totalColumns;\n\n            widths = widths.map((w) => w + adjustment);\n\n            // Update the columns with the new widths\n            widths.forEach((w, i) => {\n              const columnPath = path.concat([i]);\n              editor.tf.setNodes<TColumnElement>(\n                { width: `${w}%` },\n                { at: columnPath }\n              );\n            });\n          }\n        });\n      }\n      // If it's a column, ensure it has at least one block (optional)\n      if (ElementApi.isElement(n) && n.type === type) {\n        const node = n as TColumnElement;\n\n        // node.children.forEach((child, index) => {\n        //   if (TextApi.isText(child)) {\n        //     editor.tf.wrapNodes(\n        //       { children: [], type: editor.getType(KEYS.p) },\n        //       {\n        //         at: PathApi.child(path, index),\n        //       }\n        //     );\n        //   }\n        // });\n\n        if (node.children.length === 0) {\n          editor.tf.removeNodes({ at: path });\n\n          return;\n        }\n      }\n\n      return normalizeNode([n, path]);\n    },\n    selectAll: () => {\n      const apply = () => {\n        const at = editor.selection;\n\n        if (!at) return;\n\n        const column = editor.api.above({\n          match: { type: type },\n        });\n\n        if (!column) return;\n\n        let targetPath = column[1];\n\n        if (\n          editor.api.isStart(editor.api.start(at), targetPath) &&\n          editor.api.isEnd(editor.api.end(at), targetPath)\n        ) {\n          targetPath = PathApi.parent(targetPath);\n        }\n\n        if (targetPath.length === 0) return;\n\n        editor.tf.select(targetPath);\n\n        return true;\n      };\n\n      if (apply()) return true;\n\n      return selectAll();\n    },\n  },\n});\n","import { useEditorSelector, useReadOnly, useSelected } from 'platejs/react';\n\nexport const useDebouncePopoverOpen = () => {\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n\n  const selectionCollapsed = useEditorSelector(\n    (editor) => editor.api.isCollapsed(),\n    []\n  );\n\n  // TODO:should add debounce\n  return !readOnly && selected && selectionCollapsed;\n};\n"],"mappings":"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","names":["KEYS","apply","KEYS"]}