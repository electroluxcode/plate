{"version":3,"sources":["../src/DndPlugin.tsx","../src/components/Scroller/DndScroller.tsx","../src/components/Scroller/Scroller.tsx","../src/components/Scroller/ScrollArea.tsx","../src/components/useDraggable.ts","../src/components/useDropLine.ts","../src/hooks/useDndNode.ts","../src/hooks/useDragNode.ts","../src/hooks/useDropNode.ts","../src/transforms/onDropNode.ts","../src/utils/getHoverDirection.ts","../src/utils/getNewDirection.ts","../src/transforms/onHoverNode.ts","../src/queries/getBlocksWithId.ts","../src/transforms/focusBlockStartById.ts","../src/transforms/removeBlocksAndFocus.ts","../src/transforms/selectBlockById.ts","../src/transforms/selectBlocksBySelectionOrId.ts"],"sourcesContent":["import React, { useCallback, useEffect } from 'react';\n\nimport type { Path, PluginConfig } from 'platejs';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport { KEYS } from 'platejs';\nimport { type PlateEditor, createTPlatePlugin } from 'platejs/react';\n\nimport type {\n  DragItemNode,\n  DropLineDirection,\n  FileDragItemNode,\n} from './types';\n\nimport { type ScrollerProps, DndScroller } from './components/Scroller';\n\nexport const DRAG_ITEM_BLOCK = 'block';\n\nexport type DndConfig = PluginConfig<\n  'dnd',\n  {\n    _isOver?: boolean;\n    draggingId?: string[] | string | null;\n    dropTarget?: {\n      id: string | null;\n      line: DropLineDirection;\n    };\n    enableScroller?: boolean;\n    isDragging?: boolean;\n    multiplePreviewRef?: React.RefObject<HTMLDivElement | null> | null;\n    scrollerProps?: Partial<ScrollerProps>;\n    onDropFiles?: (props: {\n      id: string;\n      dragItem: FileDragItemNode;\n      editor: PlateEditor;\n      monitor: DropTargetMonitor<DragItemNode, unknown>;\n      nodeRef: any;\n      target?: Path;\n    }) => void;\n  }\n>;\n\nexport const DndPlugin = createTPlatePlugin<DndConfig>({\n  key: KEYS.dnd,\n  editOnly: true,\n  handlers: {\n    onDragEnd: ({ editor, plugin }) => {\n      editor.setOption(plugin, 'isDragging', false);\n      editor.setOption(plugin, 'dropTarget', { id: null, line: '' });\n    },\n    onDragEnter: ({ editor, plugin }) => {\n      editor.setOption(plugin, '_isOver', true);\n    },\n    onDragStart: ({ editor, event, plugin }) => {\n      const target = event.target as HTMLElement;\n\n      const dataTransfer = (event as React.DragEvent).dataTransfer!;\n      dataTransfer.effectAllowed = 'move';\n      dataTransfer.dropEffect = 'move';\n\n      const id = target.dataset.blockId;\n\n      if (!id) return;\n\n      editor.setOption(plugin, 'draggingId', id);\n      editor.setOption(plugin, 'isDragging', true);\n      editor.setOption(plugin, '_isOver', true);\n    },\n    onDrop: ({ getOptions, setOption }) => {\n      return getOptions().isDragging;\n    },\n    onFocus: ({ editor, plugin }) => {\n      editor.setOption(plugin, 'isDragging', false);\n      editor.setOption(plugin, 'dropTarget', { id: null, line: '' });\n      editor.setOption(plugin, '_isOver', false);\n      editor\n        .getOption(plugin, 'multiplePreviewRef')\n        ?.current?.replaceChildren();\n    },\n  },\n  options: {\n    _isOver: false,\n    draggingId: null,\n    dropTarget: { id: null, line: '' },\n    isDragging: false,\n    multiplePreviewRef: null,\n  },\n  useHooks: ({ editor, setOption }) => {\n    const handleDragLeave = useCallback(\n      (e: DragEvent) => {\n        // This event fires for every element that receives a drag leave event. As soon as it is fired on the\n        // editable dom node, or above, we will unset the drop target, and therefore hide the drop line.\n        // In other words, whenever the drag is not happening inside the editor anymore, we will hide the\n        // drop line which makes sense, since a potential drop would not insert anything into the editor.\n        // This will also apply, if the user move the drag operation outside the document.\n        if (e.target instanceof Node) {\n          const editorDOMNode = editor.api.toDOMNode(editor);\n\n          if (\n            editorDOMNode &&\n            !(e.target === editorDOMNode || editorDOMNode.contains(e.target))\n          ) {\n            setOption('dropTarget', undefined);\n          }\n        }\n      },\n      [editor, setOption]\n    );\n\n    // We listen for the drop event on the document and not only inside the editor, because we want to\n    // remove the dropTarget, and therefore hide the drop line, also when the drop happened outside of\n    // the editor. Needed, if the drag did not start inside the editor, but for example by dragging a\n    // file from the filesystem\n    const handleDrop = useCallback(() => {\n      setOption('_isOver', false);\n      setOption('dropTarget', undefined);\n    }, [setOption]);\n\n    useEffect(() => {\n      document.addEventListener('dragleave', handleDragLeave, true);\n      document.addEventListener('drop', handleDrop, true);\n\n      return () => {\n        document.removeEventListener('dragleave', handleDragLeave, true);\n        document.removeEventListener('drop', handleDrop, true);\n      };\n    }, [handleDragLeave, handleDrop]);\n  },\n}).extend(({ getOptions }) => ({\n  render: {\n    afterEditable: getOptions().enableScroller\n      ? () => <DndScroller {...getOptions()?.scrollerProps} />\n      : undefined,\n  },\n}));\n","import React from 'react';\n\nimport { usePluginOption } from 'platejs/react';\n\nimport { DndPlugin } from '../../DndPlugin';\nimport { type ScrollerProps, Scroller } from './Scroller';\n\nexport function DndScroller(props: Partial<ScrollerProps>) {\n  const isDragging = usePluginOption(DndPlugin, 'isDragging');\n\n  const [show, setShow] = React.useState(false);\n\n  React.useEffect(() => {\n    if (isDragging) {\n      const timeout = setTimeout(() => {\n        setShow(true);\n      }, 100);\n\n      return () => clearTimeout(timeout);\n    }\n\n    setShow(false);\n  }, [isDragging, show]);\n\n  return <Scroller enabled={isDragging && show} {...props} />;\n}\n","import React from 'react';\n\nimport { type ScrollAreaProps, ScrollArea } from './ScrollArea';\n\nexport type ScrollerProps = Omit<ScrollAreaProps, 'placement'>;\n\n/**\n * Set up an edge scroller at the top of the page for scrolling up. One at the\n * bottom for scrolling down.\n */\nexport function Scroller(props: ScrollerProps) {\n  return (\n    <>\n      <ScrollArea placement=\"top\" {...props} />\n      <ScrollArea placement=\"bottom\" {...props} />\n    </>\n  );\n}\n","import React from 'react';\n\nimport throttle from 'lodash/throttle.js';\nimport raf from 'raf';\n\nconst getCoords = (e: any) => {\n  if (e.type === 'touchmove') {\n    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };\n  }\n\n  return { x: e.clientX, y: e.clientY };\n};\n\nexport interface ScrollAreaProps {\n  placement: 'bottom' | 'top';\n  containerRef?: React.RefObject<any>;\n  enabled?: boolean;\n  height?: number;\n  minStrength?: number;\n  scrollAreaProps?: React.HTMLAttributes<HTMLDivElement>;\n  strengthMultiplier?: number;\n  zIndex?: number;\n}\n\nexport function ScrollArea({\n  containerRef,\n  enabled = true,\n  height = 100,\n  minStrength = 0.15,\n  placement,\n  scrollAreaProps,\n  strengthMultiplier = 25,\n  zIndex = 10_000,\n}: ScrollAreaProps) {\n  const ref = React.useRef<HTMLDivElement>(undefined);\n\n  const scaleYRef = React.useRef(0);\n  const frameRef = React.useRef<number | null>(null);\n\n  const direction = placement === 'top' ? -1 : 1;\n\n  // Drag a fixed, invisible box of custom height at the top, and bottom\n  // of the window. Make sure to show it only when dragging something.\n  const style: React.CSSProperties = {\n    height,\n    opacity: 0,\n    position: 'fixed',\n    width: '100%',\n    zIndex,\n    ...scrollAreaProps?.style,\n  };\n\n  if (placement === 'top') {\n    style.top = 0;\n  } else if (placement === 'bottom') {\n    style.bottom = 0;\n  }\n\n  const stopScrolling = () => {\n    scaleYRef.current = 0;\n\n    if (frameRef.current) {\n      raf.cancel(frameRef.current);\n      frameRef.current = null;\n    }\n  };\n\n  const startScrolling = () => {\n    const tick = () => {\n      const scaleY = scaleYRef.current;\n\n      // stop scrolling if there's nothing to do\n      if (strengthMultiplier === 0 || scaleY === 0) {\n        stopScrolling();\n\n        return;\n      }\n\n      const container = containerRef?.current ?? window;\n      container.scrollBy(0, scaleY * strengthMultiplier * direction);\n\n      frameRef.current = raf(tick);\n\n      // there's a bug in safari where it seems like we can't get\n      // mousemove events from a container that also emits a scroll\n      // event that same frame. So we should double the strengthMultiplier and only adjust\n      // the scroll position at 30fps\n    };\n\n    tick();\n  };\n\n  // Update scaleY every 100ms or so\n  // and start scrolling if necessary\n  const updateScrolling = throttle(\n    (e) => {\n      const container = ref.current;\n\n      if (!container) return;\n\n      const { height: h, top: y } = container.getBoundingClientRect();\n      const coords = getCoords(e);\n\n      const strength = Math.max(Math.max(coords.y - y, 0) / h, minStrength);\n\n      // calculate strength\n      scaleYRef.current = direction === -1 ? 1 - strength : strength;\n\n      // start scrolling if we need to\n      if (!frameRef.current && scaleYRef.current) {\n        startScrolling();\n      }\n    },\n    100,\n    { trailing: false }\n  );\n\n  const handleEvent = (e: any) => {\n    updateScrolling(e);\n  };\n\n  React.useEffect(() => {\n    if (!enabled) {\n      stopScrolling();\n    }\n  }, [enabled]);\n\n  if (!enabled) return null;\n\n  // Hide the element if not enabled, so it doesn't interfere with clicking things under it.\n  return (\n    <div\n      ref={ref as any}\n      // touchmove events don't seem to work across siblings, so we unfortunately\n      style={style}\n      onDragEnd={stopScrolling}\n      onDragLeave={stopScrolling}\n      onDragOver={handleEvent}\n      // would have to attach the listeners to the body\n      onTouchMove={handleEvent}\n      {...scrollAreaProps}\n    />\n  );\n}\n","import React from 'react';\n\nimport { useEditorRef } from 'platejs/react';\n\nimport { type UseDndNodeOptions, DRAG_ITEM_BLOCK, useDndNode } from '..';\n\nexport type DraggableState = {\n  /**\n   * True when the element is ready to be dragged (e.g., on mouse down but\n   * before drag starts)\n   */\n  isAboutToDrag: boolean;\n  isDragging: boolean;\n  /** The ref of the draggable element */\n  nodeRef: React.RefObject<HTMLDivElement | null>;\n  /** The ref of the multiple preview element */\n  previewRef: React.RefObject<HTMLDivElement | null>;\n  /** The ref of the draggable handle */\n  handleRef: (\n    elementOrNode:\n      | Element\n      | React.ReactElement<any>\n      | React.RefObject<any>\n      | null\n  ) => void;\n};\n\nexport const useDraggable = (props: UseDndNodeOptions): DraggableState => {\n  const {\n    orientation = 'vertical',\n    type = DRAG_ITEM_BLOCK,\n    onDropHandler,\n  } = props;\n\n  const editor = useEditorRef();\n\n  const nodeRef = React.useRef<HTMLDivElement>(null);\n\n  const multiplePreviewRef = React.useRef<HTMLDivElement>(null);\n\n  if (!editor.plugins.dnd) return {} as any;\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const { dragRef, isAboutToDrag, isDragging } = useDndNode({\n    multiplePreviewRef,\n    nodeRef,\n    orientation,\n    type,\n    onDropHandler,\n    ...props,\n  });\n\n  return {\n    isAboutToDrag,\n    isDragging,\n    nodeRef,\n    previewRef: multiplePreviewRef,\n    handleRef: dragRef,\n  };\n};\n","import { useElement, usePluginOptions } from 'platejs/react';\n\nimport type { DropLineDirection } from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\n\nexport const useDropLine = ({\n  id: idProp,\n  orientation = 'vertical',\n}: {\n  /** The id of the element to show the dropline for. */\n  id?: string;\n  orientation?: 'horizontal' | 'vertical';\n} = {}): {\n  dropLine?: DropLineDirection;\n} => {\n  const element = useElement();\n  const id = idProp || (element.id as string);\n\n  const dropLine =\n    usePluginOptions(DndPlugin, ({ dropTarget }) => {\n      if (!dropTarget) return null;\n      if (dropTarget.id !== id) return null;\n\n      return dropTarget.line;\n    }) ?? '';\n\n  if (orientation) {\n    const isHorizontalDropLine = dropLine === 'left' || dropLine === 'right';\n    const isVerticalDropLine = dropLine === 'top' || dropLine === 'bottom';\n\n    // If the orientation is vertical but we got a horizontal dropline, clear it.\n    if (\n      (orientation === 'vertical' && isHorizontalDropLine) ||\n      (orientation === 'horizontal' && isVerticalDropLine)\n    ) {\n      return {\n        dropLine: '',\n      };\n    }\n  }\n\n  return {\n    dropLine,\n  };\n};\n","import { getEmptyImage, NativeTypes } from 'react-dnd-html5-backend';\n\nimport type { ConnectDragSource, DropTargetMonitor } from 'react-dnd';\n\nimport { type PlateEditor, useEditorRef } from 'platejs/react';\n\nimport type { DragItemNode } from '../types';\n\nimport { DRAG_ITEM_BLOCK } from '../DndPlugin';\nimport { type UseDragNodeOptions, useDragNode } from './useDragNode';\nimport { type UseDropNodeOptions, useDropNode } from './useDropNode';\n\nexport type UseDndNodeOptions = Pick<UseDropNodeOptions, 'element'> &\n  Partial<\n    Pick<UseDropNodeOptions, 'canDropNode' | 'multiplePreviewRef' | 'nodeRef'>\n  > &\n  Partial<Pick<UseDragNodeOptions, 'type'>> & {\n    /** Options passed to the drag hook. */\n    drag?: Partial<Omit<UseDragNodeOptions, 'type'>>;\n    /** Options passed to the drop hook, excluding element, nodeRef. */\n    drop?: Partial<\n      Omit<UseDropNodeOptions, 'canDropNode' | 'element' | 'nodeRef'>\n    >;\n    /** Orientation of the drag and drop interaction. */\n    orientation?: 'horizontal' | 'vertical';\n    preview?: {\n      /** Whether to disable the preview. */\n      disable?: boolean;\n      /** The reference to the preview element. */\n      ref?: any;\n    };\n    onDropHandler?: (\n      editor: PlateEditor,\n      props: {\n        id: string;\n        dragItem: DragItemNode;\n        monitor: DropTargetMonitor<DragItemNode, unknown>;\n        nodeRef: any;\n      }\n    ) => boolean | void;\n  };\n\n/**\n * {@link useDragNode} and {@link useDropNode} hooks to drag and drop a node from\n * the editor. A default preview is used to show the node being dragged, which\n * can be customized or removed. Returns the drag ref and drop line direction.\n */\nexport const useDndNode = ({\n  canDropNode,\n  drag: dragOptions,\n  drop: dropOptions,\n  element,\n  multiplePreviewRef,\n  nodeRef,\n  orientation = 'vertical',\n  preview: previewOptions = {},\n  type = DRAG_ITEM_BLOCK,\n  onDropHandler,\n}: UseDndNodeOptions): {\n  dragRef: ConnectDragSource;\n  isAboutToDrag: boolean;\n  isDragging: boolean;\n  isOver: boolean;\n} => {\n  const editor = useEditorRef();\n\n  const [{ isAboutToDrag, isDragging }, dragRef, preview] = useDragNode(\n    editor,\n    {\n      element,\n      type,\n      ...dragOptions,\n    }\n  );\n\n  const [{ isOver }, drop] = useDropNode(editor, {\n    accept: [type, NativeTypes.FILE],\n    canDropNode,\n    element,\n    multiplePreviewRef,\n    nodeRef,\n    orientation,\n    onDropHandler,\n    ...dropOptions,\n  });\n\n  // Always use nodeRef for the drop target (actual DOM element)\n  drop(nodeRef);\n\n  // Handle preview based on options and whether we're dragging multiple nodes\n  if (previewOptions.disable) {\n    preview(getEmptyImage(), { captureDraggingState: true });\n  } else if (previewOptions.ref) {\n    preview(previewOptions.ref);\n  } else {\n    preview(multiplePreviewRef);\n  }\n\n  return {\n    dragRef,\n    isAboutToDrag,\n    isDragging,\n    isOver,\n  };\n};\n","import React from 'react';\nimport {\n  type ConnectDragPreview,\n  type ConnectDragSource,\n  type DragSourceHookSpec,\n  useDrag,\n} from 'react-dnd';\n\nimport type { TElement } from 'platejs';\nimport type { PlateEditor } from 'platejs/react';\n\nimport type { DragItemNode } from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\n\nexport interface UseDragNodeOptions\n  extends DragSourceHookSpec<DragItemNode, unknown, { isDragging: boolean }> {\n  element: TElement;\n}\n\n/**\n * `useDrag` hook to drag a node from the editor. `item` with `id` is required.\n *\n * On drag start:\n *\n * - Set `isDragging` to true\n * - Add `dragging` class to `body`\n *\n * On drag end:\n *\n * - Set `isDragging` to false\n * - Remove `dragging` class to `body`\n *\n * Collect:\n *\n * - IsDragging: true if mouse is dragging the block\n */\nexport const useDragNode = (\n  editor: PlateEditor,\n  { element: staleElement, item, ...options }: UseDragNodeOptions\n): [\n  { isAboutToDrag: boolean; isDragging: boolean },\n  ConnectDragSource,\n  ConnectDragPreview,\n] => {\n  const elementId = staleElement.id as string;\n  const [isAboutToDrag, setIsAboutToDrag] = React.useState(false);\n\n  const [collected, dragRef, preview] = useDrag<\n    DragItemNode,\n    unknown,\n    { isDragging: boolean }\n  >(\n    () => ({\n      canDrag: () => {\n        setIsAboutToDrag(true);\n        return true;\n      },\n      collect: (monitor) => ({\n        isDragging: monitor.isDragging(),\n      }),\n      end: () => {\n        editor.setOption(DndPlugin, 'isDragging', false);\n        document.body.classList.remove('dragging');\n        setIsAboutToDrag(false);\n      },\n      item(monitor) {\n        editor.setOption(DndPlugin, 'isDragging', true);\n        editor.setOption(DndPlugin, '_isOver', true);\n        document.body.classList.add('dragging');\n\n        const _item = typeof item === 'function' ? item(monitor) : item;\n        const [element] = editor.api.node<TElement>({ id: elementId, at: [] })!;\n\n        // Check if multiple nodes are selected\n        const currentDraggingId = editor.getOption(DndPlugin, 'draggingId');\n\n        let id: string[] | string;\n\n        if (\n          Array.isArray(currentDraggingId) &&\n          currentDraggingId.length > 1 &&\n          currentDraggingId.includes(elementId)\n        ) {\n          // Multiple selection including current element\n          id = Array.from(currentDraggingId);\n        } else {\n          // Single element drag\n          id = elementId;\n          editor.setOption(DndPlugin, 'draggingId', elementId);\n        }\n\n        return {\n          id,\n          editorId: editor.id,\n          element,\n          ..._item,\n        };\n      },\n      ...options,\n    }),\n    [editor, elementId]\n  );\n\n  // Reset isAboutToDrag when drag is cancelled (e.g., ESC key)\n  React.useEffect(() => {\n    if (!collected.isDragging && isAboutToDrag) {\n      setIsAboutToDrag(false);\n    }\n  }, [collected.isDragging, isAboutToDrag]);\n\n  return [{ ...collected, isAboutToDrag }, dragRef, preview];\n};\n","import {\n  type DropTargetHookSpec,\n  type DropTargetMonitor,\n  useDrop,\n} from 'react-dnd';\n\nimport type { NodeEntry, TElement } from 'platejs';\nimport type { PlateEditor } from 'platejs/react';\n\nimport type {\n  DragItemNode,\n  ElementDragItemNode,\n  FileDragItemNode,\n} from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\nimport { getDropPath, onDropNode } from '../transforms/onDropNode';\nimport { onHoverNode } from '../transforms/onHoverNode';\n\nexport type CanDropCallback = (args: {\n  dragEntry: NodeEntry<TElement>;\n  dragItem: DragItemNode;\n  dropEntry: NodeEntry<TElement>;\n  editor: PlateEditor;\n}) => boolean;\n\nexport interface UseDropNodeOptions\n  extends DropTargetHookSpec<DragItemNode, unknown, { isOver: boolean }> {\n  /** The node to which the drop line is attached. */\n  element: TElement;\n\n  /** The reference to the node being dragged. */\n  nodeRef: any;\n\n  /** The reference to the multiple preview element */\n  multiplePreviewRef: any;\n\n  /**\n   * Intercepts the drop handling. If `false` is returned, the default drop\n   * behavior is called after. If `true` is returned, the default behavior is\n   * not called.\n   */\n  canDropNode?: CanDropCallback;\n\n  orientation?: 'horizontal' | 'vertical';\n\n  onDropHandler?: (\n    editor: PlateEditor,\n    props: {\n      id: string;\n      dragItem: DragItemNode;\n      monitor: DropTargetMonitor<DragItemNode, unknown>;\n      nodeRef: any;\n    }\n  ) => boolean | void;\n}\n\n/**\n * `useDrop` hook to drop a node on the editor.\n *\n * On drop:\n *\n * - Get hover direction (top, bottom or undefined), return early if undefined\n * - DragPath: find node with id = dragItem.id, return early if not found\n * - Focus editor\n * - DropPath: find node with id = id, its path should be next (bottom) or\n *   previous (top)\n * - Move node from dragPath to dropPath\n *\n * On hover:\n *\n * - Get drop line direction\n * - If differs from dropLine, setDropLine is called\n *\n * Collect:\n *\n * - IsOver: true if mouse is over the block\n */\nexport const useDropNode = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    element,\n    nodeRef,\n    orientation,\n    onDropHandler,\n    ...options\n  }: UseDropNodeOptions\n) => {\n  const id = element.id as string;\n\n  return useDrop<DragItemNode, unknown, { isOver: boolean }>({\n    collect: (monitor) => ({\n      isOver: monitor.isOver({\n        shallow: true,\n      }),\n    }),\n    drop: (dragItem, monitor) => {\n      // Don't call onDropNode if this is a file drop\n\n      if (!(dragItem as ElementDragItemNode).id) {\n        const result = getDropPath(editor, {\n          canDropNode,\n          dragItem,\n          element,\n          monitor,\n          nodeRef,\n          orientation,\n        });\n\n        const onDropFiles = editor.getOptions(DndPlugin).onDropFiles;\n\n        if (!result || !onDropFiles) return;\n\n        return onDropFiles({\n          id,\n          dragItem: dragItem as FileDragItemNode,\n          editor,\n          monitor,\n          nodeRef,\n          target: result.to,\n        });\n      }\n\n      const handled =\n        !!onDropHandler &&\n        onDropHandler(editor, {\n          id,\n          dragItem,\n          monitor,\n          nodeRef,\n        });\n\n      if (handled) return;\n\n      onDropNode(editor, {\n        canDropNode,\n        dragItem: dragItem as ElementDragItemNode,\n        element,\n        monitor,\n        nodeRef,\n        orientation,\n      });\n    },\n    hover(item: DragItemNode, monitor: DropTargetMonitor) {\n      onHoverNode(editor, {\n        canDropNode,\n        dragItem: item,\n        element,\n        monitor,\n        nodeRef,\n        orientation,\n      });\n    },\n    ...options,\n  });\n};\n","import type { PlateEditor } from 'platejs/react';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport { type NodeEntry, type Path, type TElement, PathApi } from 'platejs';\n\nimport type { UseDropNodeOptions } from '../hooks';\nimport type { DragItemNode, ElementDragItemNode } from '../types';\n\nimport { getHoverDirection } from '../utils';\n\n/** Callback called on drag and drop a node with id. */\nexport const getDropPath = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation = 'vertical',\n  }: {\n    dragItem: DragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<\n    UseDropNodeOptions,\n    'canDropNode' | 'element' | 'nodeRef' | 'orientation'\n  >\n) => {\n  const direction = getHoverDirection({\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation,\n  });\n\n  if (!direction) return;\n\n  let dragEntry: NodeEntry<TElement> | undefined;\n  let dropEntry: NodeEntry<TElement> | undefined;\n\n  if ('element' in dragItem) {\n    const dragPath = editor.api.findPath(dragItem.element);\n    const hoveredPath = editor.api.findPath(element);\n\n    if (!dragPath || !hoveredPath) return;\n\n    dragEntry = [dragItem.element, dragPath];\n    dropEntry = [element, hoveredPath];\n  } else {\n    dropEntry = editor.api.node<TElement>({ id: element.id as string, at: [] });\n  }\n  if (!dropEntry) return;\n  if (\n    (canDropNode &&\n      dragEntry &&\n      !canDropNode({ dragEntry, dragItem, dropEntry, editor })) ||\n    !monitor.canDrop()\n  ) {\n    return;\n  }\n\n  let dropPath: Path | undefined;\n\n  // if drag from file system use [] as default path\n  const dragPath = dragEntry?.[1];\n  const hoveredPath = dropEntry[1];\n\n  // Treat 'right' like 'bottom' (after hovered)\n  // Treat 'left' like 'top' (before hovered)\n  if (direction === 'bottom' || direction === 'right') {\n    // Insert after hovered node\n    dropPath = hoveredPath;\n\n    // If the dragged node is already right after hovered node, no change\n    if (dragPath && PathApi.equals(dragPath, PathApi.next(dropPath))) return;\n  }\n  if (direction === 'top' || direction === 'left') {\n    // Insert before hovered node\n    dropPath = [...hoveredPath.slice(0, -1), hoveredPath.at(-1)! - 1];\n\n    // If the dragged node is already right before hovered node, no change\n    if (dragPath && PathApi.equals(dragPath, dropPath)) return;\n  }\n\n  const _dropPath = dropPath as Path;\n  const before =\n    dragPath &&\n    PathApi.isBefore(dragPath, _dropPath) &&\n    PathApi.isSibling(dragPath, _dropPath);\n  const to = before ? _dropPath : PathApi.next(_dropPath);\n\n  return { direction, dragPath, to };\n};\n\nexport const onDropNode = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation = 'vertical',\n  }: {\n    dragItem: ElementDragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<\n    UseDropNodeOptions,\n    'canDropNode' | 'element' | 'nodeRef' | 'orientation'\n  >\n) => {\n  const result = getDropPath(editor, {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation,\n  });\n\n  if (!result) return;\n\n  const { dragPath, to } = result;\n\n  if (dragItem.editorId === editor.id) {\n    // Check if we're dragging multiple nodes\n    const draggedIds = Array.isArray(dragItem.id) ? dragItem.id : [dragItem.id];\n\n    if (draggedIds.length > 1) {\n      // Handle multi-node drop - get elements by their IDs and sort them\n      const elements: TElement[] = [];\n\n      draggedIds.forEach((id) => {\n        const entry = editor.api.node<TElement>({ id, at: [] });\n        if (entry) {\n          elements.push(entry[0]);\n        }\n      });\n\n      editor.tf.moveNodes({\n        at: [],\n        to,\n        match: (n) => elements.some((element) => element.id === n.id),\n      });\n    } else {\n      // Single node drop\n      editor.tf.moveNodes({\n        at: dragPath,\n        to,\n      });\n    }\n  } else {\n    editor.tf.insertNodes(dragItem.element, { at: to });\n  }\n};\n","import type { TElement } from 'platejs';\nimport type { DropTargetMonitor, XYCoord } from 'react-dnd';\n\nimport type {\n  DragItemNode,\n  DropDirection,\n  ElementDragItemNode,\n} from '../types';\n\nexport interface GetHoverDirectionOptions {\n  dragItem: DragItemNode;\n\n  /** Hovering node. */\n  element: TElement;\n\n  monitor: DropTargetMonitor;\n\n  /** The node ref of the node being dragged. */\n  nodeRef: any;\n\n  /** The orientation of the drag operation. */\n  orientation?: 'horizontal' | 'vertical';\n}\n\n/**\n * If dragging a node A over another node B: get the direction of node A\n * relative to node B.\n */\nexport const getHoverDirection = ({\n  dragItem,\n  element,\n  monitor,\n  nodeRef,\n  orientation = 'vertical',\n}: GetHoverDirectionOptions): DropDirection => {\n  if (!nodeRef.current) return;\n  // Don't replace items with themselves\n  if (element === (dragItem as ElementDragItemNode).element) return;\n\n  // For multiple node drag, don't show drop line if hovering over any selected element\n  const elementDragItem = dragItem as ElementDragItemNode;\n  const draggedIds = Array.isArray(elementDragItem.id)\n    ? elementDragItem.id\n    : [elementDragItem.id];\n  if (draggedIds.includes(element.id as string)) return;\n\n  // Determine rectangle on screen\n  const hoverBoundingRect = nodeRef.current?.getBoundingClientRect();\n\n  if (!hoverBoundingRect) {\n    return;\n  }\n\n  // Determine mouse position\n  const clientOffset = monitor.getClientOffset();\n\n  if (!clientOffset) {\n    return;\n  }\n  if (orientation === 'vertical') {\n    // Get vertical middle\n    const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n\n    // Get pixels to the top\n    const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;\n\n    // Only perform the move when the mouse has crossed half of the items height\n    // When dragging downwards, only move when the cursor is below 50%\n    // When dragging upwards, only move when the cursor is above 50%\n\n    // Dragging downwards\n    if (hoverClientY < hoverMiddleY) {\n      return 'top';\n    }\n    // Dragging upwards\n    if (hoverClientY >= hoverMiddleY) {\n      return 'bottom';\n    }\n  } else {\n    // Horizontal orientation for columns\n    const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;\n    const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left;\n\n    return hoverClientX < hoverMiddleX ? 'left' : 'right';\n  }\n};\n","/** Get new direction if updated */\nimport type { DropLineDirection } from '../types';\n\nexport const getNewDirection = (\n  previousDir: string,\n  dir?: string\n): DropLineDirection | undefined => {\n  if (!dir && previousDir) {\n    return '';\n  }\n  if (dir === 'top' && previousDir !== 'top') {\n    return 'top';\n  }\n  if (dir === 'bottom' && previousDir !== 'bottom') {\n    return 'bottom';\n  }\n  if (dir === 'left' && previousDir !== 'left') {\n    return 'left';\n  }\n  if (dir === 'right' && previousDir !== 'right') {\n    return 'right';\n  }\n};\n","import type { PlateEditor } from 'platejs/react';\nimport type { DropTargetMonitor } from 'react-dnd';\n\nimport { NodeApi, PathApi } from 'platejs';\n\nimport type { UseDropNodeOptions } from '../hooks/useDropNode';\nimport type { DragItemNode } from '../types';\n\nimport { DndPlugin } from '../DndPlugin';\nimport { getDropPath } from './onDropNode';\n\n/** Callback called when dragging a node and hovering nodes. */\nexport const onHoverNode = (\n  editor: PlateEditor,\n  {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation = 'vertical',\n  }: {\n    dragItem: DragItemNode;\n    monitor: DropTargetMonitor;\n  } & Pick<\n    UseDropNodeOptions,\n    'canDropNode' | 'element' | 'nodeRef' | 'orientation'\n  >\n) => {\n  const { _isOver, dropTarget } = editor.getOptions(DndPlugin);\n  const currentId = dropTarget?.id ?? null;\n  const currentLine = dropTarget?.line ?? '';\n\n  // Check if the drop would actually move the node.\n  const result = getDropPath(editor, {\n    canDropNode,\n    dragItem,\n    element,\n    monitor,\n    nodeRef,\n    orientation,\n  });\n\n  // If getDropPath returns undefined, it means no actual move would happen.\n  // In that case, don't show a drop target.\n  if (!result) {\n    if (currentId || currentLine) {\n      editor.setOption(DndPlugin, 'dropTarget', { id: null, line: '' });\n    }\n\n    return;\n  }\n\n  const { direction } = result;\n  const newDropTarget = { id: element.id as string, line: direction };\n\n  if (newDropTarget.id !== currentId || newDropTarget.line !== currentLine) {\n    // Only set if there's a real change\n\n    if (!_isOver) {\n      return;\n    }\n\n    if (newDropTarget.line === 'top') {\n      const previousPath = PathApi.previous(editor.api.findPath(element)!);\n\n      if (!previousPath) {\n        return editor.setOption(DndPlugin, 'dropTarget', newDropTarget);\n      }\n\n      const nextNode = NodeApi.get(editor, previousPath!);\n\n      editor.setOption(DndPlugin, 'dropTarget', {\n        id: nextNode?.id as string,\n        line: 'bottom',\n      });\n\n      return;\n    }\n\n    editor.setOption(DndPlugin, 'dropTarget', newDropTarget);\n  }\n  if (direction && editor.api.isExpanded()) {\n    editor.tf.focus();\n    editor.tf.collapse();\n  }\n};\n","import type { Editor, EditorNodesOptions, ValueOf } from 'platejs';\n\n/** Get blocks with an id */\nexport const getBlocksWithId = <E extends Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n) => {\n  const _nodes = editor.api.nodes({\n    match: (n) => editor.api.isBlock(n) && !!n.id,\n    ...options,\n  });\n\n  return Array.from(_nodes);\n};\n","import type { Editor } from 'platejs';\n\n/** Select the start of a block by id and focus the editor. */\nexport const focusBlockStartById = (editor: Editor, id: string) => {\n  const path = editor.api.node({ id, at: [] })?.[1];\n\n  if (!path) return;\n\n  editor.tf.select(editor.api.start(path)!);\n  editor.tf.focus();\n};\n","import type { Editor, EditorNodesOptions, ValueOf } from 'platejs';\n\nimport { getBlocksWithId } from '../queries/getBlocksWithId';\n\n/** Remove blocks with an id and focus the editor. */\nexport const removeBlocksAndFocus = <E extends Editor = Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n) => {\n  const nodeEntries = getBlocksWithId(editor, options);\n\n  editor.tf.removeNodes({ at: editor.api.nodesRange(nodeEntries) });\n  editor.tf.focus();\n};\n","import type { Editor } from 'platejs';\n\n/** Select the block above the selection by id and focus the editor. */\nexport const selectBlockById = (editor: Editor, id: string) => {\n  const path = editor.api.node({ id, at: [] })?.[1];\n\n  if (!path) return;\n\n  editor.tf.select(editor.api.range(path)!);\n  editor.tf.focus();\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { getBlocksWithId } from '../queries/getBlocksWithId';\nimport { selectBlockById } from './selectBlockById';\n\n/**\n * Select blocks by selection or by id. If the block with id is not selected,\n * select the block with id. Else, select the blocks above the selection.\n */\nexport const selectBlocksBySelectionOrId = (\n  editor: PlateEditor,\n  id: string\n) => {\n  if (!editor.selection) return;\n\n  const blockEntries = getBlocksWithId(editor, { at: editor.selection });\n  const isBlockSelected = blockEntries.some(\n    (blockEntry) => blockEntry[0].id === id\n  );\n\n  if (isBlockSelected) {\n    editor.tf.select(editor.api.nodesRange(blockEntries)!);\n    editor.tf.focus();\n  } else {\n    selectBlockById(editor, id);\n  }\n};\n"],"mappings":"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","names":["React","React","React","React","React","React","React","React","useEditorRef","React","React","dragPath","hoveredPath","element","PathApi","PathApi","useEditorRef"]}