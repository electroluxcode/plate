{"version":3,"sources":["../../src/react/BlockMenuPlugin.tsx","../../src/react/BlockSelectionPlugin.tsx","../../src/internal/transforms/selectBlocks.ts","../../src/react/components/BlockSelectionAfterEditable.tsx","../../src/react/hooks/useBlockSelectable.ts","../../src/react/hooks/useBlockSelected.ts","../../src/react/hooks/useBlockSelectionNodes.ts","../../src/react/hooks/useCursorOverlay.ts","../../src/react/CursorOverlayPlugin.tsx","../../src/react/queries/getCaretPosition.ts","../../src/react/queries/getCursorOverlayState.ts","../../src/react/queries/getSelectionRects.ts","../../src/react/hooks/useRefreshOnResize.ts","../../src/react/hooks/useRequestReRender.ts","../../src/react/hooks/useIsSelecting.ts","../../src/lib/extractSelectableIds.ts","../../src/lib/getAboveDomNode.ts","../../src/lib/isSelecting.ts","../../src/react/hooks/useSelectionArea.ts","../../src/internal/EventEmitter.ts","../../src/internal/utils/css.ts","../../src/internal/utils/events.ts","../../src/internal/utils/intersects.ts","../../src/internal/utils/selectAll.ts","../../src/internal/utils/constants.ts","../../src/internal/utils/frames.ts","../../src/internal/utils/shouldTrigger.ts","../../src/internal/SelectionArea.ts","../../src/react/utils/copySelectedBlocks.ts","../../src/react/utils/pasteSelectedBlocks.ts","../../src/react/utils/selectInsertedBlocks.ts","../../src/react/internal/api/moveSelection.ts","../../src/react/internal/api/setSelectedIds.ts","../../src/react/internal/api/shiftSelection.ts","../../src/react/transforms/duplicateBlockSelectionNodes.ts","../../src/react/transforms/insertBlocksAndSelect.ts","../../src/react/transforms/removeBlockSelectionNodes.ts","../../src/react/transforms/selectBlockSelectionNodes.ts","../../src/react/transforms/setBlockSelectionNodes.ts"],"sourcesContent":["import type { PluginConfig } from 'platejs';\n\nimport { KEYS } from 'platejs';\nimport { createTPlatePlugin } from 'platejs/react';\n\nimport type { BlockSelectionConfig } from './BlockSelectionPlugin';\n\nexport const BLOCK_CONTEXT_MENU_ID = 'context';\n\nexport type BlockMenuConfig = PluginConfig<\n  'blockMenu',\n  {\n    openId: OpenId | null;\n    position: {\n      x: number;\n      y: number;\n    };\n  },\n  {\n    blockMenu: {\n      hide: () => void;\n      show: (id: OpenId, position?: { x: number; y: number }) => void;\n      showContextMenu: (\n        blockId: string,\n        position: { x: number; y: number }\n      ) => void;\n    };\n  }\n>;\n\ntype OpenId = (string & {}) | typeof BLOCK_CONTEXT_MENU_ID;\n\nexport const BlockMenuPlugin = createTPlatePlugin<BlockMenuConfig>({\n  key: KEYS.blockMenu,\n  editOnly: true,\n  options: {\n    openId: null,\n    position: {\n      x: -10_000,\n      y: -10_000,\n    },\n  },\n})\n  .extendApi<Partial<BlockMenuConfig['api']['blockMenu']>>(\n    ({ setOption, setOptions }) => ({\n      hide: () => {\n        setOptions({\n          openId: null,\n          position: {\n            x: -10_000,\n            y: -10_000,\n          },\n        });\n      },\n      show: (id, position) => {\n        if (position) {\n          setOptions({\n            openId: id,\n            position,\n          });\n        } else {\n          setOption('openId', id);\n        }\n      },\n    })\n  )\n  .extendApi<Partial<BlockMenuConfig['api']['blockMenu']>>(\n    ({ api, editor }) => ({\n      showContextMenu: (blockId, position) => {\n        editor\n          .getApi<BlockSelectionConfig>({ key: KEYS.blockSelection })\n          .blockSelection?.set(blockId);\n        api.blockMenu.show(BLOCK_CONTEXT_MENU_ID, position);\n      },\n    })\n  )\n  .extend(({ api }) => ({\n    handlers: {\n      onMouseDown: ({ event, getOptions }) => {\n        if (event.button === 0 && getOptions().openId) {\n          event.preventDefault();\n          api.blockMenu.hide();\n        }\n        if (event.button === 2) event.preventDefault();\n      },\n    },\n  }));\n","import type { CSSProperties } from 'react';\nimport type React from 'react';\n\nimport type {\n  NodeEntry,\n  OmitFirst,\n  Path,\n  PluginConfig,\n  TElement,\n  TIdElement,\n} from 'platejs';\n\nimport { bindFirst, KEYS, PathApi } from 'platejs';\nimport { type PlatePluginContext, createTPlatePlugin } from 'platejs/react';\n\nimport type { PartialSelectionOptions } from '../internal';\n\nimport { selectBlocks } from '../internal/transforms/selectBlocks';\nimport { BlockMenuPlugin } from './BlockMenuPlugin';\nimport { BlockSelectionAfterEditable } from './components/BlockSelectionAfterEditable';\nimport {\n  addOnContextMenu,\n  useBlockSelectable,\n} from './hooks/useBlockSelectable';\nimport { moveSelection } from './internal/api/moveSelection';\nimport { addSelectedRow, setSelectedIds } from './internal/api/setSelectedIds';\nimport { shiftSelection } from './internal/api/shiftSelection';\nimport { duplicateBlockSelectionNodes } from './transforms/duplicateBlockSelectionNodes';\nimport { insertBlocksAndSelect } from './transforms/insertBlocksAndSelect';\nimport { removeBlockSelectionNodes } from './transforms/removeBlockSelectionNodes';\nimport { selectBlockSelectionNodes } from './transforms/selectBlockSelectionNodes';\nimport {\n  setBlockSelectionIndent,\n  setBlockSelectionNodes,\n  setBlockSelectionTexts,\n} from './transforms/setBlockSelectionNodes';\n\nexport type BlockSelectionConfig = PluginConfig<\n  'blockSelection',\n  {\n    anchorId?: string | null;\n    areaOptions?: PartialSelectionOptions;\n    editorPaddingRight?: CSSProperties['width'];\n    enableContextMenu?: boolean;\n    isSelecting?: boolean;\n    isSelectionAreaVisible?: boolean;\n    rightSelectionAreaClassName?: string;\n    selectedIds?: Set<string>;\n    shadowInputRef?: React.RefObject<HTMLInputElement | null>;\n    /** Check if a block is selectable */\n    isSelectable?: (element: TElement, path: Path) => boolean;\n    onKeyDownSelecting?: (e: KeyboardEvent) => void;\n  },\n  {\n    blockSelection: {\n      /** Add block selection when right click on a block. */\n      addOnContextMenu: OmitFirst<typeof addOnContextMenu>;\n      /** Set selected block ids */\n      setSelectedIds: OmitFirst<typeof setSelectedIds>;\n      /** Add a block to the selection. */\n      add: (id: string[] | string) => void;\n      /**\n       * Select a block by id, with optional delay and clear options.\n       *\n       * @deprecated Use `add` or `set` instead.\n       */\n      addSelectedRow: (\n        id: string,\n        options?: { clear?: boolean; delay?: number }\n      ) => void;\n      /** Clear block selection */\n      clear: () => void;\n      /** Delete a block from the selection. */\n      delete: (id: string[] | string) => void;\n      /** Deselect all blocks */\n      deselect: () => void;\n      /** Get the first selected block */\n      first: () => NodeEntry<TIdElement> | null;\n      /** Focus block selection â€“ that differs from the editor focus */\n      focus: () => void;\n      /**\n       * Get selected blocks\n       *\n       * @param options.sort - Sort the nodes by path\n       * @param options.collapseTableRows - If all table rows are selected,\n       *   return the table node with all selected rows instead, do not return\n       *   the table rows anymore.\n       */\n      getNodes: (options?: {\n        collapseTableRows?: boolean;\n        sort?: boolean;\n      }) => NodeEntry<TIdElement>[];\n      /** Check if a block is selected. */\n      has: (id: string[] | string) => boolean;\n      /** Check if a block is selectable. */\n      isSelectable: (element: TElement, path: Path) => boolean;\n      /** Arrow-based move selection */\n      moveSelection: (direction: 'down' | 'up') => void;\n      /** Reset selected block ids. @deprecated Use `clear` instead. */\n      resetSelectedIds: () => void;\n      /** Select all selectable blocks */\n      selectAll: () => void;\n      /** Set a block to be selected. */\n      set: (id: string[] | string) => void;\n      /** Shift-based expand/shrink selection */\n      shiftSelection: (direction: 'down' | 'up') => void;\n      /** Deselect all blocks. @deprecated Use `deselect` instead. */\n      unselect: () => void;\n    };\n  },\n  {},\n  {\n    /** Check if a block is selected by id */\n    isSelected?: (id?: string) => boolean;\n    /** Check if any blocks are selected */\n    isSelectingSome?: () => boolean;\n  }\n>;\n\nexport const BlockSelectionPlugin = createTPlatePlugin<BlockSelectionConfig>({\n  key: KEYS.blockSelection,\n  editOnly: true,\n  handlers: {\n    onMouseDown: ({ api, editor, event, getOptions }) => {\n      const target = event.target as HTMLElement;\n\n      if (\n        // deprecated\n        target.dataset.platePreventUnselect ||\n        target.dataset.platePreventDeselect\n      )\n        return;\n      if (\n        event.button === 0 &&\n        getOptions().selectedIds!.size > 0 &&\n        !editor.getOption(BlockMenuPlugin, 'openId')\n      ) {\n        api.blockSelection.deselect();\n      }\n    },\n  },\n  inject: {\n    isBlock: true,\n    nodeProps: {\n      transformProps: () => {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        return useBlockSelectable().props;\n      },\n    },\n  },\n  options: {\n    anchorId: null,\n    areaOptions: {\n      features: {\n        singleTap: {\n          allow: false,\n        },\n      },\n    },\n    enableContextMenu: false,\n    isSelecting: false,\n    isSelectionAreaVisible: false,\n    selectedIds: new Set(),\n    shadowInputRef: { current: null },\n    isSelectable: () => true,\n  },\n  plugins: [BlockMenuPlugin],\n  render: {\n    afterEditable: BlockSelectionAfterEditable,\n  },\n})\n  .extendSelectors<BlockSelectionConfig['selectors']>(({ getOptions }) => ({\n    isSelected: (id) => !!id && getOptions().selectedIds!.has(id),\n    isSelectingSome: () => getOptions().selectedIds!.size > 0,\n  }))\n  .extendApi<Partial<BlockSelectionConfig['api']['blockSelection']>>(\n    ({ api, editor, getOption, getOptions, setOption }) => ({\n      addOnContextMenu: bindFirst(addOnContextMenu, editor),\n      moveSelection: bindFirst(moveSelection, editor),\n      setSelectedIds: bindFirst(setSelectedIds, editor),\n      shiftSelection: bindFirst(shiftSelection, editor),\n      add: (id) => {\n        const next = new Set(getOptions().selectedIds!);\n\n        if (Array.isArray(id)) {\n          id.forEach((singleId) => next.add(singleId));\n        } else {\n          next.add(id);\n        }\n\n        setOption('selectedIds', next);\n      },\n      clear: () => {\n        setOption('selectedIds', new Set());\n      },\n      delete: (id) => {\n        const next = new Set(getOptions().selectedIds!);\n\n        if (Array.isArray(id)) {\n          id.forEach((i) => next.delete(i));\n        } else {\n          next.delete(id);\n        }\n\n        setOption('selectedIds', next);\n      },\n      deselect: () => {\n        setOption('selectedIds', new Set());\n        setOption('isSelecting', false);\n      },\n      first: () => {\n        const selectedIds = getOption('selectedIds');\n\n        if (!selectedIds || selectedIds.size === 0) return null;\n\n        return editor.api.node({\n          at: [],\n          match: (n) => selectedIds.has(n.id as string),\n        })!;\n      },\n      focus: () => {\n        const shadowInputRef = getOption('shadowInputRef');\n\n        if (shadowInputRef?.current) {\n          shadowInputRef.current.focus({ preventScroll: true });\n        }\n      },\n      getNodes: (options) => {\n        const selectedIds = getOption('selectedIds');\n\n        let nodes = [];\n\n        nodes = editor.api.blocks<TIdElement>({\n          at: [],\n          match: (n) => !!n.id && selectedIds?.has(n.id as string),\n        });\n\n        if (options?.sort) {\n          nodes.sort(([, pathA], [, pathB]) => {\n            return PathApi.compare(pathA, pathB);\n          });\n        }\n\n        if (options?.collapseTableRows) {\n          const collapsedNodes: NodeEntry<TIdElement>[] = [];\n\n          nodes.forEach(([node, path]) => {\n            if (node.type === KEYS.tr) {\n              const tablePath = PathApi.parent(path);\n              const tableNodeEntry = editor.api.node<TIdElement>(tablePath)!;\n\n              // Check if table already exists in collapsedNodes\n              const existingTableIndex = collapsedNodes.findIndex(\n                ([existingNode]) =>\n                  existingNode.type === tableNodeEntry[0].type &&\n                  existingNode.id === tableNodeEntry[0].id\n              );\n\n              if (existingTableIndex === -1) {\n                // Create new table with this row\n                const tableNodeCopy = {\n                  ...tableNodeEntry[0],\n                  children: [node],\n                };\n\n                collapsedNodes.push([tableNodeCopy, tableNodeEntry[1]]);\n              } else {\n                // Add the row to existing table\n                const existingTable = collapsedNodes[existingTableIndex][0];\n                existingTable.children.push(node);\n              }\n              return;\n            }\n\n            collapsedNodes.push([node, path]);\n          });\n\n          return collapsedNodes;\n        }\n\n        return nodes;\n      },\n      has: (id) => {\n        if (Array.isArray(id)) {\n          return id.every((i) => getOptions().selectedIds!.has(i));\n        }\n\n        return getOptions().selectedIds!.has(id);\n      },\n      isSelectable: (element, path) =>\n        !!element.id &&\n        editor.api.isBlock(element) &&\n        getOptions().isSelectable!(element, path),\n      resetSelectedIds: () => {\n        setOption('selectedIds', new Set());\n      },\n      set: (id) => {\n        setOption('selectedIds', new Set(Array.isArray(id) ? id : [id]));\n      },\n      unselect: () => {\n        setOption('selectedIds', new Set());\n        setOption('isSelecting', false);\n      },\n    })\n  )\n  .extendApi<Partial<BlockSelectionConfig['api']['blockSelection']>>(\n    ({ api, editor, setOption }) => ({\n      addSelectedRow: bindFirst(addSelectedRow, editor),\n      selectAll: () => {\n        const ids = api\n          .blocks({\n            at: [],\n            mode: 'highest',\n            match: (n, p) =>\n              !!n.id && api.blockSelection.isSelectable(n as any, p),\n          })\n          .map((n) => n[0].id as string);\n\n        setOption('selectedIds', new Set(ids));\n        api.blockSelection.focus();\n      },\n    })\n  )\n  .extendTransforms(({ editor }) => ({\n    /** Duplicate selected blocks */\n    duplicate: bindFirst(duplicateBlockSelectionNodes, editor),\n    /** Insert blocks and select */\n    insertBlocksAndSelect: bindFirst(insertBlocksAndSelect, editor),\n    /** Remove selected blocks */\n    removeNodes: bindFirst(removeBlockSelectionNodes, editor),\n    /** Set selection based on block selection */\n    select: bindFirst(selectBlockSelectionNodes, editor),\n    /**\n     * Selects blocks in the editor based on the provided block ID.\n     *\n     * Uses block selection if any blocks are selected, otherwise falls back to\n     * editor selection. If the provided block ID is already in the current\n     * selection, maintains the existing selection. Otherwise, clears the\n     * current selection and selects only the specified block.\n     */\n    selectBlocks: bindFirst(selectBlocks, editor),\n    /** Set block indent */\n    setIndent: bindFirst(setBlockSelectionIndent, editor),\n    /** Set nodes on selected blocks */\n    setNodes: bindFirst(setBlockSelectionNodes, editor),\n    /** Set texts on selected blocks */\n    setTexts: bindFirst(setBlockSelectionTexts, editor),\n  }))\n  .overrideEditor((ctx) => {\n    const {\n      api,\n      api: { nodes },\n      editor,\n      getOption,\n      getOptions,\n      tf: {\n        addMark,\n        escape,\n        focus,\n        selectAll,\n        setNodes,\n        setSelection,\n        toggleMark,\n      },\n    } = ctx;\n\n    return {\n      api: {\n        // turn-into-dropdown-menu\n        nodes(options) {\n          if (!options?.at && getOption('isSelectingSome')) {\n            return api.blockSelection.getNodes();\n          }\n\n          return nodes(options) as any;\n        },\n      },\n      transforms: {\n        addMark(key, value) {\n          withBlockSelection(ctx as any, () => {\n            addMark(key, value);\n          });\n        },\n        escape: () => {\n          const apply = () => {\n            const ancestorNode = editor.api.block({ highest: true });\n\n            if (!ancestorNode) return;\n\n            const id = ancestorNode[0].id as string;\n\n            if (!id) return;\n\n            api.blockSelection.set(id);\n\n            return true;\n          };\n\n          if (apply()) return true;\n\n          return escape();\n        },\n        focus() {\n          if (!editor.meta._forceFocus && getOption('isSelectingSome')) return;\n          focus();\n        },\n        selectAll: () => {\n          const apply = () => {\n            const ancestorNode = editor.api.block({ highest: true });\n\n            if (!ancestorNode) return;\n\n            const [, path] = ancestorNode;\n\n            if (editor.api.isAt({ block: true, end: true, start: true })) {\n              api.blockSelection.selectAll();\n              return true;\n            }\n            // TODOï¼š should select the blocks then selected all should exclude table and columns\n            if (!editor.api.isAt({ block: true })) {\n              api.blockSelection.selectAll();\n              return true;\n            }\n\n            editor.tf.select(path);\n\n            return true;\n          };\n\n          if (apply()) return true;\n\n          return selectAll();\n        },\n        setNodes(props, options) {\n          withBlockSelection(ctx as any, () => {\n            setNodes(props, options);\n          });\n        },\n        setSelection(props) {\n          if (\n            getOptions().selectedIds!.size > 0 &&\n            !editor.getOption(BlockMenuPlugin, 'openId')\n          ) {\n            api.blockSelection.deselect();\n          }\n\n          setSelection(props);\n        },\n        toggleMark(key, options) {\n          withBlockSelection(ctx as any, () => {\n            toggleMark(key, options);\n          });\n        },\n      },\n    };\n  });\n\nconst withBlockSelection = (\n  { api, editor, getOption }: PlatePluginContext<BlockSelectionConfig>,\n  callback: any\n) => {\n  if (getOption('isSelectingSome')) {\n    editor.tf.withoutNormalizing(() => {\n      const blocks = editor\n        .getApi(BlockSelectionPlugin)\n        .blockSelection.getNodes();\n\n      editor.tf.select(editor.api.nodesRange(blocks));\n\n      callback();\n\n      api.blockSelection.set(blocks.map(([node]) => node.id));\n    });\n    return;\n  }\n\n  callback();\n};\n","import type { Path, SlateEditor, TIdElement, TNode } from 'platejs';\n\nimport { BlockSelectionPlugin } from '../../react';\n\nexport const selectBlocks = (editor: SlateEditor, at: Path | TNode) => {\n  const blockSelection = editor\n    .getApi(BlockSelectionPlugin)\n    .blockSelection.getNodes();\n\n  const entry = editor.api.node<TIdElement>(at);\n\n  if (!entry) return;\n\n  const [element, path] = entry;\n\n  const selectedBlocks =\n    blockSelection.length > 0\n      ? blockSelection\n      : editor.api.blocks({\n          mode: 'lowest',\n          match: (_, p) => p.length === path.length,\n        });\n  const ids = selectedBlocks.map((block) => block[0].id as string);\n\n  editor\n    .getApi(BlockSelectionPlugin)\n    .blockSelection.set(ids.includes(element.id) ? ids : [element.id]);\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { isHotkey, KEYS, PathApi } from 'platejs';\nimport {\n  type EditableSiblingComponent,\n  useEditorPlugin,\n  useEditorRef,\n  usePluginOption,\n} from 'platejs/react';\n\nimport {\n  type BlockSelectionConfig,\n  BlockSelectionPlugin,\n} from '../BlockSelectionPlugin';\nimport { useSelectionArea } from '../hooks';\nimport {\n  copySelectedBlocks,\n  pasteSelectedBlocks,\n  selectInsertedBlocks,\n} from '../utils';\n\nexport const BlockSelectionAfterEditable: EditableSiblingComponent = () => {\n  const editor = useEditorRef();\n  const { api, getOption, getOptions, setOption } =\n    useEditorPlugin<BlockSelectionConfig>({ key: KEYS.blockSelection });\n\n  const isSelectingSome = usePluginOption(\n    BlockSelectionPlugin,\n    'isSelectingSome'\n  );\n  const selectedIds = usePluginOption(BlockSelectionPlugin, 'selectedIds');\n\n  const removeSelectedBlocks = React.useCallback(\n    (options: { selectPrevious?: boolean } = {}) => {\n      const entries = [\n        ...editor.api.nodes({\n          at: [],\n          match: (n) => !!n.id && selectedIds?.has(n.id as string),\n        }),\n      ];\n\n      if (entries.length === 0) return null;\n\n      const firstPath = entries[0]![1];\n\n      editor.tf.withoutNormalizing(() => {\n        for (const [node, path] of [...entries].reverse()) {\n          editor.tf.removeNodes({\n            at: path,\n          });\n          api.blockSelection.delete(node.id as string);\n        }\n\n        if (editor.children.length === 0) {\n          editor.meta._forceFocus = true;\n          editor.tf.focus();\n          editor.meta._forceFocus = false;\n        } else if (options.selectPrevious) {\n          const prevPath = PathApi.previous(firstPath);\n\n          if (prevPath) {\n            const prevEntry = editor.api.block({ at: prevPath });\n\n            if (prevEntry) {\n              setOption('selectedIds', new Set([prevEntry[0].id as string]));\n            }\n          }\n        }\n      });\n\n      return firstPath;\n    },\n    [editor, api.blockSelection, selectedIds, setOption]\n  );\n\n  useSelectionArea();\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [isMounted, setIsMounted] = React.useState(false);\n\n  React.useEffect(() => {\n    setIsMounted(true);\n    setOption('shadowInputRef', inputRef);\n\n    return () => {\n      setIsMounted(false);\n    };\n  }, [setOption]);\n\n  React.useEffect(() => {\n    if (!isSelectingSome) {\n      setOption('anchorId', null);\n    }\n  }, [isSelectingSome, setOption]);\n\n  React.useEffect(() => {\n    if (isSelectingSome && inputRef.current) {\n      inputRef.current.focus({ preventScroll: true });\n    } else if (inputRef.current) {\n      inputRef.current.blur();\n    }\n  }, [isSelectingSome]);\n\n  const handleKeyDown = React.useCallback(\n    (e: React.KeyboardEvent<HTMLInputElement>) => {\n      const isReadonly = editor.api.isReadOnly();\n      getOptions().onKeyDownSelecting?.(e.nativeEvent);\n\n      if (!getOption('isSelectingSome')) return;\n      if (isHotkey('shift+up')(e)) {\n        e.preventDefault();\n        e.stopPropagation();\n        api.blockSelection.shiftSelection('up');\n\n        return;\n      }\n      if (isHotkey('shift+down')(e)) {\n        e.preventDefault();\n        e.stopPropagation();\n        api.blockSelection.shiftSelection('down');\n\n        return;\n      }\n      // ESC => unselect all\n      if (isHotkey('escape')(e)) {\n        api.blockSelection.deselect();\n\n        return;\n      }\n      // Undo/redo\n      if (isHotkey('mod+z')(e)) {\n        editor.undo();\n        selectInsertedBlocks(editor);\n\n        return;\n      }\n      if (isHotkey('mod+a')(e)) {\n        api.blockSelection.selectAll();\n\n        return;\n      }\n\n      if (isHotkey('mod+shift+z')(e)) {\n        editor.redo();\n        selectInsertedBlocks(editor);\n\n        return;\n      }\n      // Mod+D => duplicate selected blocks\n      if (isHotkey('mod+d')(e)) {\n        e.preventDefault();\n        editor.getTransforms(BlockSelectionPlugin).blockSelection.duplicate();\n        return;\n      }\n      // Only continue if we have \"some\" selection\n      if (!getOption('isSelectingSome')) return;\n      // Enter => focus first selected block\n      if (isHotkey('enter')(e)) {\n        const entry = editor.api.node({\n          at: [],\n          block: true,\n          match: (n) => !!n.id && selectedIds?.has(n.id as string),\n        });\n\n        if (entry) {\n          const [, path] = entry;\n          editor.meta._forceFocus = true;\n          editor.tf.focus({ at: path, edge: 'end' });\n          delete editor.meta._forceFocus;\n          e.preventDefault();\n        }\n\n        return;\n      }\n      // Backspace/Delete => remove selected blocks\n      if (isHotkey(['backspace', 'delete'])(e) && !isReadonly) {\n        e.preventDefault();\n        removeSelectedBlocks({\n          selectPrevious: isHotkey('backspace')(e),\n        });\n        return;\n      }\n      // If SHIFT not pressed => arrow up/down sets new anchor\n      if (isHotkey('up')(e)) {\n        e.preventDefault();\n        e.stopPropagation();\n        api.blockSelection.moveSelection('up');\n\n        return;\n      }\n      if (isHotkey('down')(e)) {\n        e.preventDefault();\n        e.stopPropagation();\n        api.blockSelection.moveSelection('down');\n\n        return;\n      }\n\n      // Handle character input - remove selected blocks and insert character\n      if (\n        !isReadonly &&\n        e.key.length === 1 && // Only handle single character keys\n        !e.ctrlKey &&\n        !e.metaKey &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n        const firstPath = removeSelectedBlocks();\n\n        if (firstPath) {\n          editor.meta._forceFocus = true;\n          editor.tf.insertNodes(\n            editor.api.create.block({ children: [{ text: e.key }] }),\n            { at: firstPath }\n          );\n          editor.tf.select(firstPath, { edge: 'end' });\n          editor.meta._forceFocus = false;\n          editor.tf.focus();\n        }\n        return;\n      }\n    },\n    [\n      editor,\n      getOptions,\n      getOption,\n      api.blockSelection,\n      removeSelectedBlocks,\n      selectedIds,\n    ]\n  );\n\n  /** Handle copy / cut / paste in block selection */\n  const handleCopy = React.useCallback(\n    (e: React.ClipboardEvent<HTMLInputElement>) => {\n      e.preventDefault();\n\n      if (getOption('isSelectingSome')) {\n        copySelectedBlocks(editor);\n      }\n    },\n    [editor, getOption]\n  );\n\n  const handleCut = React.useCallback(\n    (e: React.ClipboardEvent<HTMLInputElement>) => {\n      e.preventDefault();\n\n      if (getOption('isSelectingSome')) {\n        copySelectedBlocks(editor);\n\n        if (!editor.api.isReadOnly()) {\n          removeSelectedBlocks();\n        }\n      }\n    },\n    [editor, getOption, removeSelectedBlocks]\n  );\n\n  const handlePaste = React.useCallback(\n    (e: React.ClipboardEvent<HTMLInputElement>) => {\n      e.preventDefault();\n\n      if (!editor.api.isReadOnly()) {\n        pasteSelectedBlocks(editor, e.nativeEvent);\n      }\n    },\n    [editor]\n  );\n\n  if (!isMounted || typeof window === 'undefined') {\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <input\n      ref={inputRef}\n      className=\"slate-shadow-input\"\n      style={{\n        left: '-300px',\n        opacity: 0,\n        position: 'fixed',\n        top: '-300px',\n        zIndex: 999,\n      }}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onKeyDown={handleKeyDown}\n      onPaste={handlePaste}\n    />,\n    document.body\n  );\n};\n","import type React from 'react';\n\nimport { type TElement, KEYS, PathApi } from 'platejs';\nimport {\n  type PlateEditor,\n  useEditorPlugin,\n  useElement,\n  usePath,\n} from 'platejs/react';\n\nimport {\n  type BlockSelectionConfig,\n  BlockSelectionPlugin,\n} from '../BlockSelectionPlugin';\n\n/** Add block selection when right click on a block. */\nexport const addOnContextMenu = (\n  editor: PlateEditor,\n  {\n    /**\n     * When right click on a block, if the block is focused, the context menu\n     * will be disabled and open the browser context menu.\n     */\n    disabledWhenFocused = true,\n    element,\n    event,\n  }: {\n    element: TElement;\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>;\n    disabledWhenFocused?: boolean;\n  }\n) => {\n  const { enableContextMenu, selectedIds } =\n    editor.getOptions(BlockSelectionPlugin);\n\n  if (!enableContextMenu) return;\n\n  if (editor.selection?.focus && disabledWhenFocused) {\n    const nodeEntry = editor.api.above<TElement>();\n    const elementPath = editor.api.findPath(element);\n\n    if (\n      nodeEntry &&\n      elementPath &&\n      PathApi.isCommon(elementPath, nodeEntry[1])\n    ) {\n      const id = nodeEntry[0].id as string | undefined;\n      const isSelected = editor.getOption(\n        BlockSelectionPlugin,\n        'isSelected',\n        id\n      );\n      const isOpenAlways =\n        (event.target as HTMLElement).dataset?.plateOpenContextMenu === 'true';\n\n      /**\n       * When \"block selected or is void or has openContextMenu props\", right\n       * click can always open the context menu.\n       */\n      if (!isSelected && !editor.api.isVoid(nodeEntry[0]) && !isOpenAlways) {\n        return event.stopPropagation();\n      }\n    }\n  }\n\n  const id = element.id as string | undefined;\n\n  if (id) {\n    if (event?.shiftKey) {\n      editor.getApi(BlockSelectionPlugin).blockSelection.add(id);\n    } else {\n      const clickAlreadySelected = selectedIds?.has(id);\n\n      if (!clickAlreadySelected) {\n        editor.setOption(BlockSelectionPlugin, 'selectedIds', new Set([id]));\n      }\n    }\n  }\n};\n\nexport const useBlockSelectable = () => {\n  const element = useElement();\n  const path = usePath();\n  const { api, editor, getOption, getOptions, setOption } =\n    useEditorPlugin<BlockSelectionConfig>({\n      key: KEYS.blockSelection,\n    });\n\n  return {\n    props: api.blockSelection?.isSelectable(element, path)\n      ? {\n          className: 'slate-selectable',\n          onContextMenu: (\n            event: React.MouseEvent<HTMLDivElement, MouseEvent>\n          ) =>\n            addOnContextMenu(editor, {\n              element,\n              event,\n            }),\n        }\n      : {},\n  };\n};\n","import { useElement, usePluginOption } from 'platejs/react';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const useBlockSelected = (_id?: string) => {\n  const { id } = useElement();\n\n  const isBlockSelected = usePluginOption(\n    BlockSelectionPlugin,\n    'isSelected',\n    _id ?? (id as string)\n  );\n\n  return isBlockSelected;\n};\n","import { useMemo } from 'react';\n\nimport type { EditorPropOptions, TElement } from 'platejs';\n\nimport { useEditorRef, usePluginOption } from 'platejs/react';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport function useBlockSelectionNodes() {\n  const editor = useEditorRef();\n  const selectedIds = usePluginOption(BlockSelectionPlugin, 'selectedIds');\n\n  return useMemo(() => {\n    return editor.api.blocks<TElement>({\n      at: [],\n      match: (n) => !!n.id && selectedIds?.has(n.id as string),\n    });\n  }, [editor, selectedIds]);\n}\n\nexport function useBlockSelectionFragment() {\n  const nodes = useBlockSelectionNodes();\n\n  return useMemo(() => nodes.map(([node]) => node), [nodes]);\n}\n\nexport function useBlockSelectionFragmentProp(\n  options?: Omit<EditorPropOptions, 'nodes'>\n) {\n  const editor = useEditorRef();\n  const fragment = useBlockSelectionFragment();\n\n  return useMemo(\n    () => editor.api.prop({ nodes: fragment, ...options }),\n    [editor.api, fragment, options]\n  );\n}\n","import React from 'react';\n\nimport type { TRange, UnknownObject } from 'platejs';\n\nimport {\n  useEditorContainerRef,\n  useEditorRef,\n  useIsomorphicLayoutEffect,\n  usePluginOption,\n} from 'platejs/react';\n\nimport type { CursorOverlayState, CursorState, SelectionRect } from '../types';\n\nimport { CursorOverlayPlugin } from '../CursorOverlayPlugin';\nimport { getCursorOverlayState } from '../queries/getCursorOverlayState';\nimport { getSelectionRects } from '../queries/getSelectionRects';\nimport { useRefreshOnResize } from './useRefreshOnResize';\n\nexport type UseCursorOverlayOptions = {\n  /**\n   * Minimum width of a selection rect.\n   *\n   * @default 1\n   */\n  minSelectionWidth?: number;\n  /**\n   * Whether to refresh the cursor overlay positions on container resize.\n   *\n   * @default true\n   */\n  refreshOnResize?: boolean;\n};\n\nexport const FROZEN_EMPTY_ARRAY = Object.freeze(\n  []\n) as unknown as SelectionRect[];\n\nexport const useCursorOverlay = <TCursorData extends UnknownObject>({\n  minSelectionWidth = 1,\n  refreshOnResize = true,\n}: UseCursorOverlayOptions = {}): {\n  cursors: CursorOverlayState<TCursorData>[];\n  refresh: () => void;\n} => {\n  const editor = useEditorRef();\n  const containerRef = useEditorContainerRef();\n\n  const cursorStates = usePluginOption(\n    CursorOverlayPlugin,\n    'cursors'\n  ) as Record<string, CursorState<TCursorData>>;\n\n  const selectionRectCache = React.useRef<WeakMap<TRange, SelectionRect[]>>(\n    new WeakMap()\n  );\n\n  const [selectionRects, setSelectionRects] = React.useState<\n    Record<string, SelectionRect[]>\n  >({});\n\n  const updateSelectionRects = React.useCallback(() => {\n    // We have a container ref but the ref is null => container\n    // isn't mounted to we can't calculate the selection rects.\n    if (!containerRef?.current) return;\n    if (!cursorStates) return;\n\n    let xOffset = 0;\n    let yOffset = 0;\n\n    if (containerRef) {\n      const contentRect = containerRef.current!.getBoundingClientRect();\n      xOffset = contentRect.x;\n      yOffset = contentRect.y;\n      yOffset -= containerRef.current.scrollTop;\n    }\n\n    let selectionRectsChanged =\n      Object.keys(selectionRects).length !== Object.keys(cursorStates).length;\n\n    const getCachedSelectionRects = ({\n      cursor,\n    }: {\n      cursor: CursorState<TCursorData>;\n    }) => {\n      const range = cursor.selection;\n\n      if (!range) {\n        return FROZEN_EMPTY_ARRAY;\n      }\n\n      const cached = selectionRectCache.current.get(range);\n\n      if (cached) {\n        return cached;\n      }\n\n      const rects = getSelectionRects(editor, { range, xOffset, yOffset }).map(\n        (rect) => {\n          // Handle collapsed selection (cursor) positioning\n          if (rect.width < minSelectionWidth) {\n            return {\n              ...rect,\n              // Adjust left position to account for minimum width\n              left: rect.left - (minSelectionWidth - rect.width) / 2,\n              width: minSelectionWidth,\n            };\n          }\n\n          return rect;\n        }\n      );\n\n      selectionRectsChanged = true;\n      selectionRectCache.current.set(range, rects);\n\n      return rects;\n    };\n\n    const updated: Record<string, SelectionRect[]> = Object.fromEntries(\n      Object.entries(cursorStates).map(([key, cursor]) => [\n        key,\n        getCachedSelectionRects({\n          cursor,\n        }),\n      ])\n    );\n\n    if (selectionRectsChanged) {\n      setSelectionRects(updated);\n    }\n  }, [containerRef, cursorStates, editor, selectionRects, minSelectionWidth]);\n\n  // Update selection rects after paint\n\n  useIsomorphicLayoutEffect(() => {\n    updateSelectionRects();\n  });\n\n  const cursors = React.useMemo(\n    () =>\n      getCursorOverlayState({\n        cursors: cursorStates,\n        selectionRects,\n      }),\n    [cursorStates, selectionRects]\n  );\n\n  const { refresh } = useRefreshOnResize({\n    containerRef,\n    refreshOnResize,\n    selectionRectCache,\n  });\n\n  return { cursors, refresh };\n};\n","import { useEffect } from 'react';\n\nimport type { PluginConfig } from 'platejs';\n\nimport { KEYS } from 'platejs';\nimport {\n  type DOMHandler,\n  createTPlatePlugin,\n  usePluginOption,\n} from 'platejs/react';\n\nimport type { CursorData, CursorState } from './types';\n\nimport { BlockSelectionPlugin } from './BlockSelectionPlugin';\n\nexport type CursorOverlayConfig = PluginConfig<\n  'cursorOverlay',\n  {\n    cursors: Record<string, CursorState<CursorData>>;\n  },\n  {\n    cursorOverlay: {\n      addCursor: (\n        id: string,\n        cursor: Omit<CursorState<CursorData>, 'id'>\n      ) => void;\n      removeCursor: (id: (string & {}) | 'drag' | 'selection') => void;\n    };\n  }\n>;\n\nconst getRemoveCursorHandler =\n  (id: string): DOMHandler<CursorOverlayConfig> =>\n  ({ api }) => {\n    api.cursorOverlay.removeCursor(id);\n  };\n\nexport const CursorOverlayPlugin = createTPlatePlugin<CursorOverlayConfig>({\n  key: KEYS.cursorOverlay,\n  editOnly: {\n    render: false,\n  },\n  options: { cursors: {} },\n})\n  .extendApi<CursorOverlayConfig['api']['cursorOverlay']>(\n    ({ editor, plugin }) => ({\n      addCursor: (id, cursor) => {\n        const newCursors = { ...editor.getOptions(plugin).cursors };\n        newCursors[id] = {\n          id,\n          ...cursor,\n        };\n        editor.setOption(plugin, 'cursors', newCursors);\n      },\n      removeCursor: (id) => {\n        const newCursors = { ...editor.getOptions(plugin).cursors };\n\n        if (!newCursors[id]) return;\n\n        delete newCursors[id];\n        editor.setOption(plugin, 'cursors', newCursors);\n      },\n    })\n  )\n  .overrideEditor(({ api, editor, getOptions, tf: { setSelection } }) => ({\n    transforms: {\n      setSelection(props) {\n        if (getOptions().cursors?.selection) {\n          setTimeout(() => {\n            api.cursorOverlay.addCursor('selection', {\n              selection: editor.selection,\n            });\n          }, 0);\n        }\n\n        setSelection(props);\n      },\n    },\n  }))\n  .extend(() => ({\n    handlers: {\n      onBlur: ({ api, editor, event }) => {\n        if (!editor.selection) return;\n\n        const relatedTarget = event.relatedTarget as HTMLElement;\n        const enabled = relatedTarget?.dataset?.plateFocus === 'true';\n\n        if (!enabled) return;\n\n        api.cursorOverlay.addCursor('selection', {\n          selection: editor.selection,\n        });\n      },\n      onDragEnd: getRemoveCursorHandler('drag') as any,\n      onDragLeave: getRemoveCursorHandler('drag') as any,\n      onDragOver: ({ api, editor, event }) => {\n        if (\n          !editor.plugins.dnd ||\n          editor.getOptions({ key: KEYS.dnd }).isDragging\n        ) {\n          return;\n        }\n\n        const types = event.dataTransfer?.types || [];\n\n        if (types.some((type) => type.startsWith('Files'))) return;\n\n        const range = editor.api.findEventRange(event);\n\n        if (!range) return;\n\n        api.cursorOverlay.addCursor('drag', {\n          selection: range,\n        });\n      },\n      onDrop: getRemoveCursorHandler('drag') as any,\n      onFocus: getRemoveCursorHandler('selection') as any,\n    },\n    useHooks: ({ api, setOption }) => {\n      const isSelecting = usePluginOption(BlockSelectionPlugin, 'isSelecting');\n\n      useEffect(() => {\n        if (isSelecting) {\n          setTimeout(() => {\n            api.cursorOverlay.removeCursor('selection');\n          }, 0);\n        }\n      }, [isSelecting, setOption, api.cursorOverlay]);\n    },\n  }));\n","import type { TRange } from 'platejs';\n\nimport { RangeApi } from 'platejs';\n\nimport type { CaretPosition, SelectionRect } from '../types';\n\n/** Get the caret position of a range from selectionRects. */\nexport const getCaretPosition = (\n  selectionRects: SelectionRect[],\n  range: TRange\n): CaretPosition | null => {\n  const isCollapsed = range && RangeApi.isCollapsed(range);\n  const isBackward = range && RangeApi.isBackward(range);\n  const anchorRect = selectionRects[isBackward ? 0 : selectionRects.length - 1];\n\n  if (!anchorRect) {\n    return null;\n  }\n\n  return {\n    height: anchorRect.height,\n    left: anchorRect.left + (isBackward || isCollapsed ? 0 : anchorRect.width),\n    top: anchorRect.top,\n  };\n};\n","import type { UnknownObject } from 'platejs';\n\nimport type { CursorOverlayState, CursorState, SelectionRect } from '../types';\n\nimport { FROZEN_EMPTY_ARRAY } from '../hooks';\nimport { getCaretPosition } from './getCaretPosition';\n\n/** Get cursor overlay state from selection rects. */\nexport const getCursorOverlayState = <\n  TCursorData extends UnknownObject = UnknownObject,\n>({\n  cursors: cursorStates,\n  selectionRects,\n}: {\n  cursors: Record<string, CursorState<TCursorData>>;\n  selectionRects: Record<string, SelectionRect[]>;\n}): CursorOverlayState<TCursorData>[] => {\n  if (!cursorStates) return [];\n\n  return Object.entries(cursorStates).map(([key, cursorState]) => {\n    const selection = cursorState?.selection ?? null;\n    const rects = selectionRects[key] ?? FROZEN_EMPTY_ARRAY;\n\n    const caretPosition = selection ? getCaretPosition(rects, selection) : null;\n\n    return {\n      ...cursorState,\n      caretPosition,\n      selection,\n      selectionRects: rects,\n    };\n  });\n};\n","import { type Editor, type TRange, PathApi, RangeApi, TextApi } from 'platejs';\n\nimport type { SelectionRect } from '../types';\n\nexport const getSelectionRects = (\n  editor: Editor,\n  {\n    range,\n    xOffset,\n    yOffset,\n  }: {\n    range: TRange;\n    xOffset: number;\n    yOffset: number;\n  }\n): SelectionRect[] => {\n  const [start, end] = RangeApi.edges(range);\n  const domRange = editor.api.toDOMRange(range);\n\n  if (!domRange) {\n    return [];\n  }\n\n  const selectionRects: SelectionRect[] = [];\n  const textEntries = editor.api.nodes({\n    at: range,\n    match: TextApi.isText,\n  });\n\n  for (const [textNode, textPath] of textEntries) {\n    const domNode = editor.api.toDOMNode(textNode);\n\n    // Fix: failed to execute 'selectNode' on 'Range': the given Node has no parent\n    if (!domNode?.parentElement) {\n      return [];\n    }\n\n    const isStartNode = PathApi.equals(textPath, start.path);\n    const isEndNode = PathApi.equals(textPath, end.path);\n\n    let clientRects: DOMRectList | null = null;\n\n    if (isStartNode || isEndNode) {\n      const nodeRange = document.createRange();\n\n      nodeRange.selectNode(domNode);\n\n      if (isStartNode) {\n        nodeRange.setStart(domRange.startContainer, domRange.startOffset);\n      }\n      if (isEndNode) {\n        nodeRange.setEnd(domRange.endContainer, domRange.endOffset);\n      }\n\n      clientRects = nodeRange.getClientRects();\n    } else {\n      clientRects = domNode.getClientRects();\n    }\n\n    for (let i = 0; i < clientRects.length; i++) {\n      const clientRect = clientRects.item(i);\n\n      if (!clientRect) {\n        continue;\n      }\n\n      selectionRects.push({\n        height: clientRect.height,\n        left: clientRect.left - xOffset,\n        top: clientRect.top - yOffset,\n        width: clientRect.width,\n      });\n    }\n  }\n\n  return selectionRects;\n};\n","import React from 'react';\n\nimport type { TRange } from 'platejs';\n\nimport type { SelectionRect } from '../types';\n\nimport { useRequestReRender } from './useRequestReRender';\n\nexport interface UseRefreshOnResizeOptions {\n  selectionRectCache: React.MutableRefObject<WeakMap<TRange, SelectionRect[]>>;\n  containerRef?: React.RefObject<HTMLElement | null>;\n  refreshOnResize?: boolean;\n}\n\nexport const useRefreshOnResize = ({\n  containerRef,\n  refreshOnResize,\n  selectionRectCache,\n}: UseRefreshOnResizeOptions) => {\n  const requestReRender = useRequestReRender();\n\n  // Reset the selection rect cache and request re-render.\n  const refresh = React.useCallback(\n    (sync = false) => {\n      selectionRectCache.current = new WeakMap();\n      requestReRender(sync);\n    },\n    [requestReRender, selectionRectCache]\n  );\n\n  // Refresh on container resize\n  React.useEffect(() => {\n    if (!refreshOnResize || !containerRef?.current) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver(() => refresh());\n    resizeObserver.observe(containerRef.current);\n\n    return () => resizeObserver.disconnect();\n  }, [containerRef, refresh, refreshOnResize]);\n\n  return {\n    refresh,\n  };\n};\n","import React from 'react';\n\nexport const useRequestReRender = () => {\n  const [, setUpdateCounter] = React.useState(0);\n  const animationFrameRef = React.useRef<number | null>(null);\n\n  const requestReRender = React.useCallback((immediate = false) => {\n    if (animationFrameRef.current && !immediate) {\n      return;\n    }\n    if (!immediate) {\n      animationFrameRef.current = requestAnimationFrame(() => {\n        setUpdateCounter((state) => state + 1);\n        animationFrameRef.current = null;\n      });\n\n      return;\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n\n    setUpdateCounter((state) => state + 1);\n  }, []);\n\n  React.useEffect(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  });\n\n  React.useEffect(\n    () => () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    },\n    []\n  );\n\n  return requestReRender;\n};\n","import {\n  type PlateEditor,\n  useEditorSelector,\n  usePluginOption,\n} from 'platejs/react';\n\nimport { isSelecting } from '../../lib';\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const isSelectingOrFocused = (editor: PlateEditor) => {\n  return isSelecting(editor) || editor.api.isFocused();\n};\n\nexport const useIsSelecting = () => {\n  const isSelectingSome = usePluginOption(\n    BlockSelectionPlugin,\n    'isSelectingSome'\n  );\n  const selectionExpanded = useEditorSelector((editor) => {\n    return editor.api.isExpanded();\n  }, []);\n\n  return selectionExpanded || isSelectingSome;\n};\n","export const extractSelectableIds = (els: Element[]) => {\n  return els\n    .map((v) => (v as HTMLElement).dataset.blockId)\n    .filter(Boolean) as string[];\n};\n\nexport const extractSelectableId = (el: Element) =>\n  (el as HTMLElement).dataset.blockId;\n","export const querySelectorSelectable = (id: string) => {\n  return document.querySelector(`.slate-selectable[data-block-id=\"${id}\"]`);\n};\n\nexport const querySelectorAllSelectable = () => {\n  return document.querySelectorAll(`.slate-selectable`);\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { BlockSelectionPlugin } from '../react';\n\nexport const isSelecting = (editor: PlateEditor) => {\n  const isSelectingSome = editor.getOption(\n    BlockSelectionPlugin,\n    'isSelectingSome'\n  );\n  const selectionExpanded = editor.api.isExpanded();\n\n  return selectionExpanded || isSelectingSome;\n};\n","import React from 'react';\n\nimport { type TElement, KEYS } from 'platejs';\nimport { useEditorPlugin } from 'platejs/react';\n\nimport { SelectionArea } from '../../internal';\nimport { extractSelectableIds } from '../../lib';\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const useSelectionArea = () => {\n  const { api, editor, getOption, getOptions, setOption } =\n    useEditorPlugin(BlockSelectionPlugin);\n\n  const { areaOptions } = getOptions();\n\n  const areaRef = React.useRef<{\n    ids: Set<string>;\n  }>({\n    ids: new Set(),\n  });\n\n  const trsRef = React.useRef<{\n    ids: Set<string>;\n  }>({\n    ids: new Set(),\n  });\n\n  const onStart = () => {\n    if (editor.api.isFocused()) {\n      editor.tf.blur();\n    }\n    if (editor.selection) {\n      editor.tf.deselect();\n    }\n\n    setOption('isSelectionAreaVisible', true);\n  };\n\n  React.useEffect(() => {\n    const selection = new SelectionArea({\n      boundaries: `#${editor.meta.uid}`,\n      container: `#${editor.meta.uid}`,\n      document: window.document,\n      selectables: `#${editor.meta.uid} .slate-selectable`,\n      selectionAreaClass: 'slate-selection-area',\n      ...areaOptions,\n    })\n      .on('beforestart', () => {\n        setOption('isSelecting', false);\n      })\n      .on('start', ({ event }) => {\n        onStart();\n\n        if (!event?.shiftKey) {\n          selection.clearSelection();\n          api.blockSelection.clear();\n        }\n      })\n      .on('move', ({ store: { changed } }) => {\n        if (!getOptions().isSelectionAreaVisible) {\n          onStart();\n        }\n        const apply = () => {\n          if (changed.added.length === 0 && changed.removed.length === 0)\n            return;\n\n          const next = new Set(getOptions().selectedIds);\n          extractSelectableIds(changed.removed).forEach((id) => {\n            next.delete(id);\n            areaRef.current.ids.delete(id);\n          });\n\n          const added = new Set(extractSelectableIds(changed.added));\n          added.forEach((id) => {\n            const block = editor.api.block({\n              at: [],\n              match: (n) => !!n.id && n.id === id,\n            });\n\n            if (!block) return;\n            if (block[0].type === KEYS.table) return;\n\n            if (block[1].length === 1) {\n              next.add(id);\n              areaRef.current.ids.add(id);\n\n              return;\n            }\n\n            const hasAncestor = editor.api.block({\n              above: true,\n              at: block[1],\n              match: (n) => !!n.id && areaRef.current.ids.has(n.id as string),\n            });\n\n            if (!hasAncestor) {\n              next.add(id);\n              areaRef.current.ids.add(id);\n            }\n          });\n\n          // TODO: support nested blocks\n\n          setOption('selectedIds', next);\n        };\n\n        const normalize = () => {\n          const next = new Set(getOption('selectedIds'));\n          const ids = Array.from(next);\n\n          const isTableElement = (element: TElement) =>\n            element.type === KEYS.table ||\n            element.type === KEYS.tr ||\n            element.type === KEYS.th;\n\n          const isTableRowElement = (element: TElement) =>\n            element.type === KEYS.tr || element.type === KEYS.th;\n\n          const getBlockById = (id: string) =>\n            editor.api.block({\n              at: [],\n              match: (n) => !!n.id && n.id === id,\n            });\n\n          const isTableOnlySelection = ids.every((id) => {\n            const block = getBlockById(id);\n            if (!block) return false;\n\n            if (block[1].length >= 3) {\n              return true;\n            }\n\n            return isTableElement(block[0]);\n          });\n\n          if (isTableOnlySelection) {\n            ids.some((id) => {\n              const block = getBlockById(id);\n              if (!block || block[0].type !== KEYS.table) return false;\n\n              next.delete(id);\n              trsRef.current.ids.forEach((trId) => {\n                next.add(trId);\n              });\n              trsRef.current.ids.clear();\n              return true;\n            });\n          } else {\n            ids.some((id) => {\n              const block = getBlockById(id);\n              if (!block || !isTableRowElement(block[0])) return false;\n\n              const table = editor.api.block({\n                above: true,\n                at: block[1],\n              });\n              if (!table) return false;\n\n              const tableRowIds = table[0].children.map(\n                (tr) => tr.id as string\n              );\n\n              next.add(table[0].id as string);\n              tableRowIds.forEach((trId) => {\n                if (next.has(trId)) {\n                  trsRef.current.ids.add(trId);\n                  next.delete(trId);\n                }\n              });\n\n              return true;\n            });\n          }\n\n          setOption('selectedIds', next);\n        };\n\n        apply();\n        normalize();\n      })\n      .on('stop', () => {\n        areaRef.current = {\n          ids: new Set(),\n        };\n        trsRef.current = {\n          ids: new Set(),\n        };\n        setOption('isSelectionAreaVisible', false);\n      });\n\n    return () => selection.destroy();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n};\n","type AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n  private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n  public emit = this.dispatchEvent;\n\n  public off = this.removeEventListener;\n\n  public on = this.addEventListener;\n\n  public addEventListener<K extends keyof Events>(\n    event: K,\n    cb: Events[K]\n  ): this {\n    const set = this._listeners.get(event) ?? new Set();\n    this._listeners.set(event, set);\n    set.add(cb as AnyFunction);\n\n    return this;\n  }\n\n  // Let's also support on, off and emit like node\n  public dispatchEvent<K extends keyof Events>(\n    event: K,\n    ...data: Parameters<Events[K]>\n  ): unknown {\n    let ok = true;\n\n    for (const cb of this._listeners.get(event) ?? []) {\n      ok = cb(...data) !== false && ok;\n    }\n\n    return ok;\n  }\n  public removeEventListener<K extends keyof Events>(\n    event: K,\n    cb: Events[K]\n  ): this {\n    this._listeners.get(event)?.delete(cb as AnyFunction);\n\n    return this;\n  }\n  public unbindAllListeners(): void {\n    this._listeners.clear();\n  }\n}\n","const unitify = (val: number | string, unit = 'px'): string => {\n  return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {any}\n */\nexport function css(\n  { style }: HTMLElement,\n  attr: Partial<Record<keyof CSSStyleDeclaration, number | string>> | string,\n  val?: number | string\n): void {\n  if (typeof attr === 'object') {\n    for (const [key, value] of Object.entries(attr)) {\n      value !== undefined && (style[key as any] = unitify(value));\n    }\n  } else if (val !== undefined) {\n    style[attr as any] = unitify(val);\n  }\n}\n","export type EventBindingArgs = [\n  (EventTarget | undefined) | (EventTarget | undefined)[],\n  string[] | string,\n  AnyFunction,\n  Record<string, unknown>?,\n];\n\ntype AnyFunction = (...arg: any) => any;\n\ntype Method = 'addEventListener' | 'removeEventListener';\n\nconst eventListener =\n  (method: Method) =>\n  (\n    items: (EventTarget | undefined) | (EventTarget | undefined)[],\n    events: string[] | string,\n    fn: AnyFunction,\n    options = {}\n  ): EventBindingArgs => {\n    // Normalize array\n    if (items instanceof HTMLCollection || items instanceof NodeList) {\n      items = Array.from(items);\n    } else if (!Array.isArray(items)) {\n      items = [items];\n    }\n    if (!Array.isArray(events)) {\n      events = [events];\n    }\n\n    for (const el of items) {\n      if (el) {\n        for (const ev of events) {\n          el[method](ev, fn as EventListener, { capture: false, ...options });\n        }\n      }\n    }\n\n    return [items, events, fn, options];\n  };\n\n/**\n * Add event(s) to element(s).\n *\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @returns Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n *\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @returns Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n *\n * @param evt\n */\nexport const simplifyEvent = (\n  evt: any\n): {\n  target: HTMLElement;\n  x: number;\n  y: number;\n} => {\n  const { clientX, clientY, target } = evt.touches?.[0] ?? evt;\n\n  return { target, x: clientX, y: clientY };\n};\n","export type Intersection = 'center' | 'cover' | 'touch';\n\nexport function intersectsScroll(\n  a: DOMRect,\n  b: DOMRect,\n  // TODO\n  _: Intersection = 'touch',\n  container: HTMLElement\n): boolean {\n  const containerRect = container.getBoundingClientRect();\n  const scrollLeft = container.scrollLeft;\n  const scrollTop = container.scrollTop;\n\n  // 198 is container to left\n  return (\n    a.right >= b.left - containerRect.left &&\n    a.left + containerRect.left <= b.right + scrollLeft &&\n    // 94 is container to top\n    a.bottom - scrollTop >= b.top - containerRect.top &&\n    a.top <= b.bottom - containerRect.top + scrollTop\n  );\n}\n","export type SelectAllSelectors =\n  | Element\n  | readonly (Element | string)[]\n  | string;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n *\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(\n  selector: SelectAllSelectors,\n  doc: Document = document\n): Element[] {\n  const list = Array.isArray(selector) ? selector : [selector];\n  let nodes: Element[] = [];\n\n  for (let i = 0, l = list.length; i < l; i++) {\n    const item = list[i];\n\n    if (typeof item === 'string') {\n      /**\n       * We can't use the spread operator here as with large amounts of elements\n       * we'll get a \"Maximum call stack size exceeded\"-error.\n       */\n      nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n    } else if (item instanceof Element) {\n      nodes.push(item);\n    }\n  }\n\n  return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean =>\n  matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","export interface Frames<F extends AnyFunction = AnyFunction> {\n  cancel: () => void;\n\n  next: (...args: Parameters<F>) => void;\n}\n\ntype AnyFunction = (...args: any[]) => void;\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n  let previousArgs: Parameters<F>;\n  let frameId = -1;\n  let lock = false;\n\n  return {\n    cancel() {\n      cancelAnimationFrame(frameId);\n      lock = false;\n    },\n    next(...args: Parameters<F>): void {\n      previousArgs = args;\n\n      if (!lock) {\n        lock = true;\n        frameId = requestAnimationFrame(() => {\n          fn(...previousArgs);\n          lock = false;\n        });\n      }\n    },\n  };\n};\n","import type { Trigger } from '../types';\n\n/**\n * Determines whether a MouseEvent should execute until completion depending on\n * which button and modifier(s) are active for the MouseEvent. The Event will\n * execute to completion if ANY of the triggers \"matches\"\n *\n * @param event MouseEvent that should be checked\n * @param triggers A list of Triggers that signify that the event should execute\n *   until completion\n * @returns Whether the MouseEvent should execute until completion\n */\nexport function shouldTrigger(event: MouseEvent, triggers: Trigger[]): boolean {\n  for (const trigger of triggers) {\n    // The trigger requires only a specific button to be pressed\n    if (typeof trigger === 'number') {\n      return event.button === trigger;\n    }\n    // The trigger requires a specific button to be pressed AND some modifiers\n    if (typeof trigger === 'object') {\n      const reqButtonIsPressed = trigger.button === event.button;\n\n      const allReqModifiersArePressed = trigger.modifiers.every((modifier) => {\n        switch (modifier) {\n          case 'alt': {\n            return event.altKey;\n          }\n          case 'ctrl': {\n            return event.ctrlKey || event.metaKey;\n          }\n          case 'shift': {\n            return event.shiftKey;\n          }\n        }\n      });\n\n      return reqButtonIsPressed && allReqModifiersArePressed;\n    }\n  }\n\n  // By default, we do not process the event\n  return false;\n}\n","'use client';\n\nimport type {\n  AreaLocation,\n  Coordinates,\n  PartialSelectionOptions,\n  ScrollEvent,\n  SelectionEvents,\n  SelectionOptions,\n  SelectionStore,\n} from './types';\n\nimport { EventTarget } from './EventEmitter';\nimport {\n  type Frames,\n  type SelectAllSelectors,\n  css,\n  frames,\n  intersectsScroll,\n  isSafariBrowser,\n  isTouchDevice,\n  off,\n  on,\n  selectAll,\n  shouldTrigger,\n  simplifyEvent,\n} from './utils';\n\n// Some var shorting for better compression and readability\nconst { abs, ceil, max, min } = Math;\n\nexport class SelectionArea extends EventTarget<SelectionEvents> {\n  // Area element and clipping element\n  private readonly _area: HTMLElement;\n  private _areaClientLocation: AreaLocation = { x1: 0, x2: 0, y1: 0, y2: 0 };\n\n  // Dynamically constructed area rect\n  private _areaLocation: AreaLocation = { x1: 0, x2: 0, y1: 0, y2: 0 };\n\n  // Caches the position of the selection-area\n  private readonly _areaRect = new DOMRect();\n\n  private _container?: Element;\n  private _containerRect?: DOMRect;\n  private _frame: Frames;\n  private _initScrollDelta: Coordinates = { x: 0, y: 0 };\n  private _latestElement?: Element;\n  // Options\n  private readonly _options: SelectionOptions;\n\n  // Is getting set on movement.\n  private _scrollAvailable = true;\n\n  // The scroll distance of scrollElement (body or html) relative to the initial scroll position\n  private _scrollDelta: Coordinates = { x: 0, y: 0 };\n  // If a single click is being performed.\n  private _scrollingActive = false;\n\n  private _scrollSpeed: Coordinates = { x: 0, y: 0 };\n  private _selectables: Element[] = [];\n\n  // Selection store\n  private _selection: SelectionStore = {\n    changed: {\n      added: [], // Added elements since last selection\n      removed: [], // Removed elements since last selection\n    },\n    selected: [],\n    stored: [],\n    touched: [],\n  };\n\n  // It's a single-click until the user dragged the mouse.\n  private _singleClick = true;\n  private wheelTimer: NodeJS.Timeout | null = null;\n\n  disable = this._bindStartEvents.bind(this, false);\n\n  enable = this._bindStartEvents;\n\n  constructor(opt: PartialSelectionOptions) {\n    super();\n\n    this._options = {\n      boundaries: ['html'],\n      container: 'body',\n      document: window.document,\n      selectables: [],\n      selectionAreaClass: 'selection-area',\n      startAreas: ['html'],\n      ...opt,\n\n      behaviour: {\n        // TODO: not implemented\n        intersect: 'touch',\n        overlap: 'invert',\n        triggers: [0],\n        ...opt.behaviour,\n        scrolling: {\n          manualSpeed: 750,\n          speedDivider: 0.7,\n          ...opt.behaviour?.scrolling,\n          startScrollMargins: {\n            x: 20,\n            y: 40,\n            ...opt.behaviour?.scrolling?.startScrollMargins,\n          },\n        },\n        startThreshold: opt.behaviour?.startThreshold\n          ? typeof opt.behaviour.startThreshold === 'number'\n            ? opt.behaviour.startThreshold\n            : { x: 4, y: 4, ...opt.behaviour.startThreshold }\n          : { x: 4, y: 4 },\n      },\n\n      features: {\n        range: true,\n        touch: true,\n        ...opt.features,\n        singleTap: {\n          allow: true,\n          intersect: 'native',\n          ...opt.features?.singleTap,\n        },\n      },\n    };\n\n    // Bind locale functions to instance\n\n    for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n      if (typeof (this as any)[key] === 'function') {\n        (this as any)[key] = (this as any)[key].bind(this);\n      }\n    }\n\n    const { document, selectionAreaClass } = this._options;\n    this._area = document.createElement('div');\n    // this._clippingElement = document.createElement('div');\n    // this._clippingElement.appendChild(this._area);\n\n    this._area.classList.add(selectionAreaClass);\n    // selectionContainerClass && this._clippingElement.classList.add(selectionContainerClass);\n\n    css(this._area, {\n      left: 0,\n      position: 'absolute',\n      top: 0,\n      willChange: 'top, left, bottom, right, width, height',\n    });\n\n    // css(this._clippingElement, {\n    //     overflow: 'hidden',\n    //     height:\"100%\",\n    //     position: 'absolute',\n    //     transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n    //     pointerEvents: 'none',\n    //     zIndex: '1'\n    // });\n\n    this._frame = frames((evt: MouseEvent | TouchEvent) => {\n      this._recalculateSelectionAreaRect();\n      this._updateElementSelection();\n      this._emitEvent('move', evt);\n      this._redrawSelectionArea();\n    });\n\n    this.enable();\n  }\n\n  _bindStartEvents(activate = true): void {\n    const { document, features } = this._options;\n    const fn = activate ? on : off;\n\n    fn(document, 'mousedown', this._onTapStart);\n\n    features.touch &&\n      fn(document, 'touchstart', this._onTapStart, {\n        passive: false,\n      });\n  }\n\n  _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n    const {\n      behaviour: { startThreshold },\n      document,\n    } = this._options;\n    const { x1, y1 } = this._areaLocation; // Coordinates of first \"tap\"\n    const { x1: clientX, y1: clientY } = this._areaClientLocation;\n    const { x, y } = simplifyEvent(evt);\n\n    // Check pixel threshold\n    if (\n      // Single number for both coordinates\n      (typeof startThreshold === 'number' &&\n        abs(x + y - (clientX + clientY)) >= startThreshold) ||\n      // Different x and y threshold\n      (typeof startThreshold === 'object' &&\n        abs(x - x1) >= (startThreshold as Coordinates).x) ||\n      abs(y - y1) >= (startThreshold as Coordinates).y\n    ) {\n      off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {\n        passive: false,\n      });\n\n      if (this._emitEvent('beforedrag', evt) === false) {\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n\n        return;\n      }\n\n      on(document, ['mousemove', 'touchmove'], this._onTapMove, {\n        passive: false,\n      });\n\n      // Make area element visible\n      css(this._area, 'display', 'block');\n\n      // Append selection-area to the dom\n      this._container!.append(this._area);\n\n      this.resolveSelectables();\n\n      // An action is recognized as single-select until the user performed a multi-selection\n      this._singleClick = false;\n\n      on(this._container, 'wheel', this._manualScroll, { passive: true });\n\n      // Re-setup selection area and fire event\n      this._setupSelectionArea();\n      this._emitEvent('start', evt);\n      this._onTapMove(evt);\n    }\n\n    this._handleMoveEvent(evt);\n  }\n\n  _emitEvent(\n    name: keyof SelectionEvents,\n    evt: MouseEvent | TouchEvent | null\n  ): unknown {\n    return this.emit(name, {\n      event: evt,\n      selection: this,\n      store: this._selection,\n    });\n  }\n\n  _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n    const { features } = this._options;\n\n    /**\n     * - Prevent auto-refresh for when pulling down on touch devices.\n     * - Prevent auto-scroll by the browser when on safari and scrolling is\n     *   handled by viselect.\n     */\n    if (\n      (features.touch && isTouchDevice()) ||\n      (this._scrollAvailable && isSafariBrowser())\n    ) {\n      evt.preventDefault(); // Prevent swipe-down refresh\n    }\n  }\n\n  _keepSelection(): void {\n    const { _options, _selection } = this;\n    const { changed, selected, stored, touched } = _selection;\n    const addedElements = selected.filter((el) => !stored.includes(el));\n\n    switch (_options.behaviour.overlap) {\n      case 'drop': {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !touched.includes(el)), // Elements not touched\n        ];\n\n        break;\n      }\n      case 'invert': {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !changed.removed.includes(el)), // Elements not removed from selection\n        ];\n\n        break;\n      }\n      case 'keep': {\n        _selection.stored = [\n          ...stored,\n          ...selected.filter((el) => !stored.includes(el)), // Newly added\n        ];\n\n        break;\n      }\n    }\n  }\n\n  _manualScroll(evt: ScrollEvent): void {\n    this.wheelTimer && clearTimeout(this.wheelTimer);\n\n    const { x, y } = simplifyEvent(evt);\n\n    this.wheelTimer = setTimeout(() => {\n      this._areaClientLocation.x2 = x;\n      this._areaClientLocation.y2 = y;\n\n      const Ry = y - this._containerRect!.top;\n      const Rx = x - this._containerRect!.left;\n      this._areaLocation.x2 = Rx + this._container!.scrollLeft;\n      this._areaLocation.y2 = Ry + this._container!.scrollTop;\n      this._frame.next(null);\n    }, 100);\n  }\n\n  _onScroll(evt: ScrollEvent): void {\n    const { document } = this._options;\n\n    this.wheelTimer && clearTimeout(this.wheelTimer);\n\n    const { x, y } = simplifyEvent(evt);\n\n    this.wheelTimer = setTimeout(() => {\n      this._areaClientLocation.x2 = x;\n      this._areaClientLocation.y2 = y;\n\n      const deltaY =\n        y -\n        this._containerRect!.top +\n        this._container!.scrollTop +\n        document.scrollingElement!.scrollTop -\n        this._initScrollDelta.y;\n\n      const deltaX =\n        x -\n        this._containerRect!.left +\n        this._container!.scrollLeft +\n        document.scrollingElement!.scrollLeft;\n\n      this._scrollDelta.y =\n        document.scrollingElement!.scrollTop - this._initScrollDelta.y;\n\n      this._scrollDelta.x =\n        document.scrollingElement!.scrollLeft - this._initScrollDelta.x;\n\n      this._areaLocation.y2 = deltaY;\n      this._areaLocation.x2 = deltaX;\n      this._frame.next(null);\n    }, 100);\n  }\n\n  _onSingleTap(evt: MouseEvent | TouchEvent): void {\n    const {\n      range,\n      singleTap: { intersect },\n    } = this._options.features;\n    const e = simplifyEvent(evt);\n    let target;\n\n    if (intersect === 'native') {\n      target = e.target;\n    } else if (intersect === 'touch') {\n      this.resolveSelectables();\n\n      const { x, y } = e;\n      target = this._selectables.find((v) => {\n        const { bottom, left, right, top } = v.getBoundingClientRect();\n\n        return x < right && x > left && y < bottom && y > top;\n      });\n    }\n    if (!target) {\n      return;\n    }\n\n    /**\n     * Resolve selectables again. If the user started in a scrollable area they\n     * will be reduced to the current area. Prevent the exclusion of these if a\n     * range-selection gets performed.\n     */\n    this.resolveSelectables();\n\n    // Traverse dom upwards to check if target is selectable\n    while (!this._selectables.includes(target)) {\n      if (!target.parentElement) {\n        return;\n      }\n\n      target = target.parentElement;\n    }\n\n    // Grab current store first in case it gets set back\n    const { stored } = this._selection;\n    this._emitEvent('start', evt);\n\n    if (evt.shiftKey && range && this._latestElement) {\n      const reference = this._latestElement;\n\n      // Resolve correct range\n      const [preceding, following] =\n        reference.compareDocumentPosition(target) & 4\n          ? [target, reference]\n          : [reference, target];\n\n      const rangeItems = [\n        ...this._selectables.filter(\n          (el) =>\n            el.compareDocumentPosition(preceding) & 4 &&\n            el.compareDocumentPosition(following) & 2\n        ),\n        preceding,\n        following,\n      ];\n\n      this.select(rangeItems);\n      this._latestElement = reference; // latestElement is by default cleared in .select()\n    } else if (\n      stored.includes(target) &&\n      (stored.length === 1 ||\n        evt.ctrlKey ||\n        stored.every((v) => this._selection.stored.includes(v)))\n    ) {\n      this.deselect(target);\n    } else {\n      this.select(target);\n      this._latestElement = target;\n    }\n  }\n\n  _onTapMove(evt: MouseEvent | TouchEvent): void {\n    const { x, y } = simplifyEvent(evt);\n\n    const {\n      _areaClientLocation,\n      _areaLocation,\n      _frame,\n      _options,\n      _scrollSpeed,\n    } = this;\n    const { speedDivider } = _options.behaviour.scrolling;\n    const Ry = y - this._containerRect!.top;\n    const Rx = x - this._containerRect!.left;\n\n    if (\n      this._scrollAvailable &&\n      !this._scrollingActive &&\n      (_scrollSpeed.y || _scrollSpeed.x)\n    ) {\n      // Continuous scrolling\n      this._scrollingActive = true;\n\n      const scroll = () => {\n        if (!_scrollSpeed.x && !_scrollSpeed.y) {\n          this._scrollingActive = false;\n\n          return;\n        }\n        // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n        if (_scrollSpeed.y) {\n          this._container!.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n          _areaLocation.y2 = Ry;\n        }\n        if (_scrollSpeed.x) {\n          this._container!.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n          _areaLocation.x2 = Rx;\n        }\n\n        /**\n         * We changed the start coordinates -> redraw the selection-area We\n         * changed the dimensions of the area element -> re-calc selected\n         * elements The selected elements array has been changed -> fire event\n         */\n        _frame.next(evt);\n\n        // Keep scrolling even if the user stops to move his pointer\n        requestAnimationFrame(scroll);\n      };\n\n      requestAnimationFrame(scroll);\n    } else {\n      _areaLocation.x2 = Rx + this._container!.scrollLeft + this._scrollDelta.x;\n      _areaLocation.y2 = Ry + this._container!.scrollTop + this._scrollDelta.y;\n\n      _areaClientLocation.x2 = x;\n      _areaClientLocation.y2 = y;\n\n      /**\n       * Perform redraw only if scrolling is not active. If scrolling is active\n       * this area is getting re-dragged by the anonymize scroll function.\n       */\n      _frame.next(evt);\n    }\n\n    this._handleMoveEvent(evt);\n  }\n\n  _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n    const { container, document } = this._options;\n    const { target, x, y } = simplifyEvent(evt);\n\n    this._container = selectAll(container, document)[0];\n\n    if (!this._container) return;\n    if (\n      this._container.contains(target) &&\n      target.dataset.slateEditor !== 'true' &&\n      target.dataset.plateSelectable !== 'true'\n    )\n      return;\n\n    this._containerRect = this._container.getBoundingClientRect();\n\n    const Rx = x - this._containerRect.left + this._container.scrollLeft;\n    const Ry = y - this._containerRect.top + this._container.scrollTop;\n\n    const { _options } = this;\n\n    if (\n      evt instanceof MouseEvent &&\n      !shouldTrigger(evt, _options.behaviour.triggers)\n    ) {\n      return;\n    }\n\n    // Find start-areas and boundaries\n    const startAreas = selectAll(_options.startAreas, _options.document);\n    const resolvedBoundaries = selectAll(\n      _options.boundaries,\n      _options.document\n    );\n\n    // Check if area starts in one of the start areas / boundaries\n    const evtPath = evt.composedPath();\n\n    if (\n      !this._container ||\n      // eslint-disable-next-line unicorn/prefer-array-some\n      !startAreas.find((el) => evtPath.includes(el)) ||\n      // eslint-disable-next-line unicorn/prefer-array-some\n      !resolvedBoundaries.find((el) => evtPath.includes(el))\n    ) {\n      return;\n    }\n    if (!silent && this._emitEvent('beforestart', evt) === false) {\n      return;\n    }\n\n    this._areaLocation = { x1: Rx, x2: 0, y1: Ry, y2: 0 };\n    this._areaClientLocation = { x1: x, x2: 0, y1: y, y2: 0 };\n\n    // Lock scrolling in target container\n    const scrollElement = document.scrollingElement ?? document.body;\n    this._initScrollDelta = {\n      x: scrollElement.scrollLeft,\n      y: scrollElement.scrollTop,\n    };\n\n    // To detect single-click\n    this._singleClick = true;\n    this.clearSelection(false, true);\n\n    on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {\n      passive: false,\n    });\n    on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n    on(document, 'wheel', this._onScroll, { passive: false });\n  }\n\n  _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n    const { document, features } = this._options;\n    const { _singleClick } = this;\n\n    // Remove event handlers\n    off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n    off(document, ['touchmove', 'mousemove'], this._onTapMove);\n    off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n    off(document, 'wheel', this._onScroll);\n\n    // Keep selection until the next time\n    this._keepSelection();\n\n    if (evt && _singleClick && features.singleTap.allow) {\n      this._onSingleTap(evt);\n    } else if (!_singleClick && !silent) {\n      this._updateElementSelection();\n      this._emitEvent('stop', evt);\n    }\n\n    this._scrollSpeed.x = 0;\n    this._scrollSpeed.y = 0;\n    this._scrollDelta.x = 0;\n    this._scrollDelta.y = 0;\n\n    // Unbind mouse scrolling listener\n    off(this._container, 'wheel', this._manualScroll, { passive: true });\n\n    // Remove selection-area from dom\n    this._area.remove();\n\n    // Cancel current frame\n    this._frame?.cancel();\n\n    // Hide selection area\n    css(this._area, 'display', 'none');\n  }\n\n  _recalculateSelectionAreaRect(): void {\n    const {\n      _areaClientLocation,\n      _areaLocation,\n      _areaRect,\n      _container,\n      _containerRect,\n      _scrollSpeed,\n    } = this;\n    const {\n      clientHeight,\n      clientWidth,\n      scrollHeight,\n      scrollLeft,\n      scrollTop,\n      scrollWidth,\n    } = _container as Element;\n\n    const { x1, y1 } = _areaLocation;\n    let { x2, y2 } = _areaLocation;\n\n    const {\n      behaviour: {\n        scrolling: { startScrollMargins },\n      },\n    } = this._options;\n\n    if (\n      _areaClientLocation.x2 + this._scrollDelta.x <\n      _containerRect!.left + startScrollMargins.x\n    ) {\n      _scrollSpeed.x = scrollLeft\n        ? -abs(\n            _containerRect!.left - _areaClientLocation.x2 - this._scrollDelta.x\n          )\n        : 0;\n      x2 = max(x2, this._container!.scrollLeft);\n    } else if (\n      _areaClientLocation.x2 + this._scrollDelta.x >\n      _containerRect!.right - startScrollMargins.x\n    ) {\n      _scrollSpeed.x =\n        scrollWidth - scrollLeft - clientWidth\n          ? abs(\n              _containerRect!.left +\n                this._container!.clientWidth -\n                _areaClientLocation.x2 -\n                this._scrollDelta.x\n            )\n          : 0;\n      x2 = clientWidth + scrollLeft;\n    } else {\n      _scrollSpeed.x = 0;\n    }\n    if (\n      _areaClientLocation.y2 + this._scrollDelta.y <\n      _containerRect!.top + startScrollMargins.y\n    ) {\n      _scrollSpeed.y = scrollTop\n        ? -abs(\n            _containerRect!.top -\n              _areaClientLocation.y2 -\n              this._scrollDelta.y +\n              startScrollMargins.y\n          )\n        : 0;\n      y2 = max(y2, this._container!.scrollTop);\n    } else if (\n      _areaClientLocation.y2 + this._scrollDelta.y >\n      _containerRect!.bottom - startScrollMargins.y\n    ) {\n      _scrollSpeed.y =\n        scrollHeight - scrollTop - clientHeight\n          ? abs(\n              _areaClientLocation.y2 +\n                this._scrollDelta.y -\n                (_containerRect!.top +\n                  this._container!.clientHeight -\n                  startScrollMargins.y)\n            )\n          : 0;\n      y2 = clientHeight + scrollTop;\n    } else {\n      _scrollSpeed.y = 0;\n    }\n\n    // Calculate the final selection area rectangle\n    const x3 = min(x1, x2);\n    const y3 = min(y1, y2);\n    const x4 = max(x1, x2);\n    const y4 = max(y1, y2);\n\n    // Update the _areaRect with the new values\n    _areaRect.x = x3;\n    _areaRect.y = y3;\n    _areaRect.width = x4 - x3;\n    _areaRect.height = y4 - y3;\n  }\n\n  _redrawSelectionArea(): void {\n    const { height, width, x, y } = this._areaRect;\n    const { style } = this._area;\n\n    // Using transform will make the area's borders look blurry\n    style.left = `${x}px`;\n    style.top = `${y}px`;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n  }\n\n  _setupSelectionArea(): void {}\n\n  _updateElementSelection(): void {\n    const { _areaRect, _options, _selectables, _selection } = this;\n    const { selected, stored, touched } = _selection;\n    const { intersect, overlap } = _options.behaviour;\n\n    const invert = overlap === 'invert';\n    const newlyTouched: Element[] = [];\n    const added: Element[] = [];\n    const removed: Element[] = [];\n\n    // Find newly selected elements\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < _selectables.length; i++) {\n      const node = _selectables[i];\n\n      // Check if area intersects element\n      if (\n        intersectsScroll(\n          _areaRect,\n          node.getBoundingClientRect(),\n          intersect,\n          this._container as HTMLElement\n        )\n      ) {\n        // Check if the element wasn't present in the last selection.\n        if (!selected.includes(node)) {\n          // Check if user wants to invert the selection for already selected elements\n          if (invert && stored.includes(node)) {\n            removed.push(node);\n\n            continue;\n          } else {\n            added.push(node);\n          }\n        } else if (stored.includes(node) && !touched.includes(node)) {\n          touched.push(node);\n        }\n\n        newlyTouched.push(node);\n      }\n    }\n\n    // Re-select elements which were previously stored\n    if (invert) {\n      added.push(...stored.filter((v) => !selected.includes(v)));\n    }\n\n    // Check which elements where removed since last selection\n    const keep = overlap === 'keep';\n\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < selected.length; i++) {\n      const node = selected[i];\n\n      if (\n        !newlyTouched.includes(node) &&\n        !(\n          // Check if user wants to keep previously selected elements, e.g.\n          // not make them part of the current selection as soon as they're touched.\n          (keep && stored.includes(node))\n        )\n      ) {\n        removed.push(node);\n      }\n    }\n\n    _selection.selected = newlyTouched;\n    _selection.changed = { added, removed };\n\n    // Prevent range selection when selection an area.\n    this._latestElement = undefined;\n  }\n\n  /**\n   * Cancel the current selection process.\n   *\n   * @param keepEvent {boolean} true to fire a stop event after cancel.\n   */\n  cancel(keepEvent = false): void {\n    this._onTapStop(null, !keepEvent);\n  }\n\n  /**\n   * Same as deselect, but for all elements currently selected.\n   *\n   * @param includeStored If the store should also get cleared\n   * @param quiet If move / stop events should be fired\n   */\n  clearSelection(includeStored = true, quiet = false): void {\n    const { changed, selected, stored } = this._selection;\n\n    changed.added = [];\n    changed.removed.push(...selected, ...(includeStored ? stored : []));\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent('move', null);\n      this._emitEvent('stop', null);\n    }\n\n    // Reset state\n    this._selection = {\n      changed: { added: [], removed: [] },\n      selected: [],\n      stored: includeStored ? [] : stored,\n      touched: [],\n    };\n  }\n\n  /**\n   * Removes a particular element from the selection.\n   *\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  deselect(query: SelectAllSelectors, quiet = false) {\n    const { changed, selected, stored } = this._selection;\n\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => selected.includes(el) || stored.includes(el)\n    );\n\n    if (elements.length === 0) {\n      return;\n    }\n\n    this._selection.stored = stored.filter((el) => !elements.includes(el));\n    this._selection.selected = selected.filter((el) => !elements.includes(el));\n    this._selection.changed.added = [];\n    this._selection.changed.removed.push(\n      ...elements.filter((el) => !changed.removed.includes(el))\n    );\n\n    // We don't know which element was \"selected\" first so clear it\n    this._latestElement = undefined;\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent('move', null);\n      this._emitEvent('stop', null);\n    }\n  }\n\n  /** Unbinds all events and removes the area-element. */\n  destroy(): void {\n    this.cancel();\n    this.disable();\n    super.unbindAllListeners();\n  }\n\n  /** @returns {Array} Selected elements */\n  getSelection(): Element[] {\n    return this._selection.stored;\n  }\n\n  /** @returns {HTMLElement} The selection area element */\n  getSelectionArea(): HTMLElement {\n    return this._area;\n  }\n  /**\n   * Can be used if during a selection elements have been added. Will update\n   * everything which can be selected.\n   */\n  resolveSelectables(): void {\n    this._selectables = selectAll(\n      this._options.selectables,\n      this._options.document\n    );\n  }\n\n  /**\n   * Adds elements to the selection\n   *\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  select(query: SelectAllSelectors, quiet = false): Element[] {\n    const { changed, selected, stored } = this._selection;\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => !selected.includes(el) && !stored.includes(el)\n    );\n\n    // Update element lists\n    stored.push(...elements);\n    selected.push(...elements);\n    changed.added.push(...elements);\n    changed.removed = [];\n\n    // We don't know which element was \"selected\" first so clear it\n    this._latestElement = undefined;\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent('move', null);\n      this._emitEvent('stop', null);\n    }\n\n    return elements;\n  }\n\n  /**\n   * Manually triggers the start of a selection\n   *\n   * @param evt A MouseEvent / TouchEvent -like object\n   * @param silent If beforestart should be fired,\n   */\n  trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n    this._onTapStart(evt, silent);\n  }\n}\n","import type { SlateEditor } from 'platejs';\n\nimport copyToClipboard from 'copy-to-clipboard';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const copySelectedBlocks = (editor: SlateEditor) => {\n  const { selectedIds } = editor.getOptions(BlockSelectionPlugin);\n  const selectedEntries = editor\n    .getApi(BlockSelectionPlugin)\n    .blockSelection.getNodes({ collapseTableRows: true });\n  const selectedFragment = selectedEntries.map(([node]) => node);\n\n  copyToClipboard(' ', {\n    onCopy: (dataTransfer) => {\n      const data = dataTransfer as DataTransfer;\n\n      if (!data) return;\n\n      let textPlain = '';\n      const div = document.createElement('div');\n\n      editor.tf.withoutNormalizing(() => {\n        selectedEntries.forEach(([, path]) => {\n          // select block by block\n          editor.tf.select({\n            anchor: editor.api.start(path)!,\n            focus: editor.api.end(path)!,\n          });\n\n          const isEmpty = editor.api.isEmpty(path);\n\n          if (isEmpty) {\n            const after = editor.api.after(editor.selection!);\n\n            editor.tf.select({\n              anchor: editor.api.start(path)!,\n              focus: after!,\n            });\n          }\n\n          if (!isEmpty) {\n            editor.tf.setFragmentData(data);\n          }\n\n          // get plain text\n          if (isEmpty) {\n            textPlain += '\\n';\n          } else {\n            textPlain += `${data.getData('text/plain')}\\n`;\n          }\n\n          // get html text\n          const divChild = document.createElement('div');\n          if (isEmpty) {\n            // Does not support empty non-paragraph blocks yet\n            divChild.innerHTML = '<p></p>';\n          } else {\n            divChild.innerHTML = data.getData('text/html');\n          }\n\n          div.append(divChild);\n        });\n\n        // deselect and select back selectedIds\n        editor.tf.deselect();\n        editor.setOption(BlockSelectionPlugin, 'selectedIds', selectedIds);\n      });\n\n      data.setData('text/plain', textPlain);\n      data.setData('text/html', div.innerHTML);\n\n      // set slate fragment\n      const selectedFragmentStr = JSON.stringify(selectedFragment);\n      const encodedFragment = window.btoa(\n        encodeURIComponent(selectedFragmentStr)\n      );\n      data.setData('application/x-slate-fragment', encodedFragment);\n    },\n  });\n};\n","import { type SlateEditor, getEditorPlugin, PathApi } from 'platejs';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\nimport { selectInsertedBlocks } from './selectInsertedBlocks';\n\nexport const pasteSelectedBlocks = (editor: SlateEditor, e: ClipboardEvent) => {\n  const { api } = getEditorPlugin(editor, BlockSelectionPlugin);\n\n  const entries = api.blockSelection.getNodes();\n\n  if (entries.length > 0) {\n    const entry = entries.at(-1)!;\n    const [node, path] = entry;\n\n    if (!editor.api.isEmpty(node as any)) {\n      const at = PathApi.next(path);\n\n      editor.tf.insertNodes(editor.api.create.block({}, at), {\n        at,\n        select: true,\n      });\n    }\n\n    // quick fix until we find a way to merge history\n    // editor.tf.withoutMerging(() => {\n    editor.tf.insertData(e.clipboardData!);\n    // });\n\n    selectInsertedBlocks(editor);\n  }\n};\n","import { type SlateEditor, getEditorPlugin } from 'platejs';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\n/** Select inserted blocks from the last operations. */\nexport const selectInsertedBlocks = (editor: SlateEditor) => {\n  const { setOption } = getEditorPlugin(editor, BlockSelectionPlugin);\n\n  const ids = new Set<string>();\n\n  editor.operations.forEach((op) => {\n    if (\n      op.type === 'insert_node' &&\n      op.node.id &&\n      editor.api.isBlock(op.node)\n    ) {\n      ids.add(op.node.id as string);\n    }\n  });\n\n  setOption('selectedIds', ids);\n};\n","import type { TIdElement } from 'platejs';\n\nimport { type PlateEditor, getEditorPlugin } from 'platejs/react';\n\nimport { BlockSelectionPlugin } from '../../BlockSelectionPlugin';\n\nexport const moveSelection = (\n  editor: PlateEditor,\n  direction: 'down' | 'up'\n) => {\n  const { api, setOption } = getEditorPlugin(editor, BlockSelectionPlugin);\n  const blocks = api.blockSelection.getNodes();\n\n  if (blocks.length === 0) return;\n  if (direction === 'up') {\n    const [, topPath] = blocks[0];\n\n    const prevEntry = editor.api.previous<TIdElement>({\n      at: topPath,\n      from: 'parent',\n      match: api.blockSelection.isSelectable,\n    });\n\n    if (prevEntry) {\n      const [prevNode] = prevEntry;\n      setOption('anchorId', prevNode.id);\n      api.blockSelection.set(prevNode.id);\n    } else {\n      api.blockSelection.set(blocks[0][0].id);\n    }\n  } else {\n    // direction === 'down'\n    const [, bottomPath] = blocks.at(-1)!;\n\n    const nextEntry = editor.api.next<TIdElement>({\n      at: bottomPath,\n      from: 'child',\n      match: api.blockSelection.isSelectable,\n    });\n\n    if (nextEntry) {\n      const [nextNode] = nextEntry;\n      setOption('anchorId', nextNode.id);\n      api.blockSelection.set(nextNode.id);\n    } else {\n      api.blockSelection.set(blocks.at(-1)![0].id);\n    }\n  }\n};\n","import { type SlateEditor, getEditorPlugin, KEYS } from 'platejs';\n\nimport type { BlockSelectionConfig } from '../../BlockSelectionPlugin';\n\nimport { querySelectorSelectable } from '../../../lib';\nimport { extractSelectableIds } from '../../../lib/extractSelectableIds';\n\nexport const setSelectedIds = (\n  editor: SlateEditor,\n  {\n    added,\n    ids,\n    removed,\n  }: Partial<{\n    added: Element[];\n    removed: Element[];\n  }> & {\n    ids?: string[];\n  }\n) => {\n  const { getOptions, setOption } = getEditorPlugin<BlockSelectionConfig>(\n    editor,\n    { key: KEYS.blockSelection }\n  );\n\n  if (ids) {\n    setOption('selectedIds', new Set(ids));\n  }\n  if (added || removed) {\n    const { selectedIds: prev } = getOptions();\n    const next = new Set(prev);\n\n    if (added) {\n      extractSelectableIds(added).forEach((id) => id && next.add(id));\n    }\n    if (removed) {\n      extractSelectableIds(removed).forEach((id) => id && next.delete(id));\n    }\n\n    setOption('selectedIds', next);\n  }\n\n  setOption('isSelecting', true);\n};\n\nexport const addSelectedRow = (\n  editor: SlateEditor,\n  id: string,\n  options: { clear?: boolean; delay?: number } = {}\n) => {\n  const { api, getOptions, setOption } = getEditorPlugin<BlockSelectionConfig>(\n    editor,\n    { key: KEYS.blockSelection }\n  );\n\n  const { clear = true, delay } = options;\n\n  const element = querySelectorSelectable(id);\n\n  if (!element) return;\n  if (!getOptions().selectedIds!.has(id) && clear) {\n    setOption('selectedIds', new Set());\n  }\n\n  api.blockSelection.setSelectedIds({\n    added: [element],\n    removed: [],\n  });\n\n  if (delay) {\n    setTimeout(() => {\n      api.blockSelection.setSelectedIds({\n        added: [],\n        removed: [element],\n      });\n    }, delay);\n  }\n};\n","import { type TIdElement, PathApi } from 'platejs';\nimport { type PlateEditor, getEditorPlugin } from 'platejs/react';\n\nimport { BlockSelectionPlugin } from '../../BlockSelectionPlugin';\n\n/**\n * SHIFT-based expand-or-shrink selection.\n *\n * SHIFT + DOWN:\n *\n * - If anchor is top-most in the selection => expand down (add block below\n *   bottom-most).\n * - Otherwise => shrink from top-most (unless top-most is the anchor).\n *\n * SHIFT + UP:\n *\n * - If anchor is bottom-most => expand up (add block above top-most).\n * - Otherwise => shrink from bottom-most (unless bottom-most is the anchor).\n */\nexport const shiftSelection = (\n  editor: PlateEditor,\n  direction: 'down' | 'up'\n) => {\n  const { api, getOption, getOptions, setOption } = getEditorPlugin(\n    editor,\n    BlockSelectionPlugin\n  );\n\n  const blocks = api.blockSelection.getNodes();\n\n  if (blocks.length === 0) return;\n\n  // Identify the top-most and bottom-most blocks in the current selection.\n  const [topNode, topPath] = blocks[0];\n  const [bottomNode, bottomPath] = blocks.at(-1)!;\n  let anchorId = getOptions().anchorId;\n\n  // If no anchor is set, default to bottom-most if SHIFT+UP, else top-most if SHIFT+DOWN.\n  if (!anchorId) {\n    anchorId = (direction === 'up' ? bottomNode.id : topNode.id) as string;\n    setOption('anchorId', anchorId);\n  }\n\n  // Find the anchor block within the current selection array.\n  const anchorIndex = blocks.findIndex(([node]) => node.id === anchorId);\n\n  if (anchorIndex === -1) {\n    // If anchor not found in the current selection, fallback:\n    setOption('anchorId', bottomNode.id as string);\n\n    return;\n  }\n\n  const anchorIsTop = anchorIndex === 0;\n  const anchorIsBottom = anchorIndex === blocks.length - 1;\n\n  const newSelected = new Set(getOption('selectedIds'));\n\n  if (direction === 'down') {\n    // SHIFT+DOWN\n    if (anchorIsTop) {\n      // Expand down => add block below the bottom-most\n      const belowEntry = editor.api.next({\n        at: bottomPath,\n        mode: 'highest',\n        match: (n, p) =>\n          api.blockSelection.isSelectable(n as any, p) &&\n          !PathApi.isAncestor(p, bottomPath),\n      });\n\n      if (!belowEntry) return;\n\n      const [belowNode] = belowEntry;\n\n      newSelected.add(belowNode.id as string);\n    } else {\n      // anchor is not top => shrink from top-most\n      // remove the top-most from selection unless it's the anchor.\n      if (topNode.id && topNode.id !== anchorId) {\n        newSelected.delete(topNode.id as string);\n      }\n    }\n  } else {\n    // SHIFT+UP\n    if (anchorIsBottom) {\n      // Expand up => add block above the top-most\n      const aboveEntry = editor.api.previous<TIdElement>({\n        at: topPath,\n        from: 'parent',\n        match: api.blockSelection.isSelectable,\n      });\n\n      if (!aboveEntry) return;\n\n      const [aboveNode, abovePath] = aboveEntry;\n\n      if (PathApi.isAncestor(abovePath, topPath)) {\n        newSelected.forEach((id) => {\n          const entry = editor.api.node({ id, at: abovePath });\n\n          if (!entry) return;\n          if (PathApi.isDescendant(entry[1], abovePath)) {\n            newSelected.delete(id);\n\n            if (id === anchorId) {\n              anchorId = aboveNode.id;\n              setOption('anchorId', anchorId);\n            }\n          }\n        });\n      }\n\n      newSelected.add(aboveNode.id);\n    } else {\n      // anchor is not bottom => shrink from bottom-most\n      if (bottomNode.id && bottomNode.id !== anchorId) {\n        newSelected.delete(bottomNode.id as string);\n      }\n    }\n  }\n\n  // Always ensure the anchor remains selected\n  newSelected.add(anchorId!);\n\n  setOption('selectedIds', newSelected);\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { PathApi } from 'platejs';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const duplicateBlockSelectionNodes = (editor: PlateEditor) => {\n  const blocks = editor.getApi(BlockSelectionPlugin).blockSelection.getNodes();\n\n  const lastBlock = blocks.at(-1);\n\n  if (!lastBlock) return;\n\n  editor.tf.duplicateNodes({\n    nodes: blocks,\n  });\n\n  const path = PathApi.next(lastBlock[1]);\n\n  const ids = blocks\n    .map((_, index) => {\n      const targetPath = [path[0] + index];\n      const targetNode = editor.api.node(targetPath);\n\n      return targetNode?.[0].id as string;\n    })\n    .filter(Boolean);\n\n  setTimeout(() => {\n    editor.setOption(BlockSelectionPlugin, 'selectedIds', new Set(ids));\n  }, 0);\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { type Path, type TElement, NodeApi, PathApi } from 'platejs';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const insertBlocksAndSelect = (\n  editor: PlateEditor,\n  nodes: TElement[],\n  { at }: { at: Path }\n) => {\n  editor.tf.insertNodes(nodes, { at });\n\n  const insertedNodes = [NodeApi.get<TElement>(editor, at)!];\n\n  let count = 1;\n\n  while (count < nodes.length) {\n    at = PathApi.next(at);\n    const nextNode = NodeApi.get<TElement>(editor, at)!;\n    insertedNodes.push(nextNode);\n    count++;\n  }\n\n  setTimeout(() => {\n    editor.setOption(\n      BlockSelectionPlugin,\n      'selectedIds',\n      new Set(insertedNodes.map((n) => n.id as string))\n    );\n  }, 0);\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const removeBlockSelectionNodes = (editor: SlateEditor) => {\n  const selectedIds = editor.getOption(BlockSelectionPlugin, 'selectedIds');\n\n  if (!selectedIds) return;\n\n  editor.tf.removeNodes({\n    at: [],\n    block: true,\n    match: (n: any) => !!n.id && selectedIds.has((n as any).id),\n  });\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const selectBlockSelectionNodes = (editor: SlateEditor) => {\n  editor.tf.select(\n    editor.api.nodesRange(\n      editor.getApi(BlockSelectionPlugin).blockSelection.getNodes()\n    )\n  );\n  editor.getApi(BlockSelectionPlugin).blockSelection.clear();\n};\n","import type { NodeProps, SetNodesOptions, TElement, TText } from 'platejs';\nimport type { PlateEditor } from 'platejs/react';\n\nimport { BlockSelectionPlugin } from '../BlockSelectionPlugin';\n\nexport const setBlockSelectionNodes = (\n  editor: PlateEditor,\n  props: Partial<NodeProps<TElement>>,\n  options?: SetNodesOptions\n) => {\n  editor.tf.withoutNormalizing(() => {\n    const blocks = editor\n      .getApi(BlockSelectionPlugin)\n      .blockSelection.getNodes();\n\n    blocks.forEach(([, path]) => {\n      editor.tf.setNodes(props, {\n        ...options,\n        at: path,\n      });\n    });\n  });\n};\n\nexport const setBlockSelectionIndent = (\n  editor: PlateEditor,\n  indent: number,\n  options?: SetNodesOptions\n) => {\n  const api = editor.getApi(BlockSelectionPlugin);\n\n  editor.tf.withoutNormalizing(() => {\n    const blocks = api.blockSelection.getNodes();\n\n    blocks.forEach(([node, path]) => {\n      const prevIndent = (node as any).indent ?? 0;\n\n      const currentIndent = prevIndent + indent;\n\n      editor.tf.setNodes(\n        { indent: Math.max(currentIndent, 0) },\n        {\n          ...options,\n          at: path,\n        }\n      );\n    });\n  });\n};\n\nexport const setBlockSelectionTexts = (\n  editor: PlateEditor,\n  props: Partial<NodeProps<TText>>,\n  options?: Omit<SetNodesOptions, 'at'>\n) => {\n  setBlockSelectionNodes(editor, props, {\n    mode: 'lowest',\n    ...options,\n  });\n};\n"],"mappings":"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","names":["KEYS","PathApi","createTPlatePlugin","React","KEYS","PathApi","useEditorPlugin","useEditorRef","usePluginOption","KEYS","id","KEYS","useElement","useElement","usePluginOption","usePluginOption","React","useEditorRef","usePluginOption","KEYS","createTPlatePlugin","usePluginOption","createTPlatePlugin","KEYS","isSelecting","usePluginOption","PathApi","RangeApi","React","React","useEditorRef","usePluginOption","React","usePluginOption","usePluginOption","React","KEYS","useEditorPlugin","document","useEditorPlugin","React","KEYS","getEditorPlugin","PathApi","getEditorPlugin","PathApi","useEditorRef","useEditorPlugin","KEYS","usePluginOption","React","PathApi","getEditorPlugin","getEditorPlugin","getEditorPlugin","KEYS","getEditorPlugin","KEYS","PathApi","getEditorPlugin","getEditorPlugin","PathApi","PathApi","PathApi","PathApi","PathApi","createTPlatePlugin","KEYS","PathApi","selectAll"]}