{"version":3,"sources":["../src/lib/AutoformatPlugin.ts","../src/lib/transforms/autoformatBlock.ts","../src/lib/utils/getMatchRange.ts","../src/lib/transforms/autoformatMark.ts","../src/lib/utils/isPreviousCharacterEmpty.ts","../src/lib/utils/getMatchPoints.ts","../src/lib/transforms/autoformatText.ts","../src/lib/rules/autoformatArrow.ts","../src/lib/rules/autoformatLegal.ts","../src/lib/rules/autoformatPunctuation.ts","../src/lib/rules/autoformatSmartQuotes.ts","../src/lib/rules/math/autoformatComparison.ts","../src/lib/rules/math/autoformatEquality.ts","../src/lib/rules/math/autoformatFraction.ts","../src/lib/rules/math/autoformatOperation.ts","../src/lib/rules/math/autoformatSubscript.ts","../src/lib/rules/math/autoformatSuperscript.ts","../src/lib/rules/math/autoformatMath.ts"],"sourcesContent":["import { type PluginConfig, createTSlatePlugin, KEYS, RangeApi } from 'platejs';\n\nimport type { AutoformatRule, AutoformatTextRule } from './types';\n\nimport { autoformatBlock, autoformatMark, autoformatText } from './transforms';\n\nexport type AutoformatConfig = PluginConfig<\n  'autoformat',\n  {\n    enableUndoOnDelete?: boolean;\n    /** A list of triggering rules. */\n    rules?: AutoformatRule[];\n  }\n>;\n\n/** Enables support for autoformatting actions. */\nexport const AutoformatPlugin = createTSlatePlugin<AutoformatConfig>({\n  key: KEYS.autoformat,\n  editOnly: true,\n  options: {\n    rules: [],\n  },\n}).overrideEditor(\n  ({ editor, getOptions, tf: { deleteBackward, insertText } }) => {\n    return {\n      transforms: {\n        deleteBackward(unit = 'character') {\n          const apply = () => {\n            const { enableUndoOnDelete, rules } = getOptions();\n\n            if (unit !== 'character' || !rules || !enableUndoOnDelete) return;\n\n            // Abort if selection is not collapsed i.e. we're not deleting single character.\n            const { selection } = editor;\n\n            if (!selection || !editor.api.isCollapsed()) return;\n\n            // Get start and end point of selection.\n            // For example: Text|\n            //                  ^ cursor at the moment of pressing the hotkey\n            // start, end will be equal to the location of the |\n            const [start, end] = RangeApi.edges(selection);\n\n            // Get location before the cursor.\n            // before will be a point one character before | so:\n            // Text|\n            //    ^\n            const before = editor.api.before(end, {\n              distance: 1,\n              unit: 'character',\n            });\n\n            if (!start) return;\n            if (!before) return;\n\n            // Abort if there doesn't exist a valid character to replace.\n            const charRange = { anchor: before, focus: start };\n\n            if (!charRange) return;\n\n            // Text|\n            //    ^\n            // Between ^ and | is t\n            const char = editor.api.string(charRange);\n\n            if (!char) return;\n\n            const matchers: AutoformatRule[] = [...rules].filter((rule) => {\n              const textRule = rule as AutoformatTextRule;\n\n              if (textRule) {\n                return textRule.mode === 'text' && textRule.format === char;\n              }\n\n              return;\n            });\n\n            // abort if no matching substitution is found.\n            if (!matchers || matchers.length === 0) return;\n\n            // remove the shorthand character.\n            deleteBackward(unit);\n\n            // put back the orignal characters. This could match to a single string or an array.\n            const rule = matchers[0] as AutoformatTextRule;\n\n            if (rule && typeof rule.match === 'string') {\n              editor.tf.insertText(rule.match);\n            } else {\n              const matchArray = rule.match as string[];\n\n              if (matchArray && matchArray.length > 0) {\n                editor.tf.insertText(matchArray[0]);\n              }\n            }\n\n            return true;\n          };\n\n          if (apply()) return;\n\n          deleteBackward(unit);\n        },\n        insertText(text, options) {\n          if (!editor.api.isCollapsed()) return insertText(text, options);\n\n          for (const rule of getOptions().rules!) {\n            const { insertTrigger, mode = 'text', query } = rule;\n\n            if (query && !query(editor as any, { ...rule, text })) continue;\n\n            const autoformatter: Record<typeof mode, any> = {\n              block: autoformatBlock,\n              mark: autoformatMark,\n              text: autoformatText,\n            };\n\n            if (\n              autoformatter[mode]?.(editor, {\n                ...(rule as any),\n                text,\n              })\n            ) {\n              return insertTrigger && insertText(text);\n            }\n          }\n\n          insertText(text, options);\n        },\n      },\n    };\n  }\n);\n","import castArray from 'lodash/castArray.js';\nimport { type SlateEditor, type TRange, ElementApi, KEYS } from 'platejs';\n\nimport type { AutoformatBlockRule } from '../types';\n\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatBlockOptions extends AutoformatBlockRule {\n  text: string;\n}\n\nexport const autoformatBlock = (\n  editor: SlateEditor,\n  {\n    allowSameTypeAbove = false,\n    format,\n    match: _match,\n    matchByRegex = false,\n    preFormat,\n    text,\n    trigger,\n    triggerAtBlockStart = true,\n    type = KEYS.p,\n  }: AutoformatBlockOptions\n) => {\n  const matches = castArray(_match as string[] | string);\n\n  for (const match of matches) {\n    const { end, triggers } = getMatchRange({\n      match: { end: match, start: '' },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    let matchRange: TRange | undefined;\n    let textFromBlockStart = '';\n\n    if (triggerAtBlockStart) {\n      matchRange = editor.api.range('start', editor.selection);\n\n      // Don't autoformat if there is void nodes.\n      const hasVoidNode = editor.api.some({\n        at: matchRange,\n        match: (n) => ElementApi.isElement(n) && editor.api.isVoid(n),\n      });\n\n      if (hasVoidNode) continue;\n\n      textFromBlockStart = editor.api.string(matchRange);\n\n      const isMatched = matchByRegex\n        ? !!textFromBlockStart.match(end)\n        : end === textFromBlockStart;\n\n      if (!isMatched) continue;\n    } else {\n      matchRange = editor.api.range('before', editor.selection!, {\n        before: {\n          matchByRegex,\n          matchString: end,\n        },\n      });\n\n      if (!matchRange) continue;\n\n      textFromBlockStart = editor.api.string(matchRange);\n    }\n    if (!allowSameTypeAbove) {\n      // Don't autoformat if already in a block of the same type.\n      const isBelowSameBlockType = editor.api.some({ match: { type } });\n\n      if (isBelowSameBlockType) continue;\n    }\n    // if the trigger is only 1 char there is nothing to delete, so we'd delete unrelated text\n    if (match.length > 1) {\n      editor.tf.delete({\n        at: matchRange,\n      });\n    }\n    if (preFormat) {\n      preFormat(editor);\n    }\n    if (format) {\n      format(editor, { matchString: textFromBlockStart });\n    } else {\n      editor.tf.setNodes(\n        { type },\n        {\n          match: (n) => editor.api.isBlock(n),\n        }\n      );\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { AutoformatRule, MatchRange } from '../types';\n\nexport const getMatchRange = ({\n  match,\n  trigger,\n}: {\n  match: MatchRange | string;\n  trigger: AutoformatRule['trigger'];\n}) => {\n  let start: string;\n  let end: string;\n\n  if (typeof match === 'object') {\n    start = match.start;\n    end = match.end;\n  } else {\n    start = match;\n    end = start.split('').reverse().join('');\n  }\n\n  const triggers: string[] = trigger ? castArray(trigger) : [end.slice(-1)];\n\n  end = trigger ? end : end.slice(0, -1);\n\n  return {\n    end,\n    start,\n    triggers,\n  };\n};\n","import type { Editor, TRange } from 'platejs';\n\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatMarkRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatMarkOptions extends AutoformatMarkRule {\n  text: string;\n}\n\nexport const autoformatMark = (\n  editor: Editor,\n  { ignoreTrim, match: _match, text, trigger, type }: AutoformatMarkOptions\n) => {\n  if (!type) return false;\n\n  const selection = editor.selection!;\n  const matches = castArray(_match);\n\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match,\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    const matchRange: TRange = {\n      anchor: afterStartMatchPoint!,\n      focus: beforeEndMatchPoint,\n    };\n\n    if (!ignoreTrim) {\n      const matchText = editor.api.string(matchRange);\n\n      if (matchText.trim() !== matchText) continue;\n    }\n    // delete end match\n    if (end) {\n      editor.tf.delete({\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n\n    const marks = castArray(type);\n\n    // add mark to the text between the matches\n    editor.tf.select(matchRange as TRange);\n    marks.forEach((mark) => {\n      editor.tf.addMark(mark, true);\n    });\n    editor.tf.collapse({ edge: 'end' });\n    editor.tf.removeMarks(marks, { shouldChange: false });\n\n    editor.tf.delete({\n      at: {\n        anchor: beforeStartMatchPoint!,\n        focus: afterStartMatchPoint!,\n      },\n    });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { Editor, TLocation } from 'platejs';\n\nexport const isPreviousCharacterEmpty = (editor: Editor, at: TLocation) => {\n  const range = editor.api.range('before', at);\n\n  if (range) {\n    const text = editor.api.string(range);\n\n    if (text) {\n      const noWhiteSpaceRegex = new RegExp(`\\\\S+`);\n\n      return !noWhiteSpaceRegex.exec(text);\n    }\n  }\n\n  return true;\n};\n","import type { Editor, Point } from 'platejs';\n\nimport type { MatchRange } from '../types';\n\nimport { isPreviousCharacterEmpty } from './isPreviousCharacterEmpty';\n\nexport type GetMatchPointsReturnType =\n  | {\n      afterStartMatchPoint: Point | undefined;\n      beforeEndMatchPoint: Point;\n      beforeStartMatchPoint: Point | undefined;\n    }\n  | undefined;\n\nexport const getMatchPoints = (editor: Editor, { end, start }: MatchRange) => {\n  const selection = editor.selection!;\n\n  let beforeEndMatchPoint: Point | undefined = selection.anchor;\n\n  if (end) {\n    beforeEndMatchPoint = editor.api.before(selection, {\n      matchString: end,\n    });\n\n    if (!beforeEndMatchPoint) return;\n  }\n\n  let afterStartMatchPoint: Point | undefined;\n  let beforeStartMatchPoint: Point | undefined;\n\n  if (start) {\n    afterStartMatchPoint = editor.api.before(beforeEndMatchPoint, {\n      afterMatch: true,\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!afterStartMatchPoint) return;\n\n    beforeStartMatchPoint = editor.api.before(beforeEndMatchPoint, {\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint as Point))\n      return;\n  }\n\n  return {\n    afterStartMatchPoint,\n    beforeEndMatchPoint,\n    beforeStartMatchPoint,\n  };\n};\n","import type { SlateEditor } from 'platejs';\n\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatTextRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatTextOptions extends AutoformatTextRule {\n  text: string;\n}\n\nexport const autoformatText = (\n  editor: SlateEditor,\n  { format, match: _match, text, trigger }: AutoformatTextOptions\n) => {\n  const selection = editor.selection!;\n  const matches = castArray(_match);\n\n  // dup\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match: Array.isArray(format)\n        ? match\n        : {\n            end: match,\n            start: '',\n          },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    if (end) {\n      editor.tf.delete({\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n    if (typeof format === 'function') {\n      format(editor, matched);\n    } else {\n      const formatEnd = Array.isArray(format) ? format[1] : format;\n      editor.tf.insertText(formatEnd);\n\n      if (beforeStartMatchPoint) {\n        const formatStart = Array.isArray(format) ? format[0] : format;\n\n        editor.tf.delete({\n          at: {\n            anchor: beforeStartMatchPoint!,\n            focus: afterStartMatchPoint!,\n          },\n        });\n\n        editor.tf.insertText(formatStart, {\n          at: beforeStartMatchPoint,\n        });\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatArrow: AutoformatRule[] = [\n  {\n    format: '→',\n    match: '->',\n    mode: 'text',\n  },\n  {\n    format: '←',\n    match: '<-',\n    mode: 'text',\n  },\n  {\n    format: '⇒',\n    match: '=>',\n    mode: 'text',\n  },\n  {\n    format: '⇐',\n    match: ['<=', '≤='],\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatLegal: AutoformatRule[] = [\n  {\n    format: '™',\n    match: ['(tm)', '(TM)'],\n    mode: 'text',\n  },\n  {\n    format: '®',\n    match: ['(r)', '(R)'],\n    mode: 'text',\n  },\n\n  {\n    format: '©',\n    match: ['(c)', '(C)'],\n    mode: 'text',\n  },\n];\n\nexport const autoformatLegalHtml: AutoformatRule[] = [\n  {\n    format: '™',\n    match: '&trade;',\n    mode: 'text',\n  },\n  {\n    format: '®',\n    match: '&reg;',\n    mode: 'text',\n  },\n  {\n    format: '©',\n    match: '&copy;',\n    mode: 'text',\n  },\n  {\n    format: '§',\n    match: '&sect;',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatPunctuation: AutoformatRule[] = [\n  {\n    format: '\\u2014',\n    match: '--',\n    mode: 'text',\n  },\n  {\n    format: '…',\n    match: '...',\n    mode: 'text',\n  },\n  {\n    format: '»',\n    match: '>>',\n    mode: 'text',\n  },\n  {\n    format: '«',\n    match: '<<',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatSmartQuotes: AutoformatRule[] = [\n  {\n    format: ['“', '”'],\n    match: '\"',\n    mode: 'text',\n  },\n  {\n    format: ['‘', '’'],\n    match: \"'\",\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatComparison: AutoformatRule[] = [\n  {\n    format: '≯',\n    match: '!>',\n    mode: 'text',\n  },\n  {\n    format: '≮',\n    match: '!<',\n    mode: 'text',\n  },\n  {\n    format: '≥',\n    match: '>=',\n    mode: 'text',\n  },\n  {\n    format: '≤',\n    match: '<=',\n    mode: 'text',\n  },\n  {\n    format: '≱',\n    match: '!>=',\n    mode: 'text',\n  },\n  {\n    format: '≰',\n    match: '!<=',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatEquality: AutoformatRule[] = [\n  {\n    format: '≠',\n    match: '!=',\n    mode: 'text',\n  },\n  {\n    format: '≡',\n    match: '==',\n    mode: 'text',\n  },\n  {\n    format: '≢',\n    match: ['!==', '≠='],\n    mode: 'text',\n  },\n  {\n    format: '≈',\n    match: '~=',\n    mode: 'text',\n  },\n  {\n    format: '≉',\n    match: '!~=',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatFraction: AutoformatRule[] = [\n  {\n    format: '½',\n    match: '1/2',\n    mode: 'text',\n  },\n  {\n    format: '⅓',\n    match: '1/3',\n    mode: 'text',\n  },\n  {\n    format: '¼',\n    match: '1/4',\n    mode: 'text',\n  },\n  {\n    format: '⅕',\n    match: '1/5',\n    mode: 'text',\n  },\n  {\n    format: '⅙',\n    match: '1/6',\n    mode: 'text',\n  },\n  {\n    format: '⅐',\n    match: '1/7',\n    mode: 'text',\n  },\n  {\n    format: '⅛',\n    match: '1/8',\n    mode: 'text',\n  },\n  {\n    format: '⅑',\n    match: '1/9',\n    mode: 'text',\n  },\n  {\n    format: '⅒',\n    match: '1/10',\n    mode: 'text',\n  },\n  {\n    format: '⅔',\n    match: '2/3',\n    mode: 'text',\n  },\n  {\n    format: '⅖',\n    match: '2/5',\n    mode: 'text',\n  },\n  {\n    format: '¾',\n    match: '3/4',\n    mode: 'text',\n  },\n  {\n    format: '⅗',\n    match: '3/5',\n    mode: 'text',\n  },\n  {\n    format: '⅜',\n    match: '3/8',\n    mode: 'text',\n  },\n  {\n    format: '⅘',\n    match: '4/5',\n    mode: 'text',\n  },\n  {\n    format: '⅚',\n    match: '5/6',\n    mode: 'text',\n  },\n  {\n    format: '⅝',\n    match: '5/8',\n    mode: 'text',\n  },\n  {\n    format: '⅞',\n    match: '7/8',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatDivision: AutoformatRule[] = [\n  {\n    format: '÷',\n    match: '//',\n    mode: 'text',\n  },\n];\n\nexport const autoformatOperation: AutoformatRule[] = [\n  {\n    format: '±',\n    match: '+-',\n    mode: 'text',\n  },\n  {\n    format: '‰',\n    match: '%%',\n    mode: 'text',\n  },\n  {\n    format: '‱',\n    match: ['%%%', '‰%'],\n    mode: 'text',\n  },\n  ...autoformatDivision,\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatSubscriptNumbers: AutoformatRule[] = [\n  {\n    format: '₀',\n    match: '~0',\n    mode: 'text',\n  },\n  {\n    format: '₁',\n    match: '~1',\n    mode: 'text',\n  },\n  {\n    format: '₂',\n    match: '~2',\n    mode: 'text',\n  },\n  {\n    format: '₃',\n    match: '~3',\n    mode: 'text',\n  },\n  {\n    format: '₄',\n    match: '~4',\n    mode: 'text',\n  },\n  {\n    format: '₅',\n    match: '~5',\n    mode: 'text',\n  },\n  {\n    format: '₆',\n    match: '~6',\n    mode: 'text',\n  },\n  {\n    format: '₇',\n    match: '~7',\n    mode: 'text',\n  },\n  {\n    format: '₈',\n    match: '~8',\n    mode: 'text',\n  },\n  {\n    format: '₉',\n    match: '~9',\n    mode: 'text',\n  },\n];\n\nexport const autoformatSubscriptSymbols: AutoformatRule[] = [\n  {\n    format: '₊',\n    match: '~+',\n    mode: 'text',\n  },\n  {\n    format: '₋',\n    match: '~-',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatSuperscriptNumbers: AutoformatRule[] = [\n  {\n    format: '⁰',\n    match: '^0',\n    mode: 'text',\n  },\n  {\n    format: '¹',\n    match: '^1',\n    mode: 'text',\n  },\n  {\n    format: '²',\n    match: '^2',\n    mode: 'text',\n  },\n  {\n    format: '³',\n    match: '^3',\n    mode: 'text',\n  },\n  {\n    format: '⁴',\n    match: '^4',\n    mode: 'text',\n  },\n  {\n    format: '⁵',\n    match: '^5',\n    mode: 'text',\n  },\n  {\n    format: '⁶',\n    match: '^6',\n    mode: 'text',\n  },\n  {\n    format: '⁷',\n    match: '^7',\n    mode: 'text',\n  },\n  {\n    format: '⁸',\n    match: '^8',\n    mode: 'text',\n  },\n  {\n    format: '⁹',\n    match: '^9',\n    mode: 'text',\n  },\n];\n\nexport const autoformatSuperscriptSymbols: AutoformatRule[] = [\n  {\n    format: '°',\n    match: '^o',\n    mode: 'text',\n  },\n  {\n    format: '⁺',\n    match: '^+',\n    mode: 'text',\n  },\n  {\n    format: '⁻',\n    match: '^-',\n    mode: 'text',\n  },\n];\n","import { autoformatComparison } from './autoformatComparison';\nimport { autoformatEquality } from './autoformatEquality';\nimport { autoformatFraction } from './autoformatFraction';\nimport { autoformatOperation } from './autoformatOperation';\nimport {\n  autoformatSubscriptNumbers,\n  autoformatSubscriptSymbols,\n} from './autoformatSubscript';\nimport {\n  autoformatSuperscriptNumbers,\n  autoformatSuperscriptSymbols,\n} from './autoformatSuperscript';\n\nexport const autoformatMath = [\n  ...autoformatComparison,\n  ...autoformatEquality,\n  ...autoformatOperation,\n  ...autoformatFraction,\n  ...autoformatSuperscriptSymbols,\n  ...autoformatSubscriptSymbols,\n  ...autoformatSuperscriptNumbers,\n  ...autoformatSubscriptNumbers,\n];\n"],"mappings":"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","names":["KEYS","castArray","castArray","castArray","castArray","castArray","castArray","KEYS","rule"]}