{"version":3,"sources":["../src/lib/BaseListPlugin.tsx","../src/lib/queries/areEqListStyleType.ts","../src/lib/types.ts","../src/lib/queries/expandListItemsWithChildren.ts","../src/lib/queries/getListChildren.ts","../src/lib/queries/getListAbove.ts","../src/lib/queries/getListSiblings.ts","../src/lib/queries/getNextList.ts","../src/lib/queries/getSiblingList.ts","../src/lib/queries/getPreviousList.ts","../src/lib/queries/getSiblingListStyleType.ts","../src/lib/queries/isOrderedList.ts","../src/lib/queries/someList.ts","../src/lib/queries/someTodoList.ts","../src/lib/withList.ts","../src/lib/normalizers/normalizeListNotIndented.ts","../src/lib/normalizers/normalizeListStart.ts","../src/lib/normalizers/withInsertBreakList.ts","../src/lib/transforms/indentList.ts","../src/lib/transforms/outdentList.ts","../src/lib/transforms/setListNode.ts","../src/lib/transforms/setListNodes.ts","../src/lib/transforms/setListSiblingNodes.ts","../src/lib/transforms/toggleList.ts","../src/lib/transforms/toggleListSet.ts","../src/lib/transforms/toggleListUnset.ts","../src/lib/transforms/toggleListByPath.ts","../src/lib/withNormalizeList.ts"],"sourcesContent":["import React from 'react';\n\nimport {\n  type PluginConfig,\n  type SlateRenderElementProps,\n  type TElement,\n  type TListElement,\n  createTSlatePlugin,\n  isDefined,\n  isHtmlBlockElement,\n  KEYS,\n  postCleanHtml,\n  traverseHtmlElements,\n} from 'platejs';\n\nimport type { GetSiblingListOptions } from './queries/getSiblingList';\nimport type { ListStyleType } from './types';\n\nimport { isOrderedList } from './queries';\nimport { withList } from './withList';\n\n/**\n * All list items are normalized to have a listStart prop indicating their\n * position in the list (unless listStart would be 1, in which case it is\n * omitted).\n *\n * ListRestart causes listStart to restart from the given number, regardless of\n * any previous listStart.\n *\n * ListRestartPolite acts like listRestart, except it only takes effect for list\n * items at the start of a list. When not at the start of a list, this prop is\n * ignored, although it is not removed and may take effect in the future.\n */\n\nexport type BaseListConfig = PluginConfig<\n  'list',\n  {\n    getSiblingListOptions?: GetSiblingListOptions<TElement>;\n    /** Map html element to list style type. */\n    getListStyleType?: (element: HTMLElement) => ListStyleType;\n  }\n>;\n\nexport const BaseListPlugin = createTSlatePlugin<BaseListConfig>({\n  key: KEYS.list,\n  inject: {\n    plugins: {\n      [KEYS.html]: {\n        parser: {\n          transformData: ({ data }) => {\n            const document = new DOMParser().parseFromString(data, 'text/html');\n            const { body } = document;\n\n            // First pass: flatten nested UL/OL that are inside LI elements\n            // We need to move them to be siblings of their parent LI\n            const lisWithNestedLists: {\n              li: Element;\n              nestedLists: Element[];\n            }[] = [];\n\n            traverseHtmlElements(body, (element) => {\n              if (element.tagName === 'LI') {\n                const nestedLists: Element[] = [];\n                // Find nested UL/OL elements\n                Array.from(element.children).forEach((child) => {\n                  if (child.tagName === 'UL' || child.tagName === 'OL') {\n                    nestedLists.push(child);\n                  }\n                });\n\n                if (nestedLists.length > 0) {\n                  lisWithNestedLists.push({ li: element, nestedLists });\n                }\n              }\n              return true;\n            });\n\n            // Move nested lists to be after their parent LI\n            lisWithNestedLists.forEach(({ li, nestedLists }) => {\n              nestedLists.forEach((nestedList) => {\n                // Remove the nested list from inside the LI\n                nestedList.remove();\n                // Insert it after the LI in the parent container\n                if (li.parentNode) {\n                  li.parentNode.insertBefore(nestedList, li.nextSibling);\n                }\n              });\n            });\n\n            // Second pass: process LI elements (now without nested lists inside them)\n            traverseHtmlElements(body, (element) => {\n              if (element.tagName === 'LI') {\n                const htmlElement = element as HTMLElement;\n                const { childNodes } = element;\n\n                // Process li children and flatten block elements\n                const liChildren: Node[] = [];\n\n                childNodes.forEach((child) => {\n                  if (child.nodeType === Node.ELEMENT_NODE) {\n                    const childElement = child as Element;\n                    if (isHtmlBlockElement(childElement)) {\n                      // Replace block elements (e.g. p) with their children\n                      liChildren.push(...childElement.childNodes);\n                      return;\n                    }\n                  }\n                  liChildren.push(child);\n                });\n\n                element.replaceChildren(...liChildren);\n\n                // Check for aria-level first (Google Docs uses this)\n                const ariaLevel = element.getAttribute('aria-level');\n\n                if (ariaLevel) {\n                  // aria-level takes precedence\n                  htmlElement.dataset.indent = ariaLevel;\n                } else {\n                  // Calculate indent level based on nested UL/OL parents\n                  let indent = 0;\n                  let parent = element.parentElement;\n                  while (parent && parent !== body) {\n                    if (parent.tagName === 'UL' || parent.tagName === 'OL') {\n                      indent++;\n                    }\n                    parent = parent.parentElement;\n                  }\n\n                  // Set indent level as data attribute\n                  if (indent > 0) {\n                    htmlElement.dataset.indent = String(indent);\n                  }\n                }\n\n                // Set list style type from inline style or parent list type\n                const listStyleType = htmlElement.style.listStyleType;\n                if (listStyleType) {\n                  htmlElement.dataset.listStyleType = listStyleType;\n                } else {\n                  // Fallback to parent list type\n                  const listParent = element.closest('ul, ol');\n                  if (listParent) {\n                    const parentListStyleType = (listParent as HTMLElement)\n                      .style.listStyleType;\n                    if (parentListStyleType) {\n                      htmlElement.dataset.listStyleType = parentListStyleType;\n                    } else if (listParent.tagName === 'UL') {\n                      htmlElement.dataset.listStyleType = 'disc';\n                    } else if (listParent.tagName === 'OL') {\n                      htmlElement.dataset.listStyleType = 'decimal';\n                    }\n                  }\n                }\n\n                return false;\n              }\n\n              return true;\n            });\n\n            return postCleanHtml(body.innerHTML);\n          },\n        },\n      },\n    },\n    targetPlugins: [KEYS.p],\n  },\n  options: {\n    getListStyleType: (element) => element.style.listStyleType as ListStyleType,\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        isElement: true,\n        rules: [\n          {\n            validNodeName: 'LI',\n          },\n        ],\n        parse: ({ editor, element, getOptions }) => {\n          // Get indent from data-indent or aria-level (gdoc)\n          const dataIndent = element.dataset.indent;\n          const ariaLevel = element.getAttribute('aria-level');\n          const indent = dataIndent ? Number(dataIndent) : Number(ariaLevel);\n\n          // Get list style type from data attribute or use default\n          const dataListStyleType = element.dataset.listStyleType;\n          const listStyleType =\n            dataListStyleType || getOptions().getListStyleType?.(element);\n\n          return {\n            indent: indent || undefined,\n            listStyleType: listStyleType || undefined,\n            type: editor.getType(KEYS.p),\n          };\n        },\n      },\n    },\n  },\n  render: {\n    belowNodes: (props) => {\n      if (!props.element.listStyleType) return;\n\n      return (props) => <List {...props} />;\n    },\n  },\n  rules: {\n    break: {\n      empty: 'reset',\n      splitReset: false,\n    },\n    delete: {\n      start: 'reset',\n    },\n    merge: {\n      removeEmpty: false,\n    },\n    match: ({ node }) => {\n      return isDefined(node[KEYS.listType]);\n    },\n  },\n}).overrideEditor(withList);\n\nfunction List(props: SlateRenderElementProps) {\n  const { listStart, listStyleType } = props.element as TListElement;\n  const List = isOrderedList(props.element) ? 'ol' : 'ul';\n\n  return (\n    <List\n      style={{ listStyleType, margin: 0, padding: 0, position: 'relative' }}\n      start={listStart}\n    >\n      <li>{props.children}</li>\n    </List>\n  );\n}\n","import type { Editor, NodeEntry } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { ListStyleType } from '../types';\n\nexport const areEqListStyleType = (\n  editor: Editor,\n  entries: NodeEntry[],\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  let eqListStyleType = true;\n\n  for (const entry of entries) {\n    const [block] = entry;\n\n    if (listStyleType === KEYS.listTodo) {\n      if (!block.hasOwnProperty(KEYS.listChecked)) {\n        eqListStyleType = false;\n\n        break;\n      }\n\n      continue;\n    }\n    if (!block[KEYS.listType] || block[KEYS.listType] !== listStyleType) {\n      eqListStyleType = false;\n\n      break;\n    }\n  }\n\n  return eqListStyleType;\n};\n","export enum ListStyleType {\n  ArabicIndic = 'arabic-indic',\n  Armenian = 'armenian',\n  Bengali = 'bengali',\n  Cambodian = 'cambodian',\n  Circle = 'circle',\n  CjkDecimal = 'cjk-decimal',\n  CjkEarthlyBranch = 'cjk-earthly-branch',\n  CjkHeavenlyStem = 'cjk-heavenly-stem',\n  Decimal = 'decimal',\n  DecimalLeadingZero = 'decimal-leading-zero',\n  Devanagari = 'devanagari',\n  Disc = 'disc',\n  DisclosureClosed = 'disclosure-closed',\n  DisclosureOpen = 'disclosure-open',\n  EthiopicNumeric = 'ethiopic-numeric',\n  Georgian = 'georgian',\n  Gujarati = 'gujarati',\n  Gurmukhi = 'gurmukhi',\n  Hebrew = 'hebrew',\n  Hiragana = 'hiragana',\n  HiraganaIroha = 'hiragana-iroha',\n  Inherit = 'inherit',\n  Initial = 'initial',\n  JapaneseFormal = 'japanese-formal',\n  JapaneseInformal = 'japanese-informal',\n  Kannada = 'kannada',\n  Katakana = 'katakana',\n  KatakanaIroha = 'katakana-iroha',\n  Khmer = 'khmer',\n  KoreanHangulFormal = 'korean-hangul-formal',\n  KoreanHanjaFormal = 'korean-hanja-formal',\n  KoreanHanjaInformal = 'korean-hanja-informal',\n  Lao = 'lao',\n  LowerAlpha = 'lower-alpha',\n  LowerArmenian = 'lower-armenian',\n  LowerGreek = 'lower-greek',\n  LowerLatin = 'lower-latin',\n  LowerRoman = 'lower-roman',\n  Malayalam = 'malayalam',\n  Mongolian = 'mongolian',\n  Myanmar = 'myanmar',\n  None = 'none',\n  Oriya = 'oriya',\n  Persian = 'persian',\n  SimpChineseFormal = 'simp-chinese-formal',\n  SimpChineseInformal = 'simp-chinese-informal',\n  Square = 'square',\n  Tamil = 'tamil',\n  Telugu = 'telugu',\n  Thai = 'thai',\n  Tibetan = 'tibetan',\n  TradChineseFormal = 'trad-chinese-formal',\n  TradChineseInformal = 'trad-chinese-informal',\n  UpperAlpha = 'upper-alpha',\n  UpperArmenian = 'upper-armenian',\n  UpperLatin = 'upper-latin',\n  UpperRoman = 'upper-roman',\n}\n\nexport const ULIST_STYLE_TYPES = [\n  ListStyleType.Disc,\n  ListStyleType.Circle,\n  ListStyleType.Square,\n  ListStyleType.DisclosureOpen,\n  ListStyleType.DisclosureClosed,\n] as const;\n","import type { Editor, ElementEntryOf, ElementOf, NodeEntry } from 'platejs';\n\nimport { isDefined, KEYS } from 'platejs';\n\nimport { getListChildren } from './getListChildren';\n\n/**\n * Expands a list of blocks to include list item children. For each list item in\n * the input, adds all its children (items with bigger indent). Non-list blocks\n * are kept as-is. Requires id to be set on the blocks.\n *\n * @returns Array of block entries with list items expanded to include their\n *   children\n */\nexport const expandListItemsWithChildren = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entries: ElementEntryOf<E>[]\n): NodeEntry<N>[] => {\n  const expandedEntries: NodeEntry<N>[] = [];\n  const processedIds = new Set<string>();\n\n  entries.forEach((entry) => {\n    const [node] = entry;\n\n    // Skip if already processed\n    if (processedIds.has(node.id as string)) return;\n\n    expandedEntries.push(entry as NodeEntry<N>);\n    processedIds.add(node.id as string);\n\n    // Check if it's a list item\n    const isListItem =\n      isDefined((node as any)[KEYS.listType]) &&\n      isDefined((node as any)[KEYS.indent]);\n\n    if (isListItem) {\n      // Get all children (items with bigger indent)\n      const children = getListChildren<N, E>(editor, entry);\n\n      // Add children that aren't already in the selection\n      children.forEach((childEntry) => {\n        if (!processedIds.has(childEntry[0].id as string)) {\n          expandedEntries.push(childEntry);\n          processedIds.add(childEntry[0].id as string);\n        }\n      });\n    }\n  });\n\n  return expandedEntries;\n};\n","import type { Editor, ElementEntryOf, ElementOf, NodeEntry } from 'platejs';\n\nimport { isDefined, KEYS, NodeApi, PathApi } from 'platejs';\n\n/**\n * Get all list items that are children of the current list item (have bigger\n * indent). Stops when encountering an item with equal or lower indent.\n */\nexport const getListChildren = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>\n): NodeEntry<N>[] => {\n  const children: NodeEntry<N>[] = [];\n  const [node, path] = entry;\n\n  const parentIndent = (node as any)[KEYS.indent] as number;\n\n  // If no indent or not a list item, return empty\n  if (!isDefined(parentIndent) || !isDefined((node as any)[KEYS.listType])) {\n    return children;\n  }\n\n  let currentPath = path;\n\n  while (true) {\n    const nextPath = PathApi.next(currentPath);\n    if (!nextPath) break;\n\n    const nextNode = NodeApi.get<N>(editor, nextPath);\n    if (!nextNode) break;\n\n    const nextIndent = (nextNode as any)[KEYS.indent] as number;\n\n    // Stop if we hit a non-list item or item with equal/lower indent\n    if (\n      !isDefined(nextIndent) ||\n      !isDefined((nextNode as any)[KEYS.listType])\n    ) {\n      break;\n    }\n\n    if (nextIndent <= parentIndent) {\n      break;\n    }\n\n    // This is a child item (bigger indent)\n    children.push([nextNode, nextPath]);\n    currentPath = nextPath;\n  }\n\n  return children;\n};\n","import {\n  type Editor,\n  type EditorAboveOptions,\n  type ElementOf,\n  type NodeEntry,\n  isDefined,\n  KEYS,\n} from 'platejs';\n\nexport const getListAbove = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: Omit<EditorAboveOptions, 'match'>\n): NodeEntry<N> | undefined => {\n  return editor.api.above({\n    ...options,\n    match: (node) => isDefined(node[KEYS.listType]),\n  });\n};\n","import type {\n  Editor,\n  ElementEntryOf,\n  ElementOf,\n  NodeEntry,\n  TElement,\n} from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport type { GetSiblingListOptions } from './getSiblingList';\n\nimport { getNextList } from './getNextList';\nimport { getPreviousList } from './getPreviousList';\n\nexport interface GetListSiblingsOptions<\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n> extends Partial<GetSiblingListOptions<N, E>> {\n  current?: boolean;\n  next?: boolean;\n  previous?: boolean;\n}\n\nexport const getListSiblings = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  {\n    current = true,\n    next = true,\n    previous = true,\n    ...options\n  }: GetListSiblingsOptions<N, E> = {}\n) => {\n  const siblings: NodeEntry[] = [];\n\n  const node = entry[0] as TElement;\n\n  if (!node[KEYS.listType] && !node.hasOwnProperty(KEYS.listChecked)) {\n    return siblings;\n  }\n\n  let iterEntry = entry;\n\n  if (previous) {\n    while (true) {\n      const prevEntry = getPreviousList<N, E>(editor, iterEntry, options);\n\n      if (!prevEntry) break;\n\n      siblings.push(prevEntry);\n\n      iterEntry = prevEntry;\n    }\n  }\n  if (current) {\n    siblings.push(entry);\n  }\n  if (next) {\n    iterEntry = entry;\n\n    while (true) {\n      const nextEntry = getNextList(editor, iterEntry, options);\n\n      if (!nextEntry) break;\n\n      siblings.push(nextEntry);\n\n      iterEntry = nextEntry;\n    }\n  }\n\n  return siblings;\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  NodeApi,\n  PathApi,\n} from 'platejs';\n\nimport { type GetSiblingListOptions, getSiblingList } from './getSiblingList';\n\n/** Get the next indent list. */\nexport const getNextList = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingListOptions<N, E>>\n): NodeEntry<N> | undefined => {\n  return getSiblingList(editor, entry, {\n    getNextEntry: ([, currPath]) => {\n      const nextPath = PathApi.next(currPath);\n      const nextNode = NodeApi.get<N>(editor, nextPath);\n\n      if (!nextNode) return;\n\n      return [nextNode, nextPath];\n    },\n    ...options,\n    getPreviousEntry: undefined,\n  });\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type ElementOrTextOf,\n  type NodeEntry,\n  type TNode,\n  isDefined,\n  KEYS,\n} from 'platejs';\n\nexport interface GetSiblingListOptions<\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n> {\n  breakOnEqIndentNeqListStyleType?: boolean;\n  breakOnListRestart?: boolean;\n  breakOnLowerIndent?: boolean;\n  breakQuery?: (siblingNode: TNode, currentNode: TNode) => boolean | undefined;\n  getNextEntry?: (\n    entry: NodeEntry<ElementOrTextOf<E>>\n  ) => NodeEntry<N> | undefined;\n  getPreviousEntry?: (\n    entry: NodeEntry<ElementOrTextOf<E>>\n  ) => NodeEntry<N> | undefined;\n  /** Query to break lookup */\n  eqIndent?: boolean;\n  /** Query to validate lookup. If false, check the next sibling. */\n  query?: (siblingNode: TNode, currentNode: TNode) => boolean | undefined;\n}\n\n/**\n * Get the next sibling indent list node. Default query: the sibling node should\n * have the same listStyleType.\n */\nexport const getSiblingList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  [node, path]: ElementEntryOf<E>,\n  {\n    breakOnEqIndentNeqListStyleType = true,\n    breakOnListRestart = false,\n    breakOnLowerIndent = true,\n    breakQuery,\n    eqIndent = true,\n    getNextEntry,\n    getPreviousEntry,\n    query,\n  }: GetSiblingListOptions<N, E>\n): NodeEntry<N> | undefined => {\n  if (!getPreviousEntry && !getNextEntry) return;\n\n  const getSiblingEntry = getNextEntry ?? getPreviousEntry!;\n\n  let nextEntry = getSiblingEntry([node, path]);\n\n  while (true) {\n    if (!nextEntry) return;\n\n    const [nextNode, nextPath] = nextEntry;\n\n    const indent = (node as any)[KEYS.indent] as number;\n    const nextIndent = (nextNode as any)[KEYS.indent] as number;\n\n    if (breakQuery?.(nextNode, node)) return;\n    if (!isDefined(nextIndent)) return;\n    if (breakOnListRestart) {\n      if (getPreviousEntry && (node as any)[KEYS.listRestart]) {\n        return;\n      }\n      if (getNextEntry && (nextNode as any)[KEYS.listRestart]) {\n        return;\n      }\n    }\n    if (breakOnLowerIndent && nextIndent < indent) return;\n    if (\n      breakOnEqIndentNeqListStyleType &&\n      nextIndent === indent &&\n      (nextNode as any)[KEYS.listType] !== (node as any)[KEYS.listType]\n    )\n      return;\n\n    let valid = !query || query(nextNode, node);\n\n    if (valid) {\n      valid = !eqIndent || nextIndent === indent;\n\n      if (valid) return [nextNode, nextPath];\n    }\n\n    nextEntry = getSiblingEntry(nextEntry);\n  }\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  NodeApi,\n  PathApi,\n} from 'platejs';\n\nimport { type GetSiblingListOptions, getSiblingList } from './getSiblingList';\n\n/** Get the previous indent list node. */\nexport const getPreviousList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingListOptions<N, E>>\n): NodeEntry<N> | undefined => {\n  return getSiblingList(editor, entry, {\n    getPreviousEntry: ([, currPath]) => {\n      const prevPath = PathApi.previous(currPath);\n\n      if (!prevPath) return;\n\n      const prevNode = NodeApi.get<N>(editor, prevPath);\n\n      if (!prevNode) return;\n\n      return [prevNode, prevPath];\n    },\n    ...options,\n    getNextEntry: undefined,\n  });\n};\n","import type { ElementOf, NodeEntry, SlateEditor, TElement } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport type { ListStyleType } from '../types';\n\nimport { type GetListSiblingsOptions, getListSiblings } from './index';\n\n/**\n * Get the first sibling list style type at the given indent. If none, return\n * the entry list style type.\n */\nexport const getSiblingListStyleType = <E extends SlateEditor>(\n  editor: E,\n  {\n    entry,\n    indent,\n    ...options\n  }: {\n    entry: NodeEntry<TElement>;\n    indent: number;\n  } & GetListSiblingsOptions<ElementOf<E>, E>\n) => {\n  const siblingEntry: NodeEntry<TElement> = [{ ...entry[0], indent }, entry[1]];\n\n  const siblings = getListSiblings(editor, siblingEntry as any, {\n    breakOnEqIndentNeqListStyleType: false,\n    current: false,\n    eqIndent: true,\n    ...options,\n  });\n\n  return (\n    siblings.length > 0\n      ? siblings[0][0][KEYS.listType]\n      : entry[0][KEYS.listType]\n  ) as ListStyleType;\n};\n","import type { TElement } from 'platejs';\n\nimport { ULIST_STYLE_TYPES } from '../types';\n\nexport function isOrderedList(element: TElement) {\n  return (\n    !!element.listStyleType &&\n    !ULIST_STYLE_TYPES.includes(element.listStyleType as any)\n  );\n}\n","import type { SlateEditor } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const someList = (editor: SlateEditor, type: string[] | string) => {\n  return (\n    !!editor.selection &&\n    editor.api.some({\n      match: (n: any) => {\n        const isHasProperty = n.hasOwnProperty(KEYS.listChecked);\n\n        if (isHasProperty) {\n          return false;\n        }\n\n        const list = n[KEYS.listType];\n\n        return Array.isArray(type) ? type.includes(list) : list === type;\n      },\n    })\n  );\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nexport const someTodoList = (editor: SlateEditor) => {\n  return editor.api.some({\n    at: editor.selection!,\n    match: (n) => {\n      const list = n[KEYS.listType];\n      const isHasProperty = n.hasOwnProperty(KEYS.listChecked);\n\n      return n.type === 'p' && isHasProperty && list === KEYS.listTodo;\n    },\n  });\n};\n","import {\n  type NodeEntry,\n  type OverrideEditor,\n  type Path,\n  type TElement,\n  type TNode,\n  KEYS,\n  PathApi,\n} from 'platejs';\n\nimport type { BaseListConfig } from './BaseListPlugin';\n\nimport { withInsertBreakList } from './normalizers';\nimport { normalizeListStart } from './normalizers/normalizeListStart';\nimport { getNextList } from './queries/getNextList';\nimport { getPreviousList } from './queries/getPreviousList';\nimport { outdentList } from './transforms';\nimport { ListStyleType } from './types';\nimport { withNormalizeList } from './withNormalizeList';\n\nexport const withList: OverrideEditor<BaseListConfig> = (ctx) => {\n  const {\n    editor,\n    getOptions,\n    tf: { apply, resetBlock },\n  } = ctx;\n\n  return {\n    transforms: {\n      resetBlock(options) {\n        if (editor.api.block(options)?.[0]?.[KEYS.listType]) {\n          outdentList(editor);\n          return;\n        }\n\n        return resetBlock(options);\n      },\n      ...withNormalizeList(ctx).transforms,\n      // ...withDeleteBackwardList(ctx).transforms,\n      ...withInsertBreakList(ctx).transforms,\n      apply(operation) {\n        const { getSiblingListOptions } = getOptions();\n\n        /**\n         * If there is a previous indent list, the inserted indent list style\n         * type should be the same. Only for lower-roman and upper-roman as it\n         * overlaps with lower-alpha and upper-alpha.\n         */\n        if (operation.type === 'insert_node') {\n          const listStyleType = operation.node[KEYS.listType];\n\n          if (\n            listStyleType &&\n            ['lower-roman', 'upper-roman'].includes(\n              listStyleType as ListStyleType\n            )\n          ) {\n            const prevNodeEntry = getPreviousList<TElement>(\n              editor,\n              [operation.node as TElement, operation.path],\n              {\n                breakOnEqIndentNeqListStyleType: false,\n                eqIndent: false,\n                ...getSiblingListOptions,\n              }\n            );\n\n            if (prevNodeEntry) {\n              const prevListStyleType = prevNodeEntry[0][KEYS.listType];\n\n              if (\n                prevListStyleType === ListStyleType.LowerAlpha &&\n                listStyleType === ListStyleType.LowerRoman\n              ) {\n                operation.node[KEYS.listType] = ListStyleType.LowerAlpha;\n              } else if (\n                prevListStyleType === ListStyleType.UpperAlpha &&\n                listStyleType === ListStyleType.UpperRoman\n              ) {\n                operation.node[KEYS.listType] = ListStyleType.UpperAlpha;\n              }\n            }\n          }\n        }\n\n        /**\n         * When inserting a line break, remove listRestart and listRestartPolite\n         * from the new list item.\n         */\n        if (\n          operation.type === 'split_node' &&\n          (operation.properties as any)[KEYS.listType]\n        ) {\n          (operation.properties as any)[KEYS.listRestart] = undefined;\n          (operation.properties as any)[KEYS.listRestartPolite] = undefined;\n        }\n\n        apply(operation);\n\n        // Normalize all list items affected by the operation\n        const affectedPaths: Path[] = [];\n\n        switch (operation.type) {\n          case 'insert_node':\n          case 'remove_node':\n          case 'set_node': {\n            affectedPaths.push(operation.path);\n            break;\n          }\n          case 'merge_node': {\n            affectedPaths.push(PathApi.previous(operation.path)!);\n            break;\n          }\n          case 'move_node': {\n            affectedPaths.push(operation.path, operation.newPath);\n            break;\n          }\n          case 'split_node': {\n            affectedPaths.push(operation.path, PathApi.next(operation.path));\n            break;\n          }\n        }\n\n        const isListItem = (node: TNode) => KEYS.listType in node;\n\n        affectedPaths.forEach((affectedPath) => {\n          let entry = editor.api.node(affectedPath);\n          if (!entry) return;\n\n          /**\n           * Even if the affected node isn't a list item, the subsequent node\n           * might be, in which case we want to normalize that node instead.\n           */\n          if (!isListItem(entry[0])) {\n            entry = editor.api.node(PathApi.next(affectedPath));\n          }\n\n          // Normalize the entire list from the affected node onwards\n          while (entry && isListItem(entry[0])) {\n            const normalized = normalizeListStart<TElement>(\n              editor,\n              entry as NodeEntry<TElement>,\n              getSiblingListOptions\n            );\n\n            /**\n             * Break early since the subsequent list items will already have\n             * been normalized by the `apply` that modified the current node.\n             */\n            if (normalized) break;\n\n            entry = getNextList<TElement>(\n              editor,\n              entry as NodeEntry<TElement>,\n              {\n                ...getSiblingListOptions,\n                breakOnEqIndentNeqListStyleType: false,\n                breakOnLowerIndent: false,\n                eqIndent: false,\n              }\n            );\n          }\n        });\n      },\n    },\n  };\n};\n","import { type Editor, type NodeEntry, isDefined, KEYS } from 'platejs';\n\n/** Unset listStyle, listStart if KEYS.indent is not defined. */\nexport const normalizeListNotIndented = (\n  editor: Editor,\n  [node, path]: NodeEntry\n) => {\n  if (\n    !isDefined(node[KEYS.indent]) &&\n    (node[KEYS.listType] || node[KEYS.listStart])\n  ) {\n    editor.tf.unsetNodes([KEYS.listType, KEYS.listStart], {\n      at: path,\n    });\n\n    return true;\n  }\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  isDefined,\n  KEYS,\n} from 'platejs';\n\nimport type { GetSiblingListOptions } from '../queries/getSiblingList';\n\nimport { getPreviousList } from '../queries/getPreviousList';\n\nexport const getListExpectedListStart = (\n  entry: NodeEntry,\n  prevEntry?: NodeEntry\n): number => {\n  const [node] = entry;\n  const [prevNode] = prevEntry ?? [null];\n\n  const restart = (node[KEYS.listRestart] as number | null) ?? null;\n  const restartPolite = (node[KEYS.listRestartPolite] as number | null) ?? null;\n\n  if (restart) {\n    return restart;\n  }\n\n  if (restartPolite && !prevNode) {\n    return restartPolite;\n  }\n\n  if (prevNode) {\n    const prevListStart = (prevNode[KEYS.listStart] as number) ?? 1;\n    return prevListStart + 1;\n  }\n\n  return 1;\n};\n\nexport const normalizeListStart = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingListOptions<N, E>>\n) => {\n  return editor.tf.withoutNormalizing(() => {\n    const [node, path] = entry;\n    const listStyleType = (node as any)[KEYS.listType];\n    const listStart = node[KEYS.listStart] as number | undefined;\n\n    if (!listStyleType) return;\n\n    const prevEntry = getPreviousList(editor, entry, options);\n    const expectedListStart = getListExpectedListStart(entry, prevEntry);\n\n    if (isDefined(listStart) && expectedListStart === 1) {\n      editor.tf.unsetNodes(KEYS.listStart, { at: path });\n\n      return true;\n    }\n\n    if (listStart !== expectedListStart && expectedListStart > 1) {\n      editor.tf.setNodes({ [KEYS.listStart]: expectedListStart }, { at: path });\n\n      return true;\n    }\n\n    return false;\n  });\n};\n","import { type OverrideEditor, type TElement, isDefined, KEYS } from 'platejs';\n\nimport type { BaseListConfig } from '../BaseListPlugin';\n\nexport const withInsertBreakList: OverrideEditor<BaseListConfig> = ({\n  editor,\n  tf: { insertBreak },\n}) => {\n  return {\n    transforms: {\n      insertBreak() {\n        const nodeEntry = editor.api.above();\n\n        if (!nodeEntry) return insertBreak();\n\n        const [node, path] = nodeEntry;\n\n        if (\n          !isDefined(node[KEYS.listType]) ||\n          node[KEYS.listType] !== KEYS.listTodo ||\n          editor.api.isExpanded() ||\n          !editor.api.isEnd(editor.selection?.focus, path)\n        ) {\n          return insertBreak();\n        }\n\n        editor.tf.withoutNormalizing(() => {\n          insertBreak();\n\n          const newEntry = editor.api.above<TElement>();\n\n          if (newEntry) {\n            editor.tf.setNodes(\n              {\n                checked: false,\n              },\n              { at: newEntry[1] }\n            );\n          }\n        });\n      },\n    },\n  };\n};\n","import type { SlateEditor, TLocation } from 'platejs';\n\nimport { setIndent } from '@platejs/indent';\nimport { KEYS } from 'platejs';\n\nimport { ListStyleType } from '../types';\n\nexport interface ListOptions {\n  at?: TLocation;\n  listRestart?: number;\n  listRestartPolite?: number;\n  listStyleType?: ListStyleType | string;\n}\n\n/** Increase the indentation of the selected blocks. */\nexport const indentList = (\n  editor: SlateEditor,\n  { listStyleType = ListStyleType.Disc, ...options }: ListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: 1,\n    setNodesProps: () => ({\n      [KEYS.listType]: listStyleType,\n    }),\n    ...options,\n  });\n};\n\nexport const indentTodo = (\n  editor: SlateEditor,\n  { listStyleType = ListStyleType.Disc, ...options }: ListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: 1,\n    setNodesProps: () => ({\n      [KEYS.listChecked]: false,\n      [KEYS.listType]: listStyleType,\n    }),\n    ...options,\n  });\n};\n","import type { SlateEditor } from 'platejs';\n\nimport { setIndent } from '@platejs/indent';\nimport { KEYS } from 'platejs';\n\nimport type { ListOptions } from './indentList';\n\n/** Decrease the indentation of the selected blocks. */\nexport const outdentList = (editor: SlateEditor, options: ListOptions = {}) => {\n  setIndent(editor, {\n    offset: -1,\n    unsetNodesProps: [KEYS.listType, KEYS.listChecked],\n    ...options,\n  });\n};\n","import type { Editor, Path } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { ListStyleType } from '../types';\n\nexport const setListNode = (\n  editor: Editor,\n  {\n    at,\n    indent = 0,\n    listStyleType = ListStyleType.Disc,\n  }: {\n    at: Path;\n    indent?: number;\n    listStyleType?: string;\n  }\n) => {\n  const newIndent = indent || indent + 1;\n\n  editor.tf.setNodes(\n    {\n      [KEYS.indent]: newIndent,\n      [KEYS.listType]: listStyleType,\n    },\n    { at }\n  );\n};\n\nexport const setIndentTodoNode = (\n  editor: Editor,\n  {\n    at,\n    indent = 0,\n    listStyleType = KEYS.listTodo,\n  }: {\n    at: Path;\n    indent?: number;\n    listStyleType?: string;\n  }\n) => {\n  const newIndent = indent || indent + 1;\n\n  editor.tf.setNodes(\n    {\n      [KEYS.indent]: newIndent,\n      [KEYS.listChecked]: false,\n      [KEYS.listType]: listStyleType,\n    },\n    { at }\n  );\n};\n","import type { Editor, NodeEntry } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { ListStyleType } from '../types';\nimport { setIndentTodoNode, setListNode } from './setListNode';\n\n/**\n * Set indent list to the given entries. Add indent if listStyleType was not\n * defined.\n */\nexport const setListNodes = (\n  editor: Editor,\n  entries: NodeEntry[],\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    entries.forEach((entry) => {\n      const [node, path] = entry;\n\n      let indent = (node[KEYS.indent] as number) ?? 0;\n      indent =\n        node[KEYS.listType] || node.hasOwnProperty(KEYS.listChecked)\n          ? indent\n          : indent + 1;\n\n      if (listStyleType === 'todo') {\n        editor.tf.unsetNodes(KEYS.listType, { at: path });\n        setIndentTodoNode(editor, {\n          at: path,\n          indent,\n          listStyleType,\n        });\n\n        return;\n      }\n\n      editor.tf.unsetNodes(KEYS.listChecked, { at: path });\n      setListNode(editor, {\n        at: path,\n        indent,\n        listStyleType,\n      });\n    });\n  });\n};\n","import type { Editor, ElementEntryOf, ElementOf } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport type { GetSiblingListOptions } from '../queries/getSiblingList';\n\nimport { getListSiblings } from '../queries/getListSiblings';\nimport { ListStyleType } from '../types';\nimport { setIndentTodoNode, setListNode } from './setListNode';\n\n/** Set indent list to entry + siblings. */\nexport const setListSiblingNodes = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  {\n    getSiblingListOptions,\n    listStyleType = ListStyleType.Disc,\n  }: {\n    getSiblingListOptions?: GetSiblingListOptions<N, E>;\n    listStyleType?: string;\n  }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    const siblings = getListSiblings(editor, entry, getSiblingListOptions);\n\n    siblings.forEach(([node, path]) => {\n      if (listStyleType === KEYS.listTodo) {\n        editor.tf.unsetNodes(KEYS.listType, { at: path });\n        setIndentTodoNode(editor, {\n          at: path,\n          indent: node[KEYS.indent] as number,\n          listStyleType,\n        });\n      } else {\n        editor.tf.unsetNodes(KEYS.listChecked, { at: path });\n        setListNode(editor, {\n          at: path,\n          indent: node[KEYS.indent] as number,\n          listStyleType,\n        });\n      }\n    });\n  });\n};\n","import type { ElementEntryOf, ElementOf, SlateEditor, TElement } from 'platejs';\n\nimport { getInjectMatch, KEYS } from 'platejs';\n\nimport type { ListOptions } from './indentList';\n\nimport { BaseListPlugin } from '../BaseListPlugin';\nimport {\n  type GetSiblingListOptions,\n  getListAbove,\n  getPreviousList,\n} from '../queries';\nimport { areEqListStyleType } from '../queries/areEqListStyleType';\nimport { setListNodes } from './setListNodes';\nimport { setListSiblingNodes } from './setListSiblingNodes';\nimport { toggleListSet } from './toggleListSet';\nimport { toggleListUnset } from './toggleListUnset';\n\n/** Toggle indent list. */\nexport const toggleList = <\n  N extends ElementOf<E>,\n  E extends SlateEditor = SlateEditor,\n>(\n  editor: E,\n  options: ListOptions,\n  getSiblingListOptions?: GetSiblingListOptions<N, E>\n) => {\n  const { listRestart, listRestartPolite, listStyleType } = options;\n\n  /**\n   * True - One or more blocks were converted to lists or changed such that they\n   * remain lists.\n   *\n   * False - One or more list blocks were unset.\n   *\n   * Null - No action was taken.\n   */\n  const setList = ((): boolean | null => {\n    const { getSiblingListOptions: _getSiblingListOptions } =\n      editor.getOptions(BaseListPlugin);\n\n    if (editor.api.isCollapsed()) {\n      const entry = editor.api.block<TElement>();\n\n      if (!entry) return null;\n      if (toggleListSet(editor, entry, options)) {\n        return true;\n      }\n      if (toggleListUnset(editor, entry, { listStyleType })) {\n        return false;\n      }\n\n      setListSiblingNodes(editor, entry as ElementEntryOf<E>, {\n        getSiblingListOptions: {\n          ..._getSiblingListOptions,\n          ...getSiblingListOptions,\n        } as GetSiblingListOptions<ElementOf<E>, E>,\n        listStyleType,\n      });\n\n      return true;\n    }\n    if (editor.api.isExpanded()) {\n      const match = getInjectMatch(\n        editor,\n        editor.getPlugin({ key: KEYS.list })\n      );\n      const _entries = editor.api.nodes<TElement>({ block: true, match });\n      const entries = [..._entries];\n\n      const eqListStyleType = areEqListStyleType(editor, entries, {\n        listStyleType,\n      });\n\n      if (eqListStyleType) {\n        editor.tf.withoutNormalizing(() => {\n          entries.forEach((entry) => {\n            const [node, path] = entry;\n\n            const indent = node[KEYS.indent] as number;\n\n            editor.tf.unsetNodes(KEYS.listType, { at: path });\n\n            if (indent > 1) {\n              editor.tf.setNodes({ [KEYS.indent]: indent - 1 }, { at: path });\n            } else {\n              editor.tf.unsetNodes([KEYS.indent, KEYS.listChecked], {\n                at: path,\n              });\n            }\n            // setListNode(editor, {\n            //   listStyleType,\n            //   indent: node[KEYS.indent],\n            //   at: path,\n            // });\n          });\n        });\n\n        return false;\n      }\n\n      setListNodes(editor, entries, { listStyleType });\n      return true;\n    }\n\n    return null;\n  })();\n\n  // Apply listRestart or listRestartPolite if applicable\n  const restartValue = listRestart || listRestartPolite;\n  const isRestart = !!listRestart;\n\n  if (setList && restartValue) {\n    const atStart = editor.api.start(editor.selection!);\n    const entry = getListAbove(editor, { at: atStart });\n    if (!entry) return;\n\n    const isFirst = !getPreviousList(editor, entry);\n\n    /**\n     * Only apply listRestartPolite if this is the first item and restartValue >\n     * 1.\n     */\n    if (!isRestart && (!isFirst || restartValue <= 0)) return;\n\n    // If restartValue is 1, only apply listRestart if this is not the first\n    if (isRestart && restartValue === 1 && isFirst) return;\n\n    const prop = isRestart ? KEYS.listRestart : KEYS.listRestartPolite;\n\n    editor.tf.setNodes({ [prop]: restartValue }, { at: entry[1] });\n  }\n};\n","import type { Editor, NodeEntry } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { ListStyleType } from '../types';\nimport { type ListOptions, indentList, indentTodo } from './indentList';\n\n/** Set indent list if not set. */\nexport const toggleListSet = (\n  editor: Editor,\n  [node, _path]: NodeEntry,\n  { listStyleType = ListStyleType.Disc, ...options }: ListOptions\n) => {\n  if (node.hasOwnProperty(KEYS.listChecked) || node[KEYS.listType]) return;\n  if (listStyleType === 'todo') {\n    indentTodo(editor as any, {\n      listStyleType,\n      ...options,\n    });\n  } else {\n    indentList(editor as any, {\n      listStyleType,\n      ...options,\n    });\n  }\n\n  return true;\n};\n","import type { Editor, NodeEntry } from 'platejs';\n\nimport { KEYS } from 'platejs';\n\nimport { ListStyleType } from '../types';\nimport { outdentList } from './outdentList';\n\n/** Unset list style type if already set. */\nexport const toggleListUnset = (\n  editor: Editor,\n  [node, path]: NodeEntry,\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  if (\n    listStyleType === KEYS.listTodo &&\n    node.hasOwnProperty(KEYS.listChecked)\n  ) {\n    editor.tf.unsetNodes(KEYS.listChecked, { at: path });\n    outdentList(editor as any, { listStyleType });\n\n    return true;\n  }\n  if (listStyleType === node[KEYS.listType]) {\n    editor.tf.unsetNodes([KEYS.listType], {\n      at: path,\n    });\n\n    outdentList(editor as any, { listStyleType });\n\n    return true;\n  }\n};\n","import { type NodeEntry, type SlateEditor, KEYS } from 'platejs';\n\nexport const toggleListByPath = (\n  editor: SlateEditor,\n  [node, path]: NodeEntry,\n  listStyleType: string\n) => {\n  editor.tf.setNodes(\n    {\n      [KEYS.indent]: node.indent ?? 1,\n      // TODO: normalized if not todo remove this property.\n      [KEYS.listChecked]: false,\n      [KEYS.listType]: listStyleType,\n      type: KEYS.p,\n    },\n    {\n      at: path,\n    }\n  );\n};\n\nexport const toggleListByPathUnSet = (\n  editor: SlateEditor,\n  [, path]: NodeEntry\n) =>\n  editor.tf.unsetNodes([KEYS.listType, KEYS.indent, KEYS.listChecked], {\n    at: path,\n  });\n","import type { OverrideEditor, TElement } from 'platejs';\n\nimport type { BaseListConfig } from './BaseListPlugin';\n\nimport { normalizeListNotIndented } from './normalizers/normalizeListNotIndented';\nimport { normalizeListStart } from './normalizers/normalizeListStart';\n\nexport const withNormalizeList: OverrideEditor<BaseListConfig> = ({\n  editor,\n  getOptions,\n  tf: { normalizeNode },\n}) => {\n  return {\n    transforms: {\n      normalizeNode([node, path]) {\n        const normalized = editor.tf.withoutNormalizing(() => {\n          if (normalizeListNotIndented(editor, [node, path])) return true;\n          if (\n            normalizeListStart(\n              editor,\n              [node as TElement, path],\n              getOptions().getSiblingListOptions\n            )\n          )\n            return true;\n        });\n\n        if (normalized) return;\n\n        return normalizeNode([node, path]);\n      },\n    },\n  };\n};\n"],"mappings":"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","names":["isDefined","KEYS","ListStyleType","isDefined","KEYS","KEYS","isDefined","KEYS","isDefined","KEYS","KEYS","NodeApi","PathApi","isDefined","KEYS","PathApi","NodeApi","NodeApi","PathApi","PathApi","NodeApi","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","PathApi","isDefined","KEYS","isDefined","KEYS","KEYS","isDefined","isDefined","KEYS","KEYS","KEYS","setIndent","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","KEYS","PathApi","KEYS","props","isDefined","List"]}