{"version":3,"sources":["../src/PlaywrightPlugin.ts","../src/usePlaywrightAdapter.tsx","../src/internal/getAdapter.ts","../src/getNodeByPath.ts","../src/getDOMNodeByPath.ts","../src/clickAtPath.ts","../src/getEditable.ts","../src/getEditorHandle.ts","../src/getSelection.ts","../src/getTypeAtPath.ts","../src/setSelection.ts"],"sourcesContent":["import { KEYS } from 'platejs';\nimport { createPlatePlugin } from 'platejs/react';\n\nimport { usePlaywrightAdapter } from './usePlaywrightAdapter';\n\nexport const PlaywrightPlugin = createPlatePlugin({\n  key: KEYS.playwright,\n  useHooks: usePlaywrightAdapter,\n});\n","import { useEffect } from 'react';\n\nimport { NodeApi } from 'platejs';\nimport { type PlateEditor, useEditorRef } from 'platejs/react';\n\nimport type { TPlatePlaywrightAdapter } from './types';\n\nconst EDITABLE_TO_EDITOR = new WeakMap<HTMLElement, PlateEditor>();\n\nconst platePlaywrightAdapter: TPlatePlaywrightAdapter = {\n  EDITABLE_TO_EDITOR,\n  getNode: NodeApi.get,\n};\n\nexport const usePlaywrightAdapter = () => {\n  const editor = useEditorRef();\n\n  useEffect(() => {\n    window.platePlaywrightAdapter = platePlaywrightAdapter;\n\n    const editable = editor.api.toDOMNode(editor)!;\n    EDITABLE_TO_EDITOR.set(editable, editor);\n\n    return () => {\n      EDITABLE_TO_EDITOR.delete(editable);\n    };\n  }, [editor]);\n\n  return null;\n};\n","import type { JSHandle, Page } from '@playwright/test';\n\nimport type { TPlatePlaywrightAdapter } from '../types';\n\nexport const getAdapter = (\n  page: Page\n): Promise<JSHandle<TPlatePlaywrightAdapter>> =>\n  page.evaluateHandle(() => {\n    const adapter = window.platePlaywrightAdapter;\n\n    if (!adapter) {\n      throw new Error(\n        'window.platePlaywrightAdapter not found. Ensure that <PlatePlaywrightAdapter /> is rendered as a child of your Plate editor.'\n      );\n    }\n\n    return adapter;\n  }) as any;\n","import type { JSHandle, Page } from '@playwright/test';\nimport type { Path, TNode } from 'platejs';\n\nimport type { EditorHandle } from './types';\n\nimport { getAdapter } from './internal/getAdapter';\n\nexport const getNodeByPath = async (\n  page: Page,\n  editorHandle: EditorHandle,\n  path: Path\n): Promise<JSHandle<TNode>> => {\n  const adapterHandle = await getAdapter(page);\n\n  return page.evaluateHandle(\n    ([adapter, editor, path]) => {\n      const node = adapter.getNode(editor, path);\n\n      if (!node)\n        throw new Error(`getNodeByPath: node not found at path ${path}`);\n\n      return node;\n    },\n    [adapterHandle, editorHandle, path] as const\n  );\n};\n","import type { ElementHandle, Page } from '@playwright/test';\nimport type { Path } from 'platejs';\n\nimport type { EditorHandle } from './types';\n\nimport { getNodeByPath } from './getNodeByPath';\nimport { getAdapter } from './internal/getAdapter';\n\nexport const getDOMNodeByPath = async (\n  page: Page,\n  editorHandle: EditorHandle,\n  path: Path\n): Promise<ElementHandle> => {\n  const nodeHandle = await getNodeByPath(page, editorHandle, path);\n\n  const adapterHandle = await getAdapter(page);\n\n  return page.evaluateHandle(\n    ([, editor, node]) => {\n      const domNode = editor.api.toDOMNode(node);\n\n      if (!domNode)\n        throw new Error(`getDOMNodeByPath: DOM node not found at path ${path}`);\n\n      return domNode;\n    },\n    [adapterHandle, editorHandle, nodeHandle] as const\n  );\n};\n","import type { Page } from '@playwright/test';\nimport type { Path } from 'platejs';\n\nimport type { EditorHandle } from './types';\n\nimport { getDOMNodeByPath } from './getDOMNodeByPath';\n\nexport const clickAtPath = async (\n  page: Page,\n  editorHandle: EditorHandle,\n  path: Path\n) => {\n  const domNode = await getDOMNodeByPath(page, editorHandle, path);\n  await domNode.click();\n};\n","import type { Locator, Page } from '@playwright/test';\n\nexport const getEditable = (context: Locator | Page) =>\n  context.locator('[data-slate-editor]');\n","import type { Locator, Page } from '@playwright/test';\nimport type { PlateEditor } from 'platejs/react';\n\nimport type { EditorHandle } from './types';\n\nimport { getEditable } from './getEditable';\nimport { getAdapter } from './internal/getAdapter';\n\nexport const getEditorHandle = async <E extends PlateEditor = PlateEditor>(\n  page: Page,\n  editable?: Locator\n): Promise<EditorHandle<E>> => {\n  const editableLocator = editable ?? getEditable(page);\n  const editableCount = await editableLocator.count();\n\n  if (editableCount === 0) {\n    const error = editable\n      ? new Error(\n          'getEditorHandle: the given locator did not match any element'\n        )\n      : new Error(\n          'getEditorHandle: could not find a [data-slate-editor] on the page'\n        );\n\n    throw error;\n  } else if (editableCount > 1) {\n    const error = editable\n      ? new Error(\n          'getEditorHandle: the given locator matched more than one element'\n        )\n      : new Error(\n          'getEditorHandle: matched more than one editor. Pass a locator as the second argument of getEditorHandle to disambiguate.'\n        );\n\n    throw error;\n  }\n  if ((await editableLocator.getAttribute('data-slate-editor')) === null) {\n    throw new Error(\n      'getEditorHandle: the element matched by the given locator is not a [data-slate-editor]. Use getEditable to locate the editable element before passing it to getEditorHandle.'\n    );\n  }\n\n  const editableHandle = await editableLocator.elementHandle();\n\n  const adapterHandle = await getAdapter(page);\n\n  return page.evaluateHandle(\n    ([adapter, editable]) => {\n      const editor = adapter.EDITABLE_TO_EDITOR.get(editable as any);\n\n      if (!editor) {\n        throw new Error(\n          'getEditorHandle: could not get the editor instance for the editable. Ensure that <PlatePlaywrightAdapter /> is rendered as a child of the Plate editor.'\n        );\n      }\n\n      return editor as E;\n    },\n    [adapterHandle, editableHandle] as const\n  );\n};\n","import type { Page } from '@playwright/test';\nimport type { EditorSelection } from 'platejs';\n\nimport type { EditorHandle } from './types';\n\nexport const getSelection = async (\n  page: Page,\n  editorHandle: EditorHandle\n): Promise<EditorSelection> =>\n  page.evaluate((editor) => editor.selection, editorHandle);\n","import type { Page } from '@playwright/test';\nimport type { Path } from 'platejs';\n\nimport { ElementApi } from 'platejs';\n\nimport type { EditorHandle } from './types';\n\nimport { getNodeByPath } from './getNodeByPath';\n\nexport const getTypeAtPath = async (\n  page: Page,\n  editorHandle: EditorHandle,\n  path: Path\n): Promise<string> => {\n  const nodeHandle = await getNodeByPath(page, editorHandle, path);\n  const node = await nodeHandle.jsonValue();\n\n  if (ElementApi.isElement(node)) {\n    return node.type;\n  }\n\n  return 'text';\n};\n","import type { Page } from '@playwright/test';\nimport type { TLocation } from 'platejs';\n\nimport type { EditorHandle } from './types';\n\nexport const setSelection = async (\n  page: Page,\n  editorHandle: EditorHandle,\n  at: TLocation\n) => {\n  await page.evaluate(\n    ([editor, at]) => {\n      const range = editor.api.range(at)!;\n      console.info(range);\n      editor.tf.setSelection(range);\n    },\n    [editorHandle, at] as const\n  );\n\n  await page.waitForTimeout(200);\n};\n"],"mappings":"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","names":["path","editable","at"]}