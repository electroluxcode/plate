{"version":3,"sources":["../src/cmdk.tsx","../src/internal/command-score.ts"],"sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\n\n/* eslint-disable no-fallthrough */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n\n'use client';\n\nimport * as React from 'react';\nimport type { JSX } from 'react';\n\nimport * as RadixDialog from '@radix-ui/react-dialog';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\nimport { commandScore } from './internal/command-score';\n\n// FORK\ntype Actions = {\n  // Select current item. Can be used outside of the menu (e.g. Enter from another input).\n  selectCurrentItem: () => void;\n  // Select first item in the list\n  selectFirstItem: () => void;\n  // Select item at index\n  selectItem: (index: number) => void;\n  // Select last item in the list\n  selectLastItem: () => void;\n  // Select next group\n  selectNextGroup: (e: React.KeyboardEvent) => void;\n  // Select next item. Can be used outside of the menu (e.g. ArrowDown from another input).\n  selectNextItem: (e: React.KeyboardEvent) => void;\n  // Select previous group\n  selectPrevGroup: (e: React.KeyboardEvent) => void;\n  // Select previous item. Can be used outside of the menu (e.g. ArrowUp from another input).\n  selectPrevItem: (e: React.KeyboardEvent) => void;\n  // Set search so Input is not required and we can use another one.\n  setSearch: (search: string) => void;\n};\ntype Children = { children?: React.ReactNode };\n\ntype CommandProps = Children &\n  DivProps & {\n    /** Optional default item value when it is initially rendered. */\n    defaultValue?: string;\n    /** Optionally set to `true` to disable selection via pointer events. */\n    disablePointerSelection?: boolean;\n    /** Accessible label for this command menu. Not shown visibly. */\n    label?: string;\n    /**\n     * Optionally set to `true` to turn on looping around when using the arrow\n     * keys.\n     */\n    loop?: boolean;\n    /**\n     * Optionally set to `false` to turn off the automatic filtering and\n     * sorting. If `false`, you must conditionally render valid items based on\n     * the search query yourself.\n     */\n    shouldFilter?: boolean;\n    /** Optional controlled state of the selected command menu item. */\n    value?: string;\n    /** Set to `false` to disable ctrl+n/j/p/k shortcuts. Defaults to `true`. */\n    vimBindings?: boolean;\n    /**\n     * Custom filter function for whether each command menu item should matches\n     * the given search query. It should return a number between 0 and 1, with 1\n     * being the best match and 0 being hidden entirely. By default, uses the\n     * `command-score` library.\n     */\n    filter?: (value: string, search: string, keywords?: string[]) => number;\n    /** Event handler called when the selected item of the menu changes. */\n    onValueChange?: (value: string) => void;\n  };\ntype Context = {\n  inputId: string;\n  label: string;\n  labelId: string;\n  // Ids\n  listId: string;\n  // Refs\n  listInnerRef: React.RefObject<HTMLDivElement | null>;\n  filter: () => boolean;\n  getDisablePointerSelection: () => boolean;\n  group: (id: string) => () => void;\n  item: (id: string, groupId: string) => () => void;\n  value: (id: string, value: string, keywords?: string[]) => void;\n};\ntype DialogProps = RadixDialog.DialogProps &\n  CommandProps & {\n    /** Provide a custom element the Dialog should portal into. */\n    container?: HTMLElement;\n    /** Provide a className to the Dialog content. */\n    contentClassName?: string;\n    /** Provide a className to the Dialog overlay. */\n    overlayClassName?: string;\n  };\ntype DivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype EmptyProps = Children & DivProps & {};\ntype Group = {\n  id: string;\n  forceMount?: boolean;\n};\ntype GroupProps = Children &\n  Omit<DivProps, 'heading' | 'value'> & {\n    /** Whether this group is forcibly rendered regardless of filtering. */\n    forceMount?: boolean;\n    /** Optional heading to render for this group. */\n    heading?: React.ReactNode;\n    /**\n     * If no heading is provided, you must provide a value that is unique for\n     * this group.\n     */\n    value?: string;\n  };\ntype InputProps = Omit<\n  React.ComponentPropsWithoutRef<typeof Primitive.input>,\n  'onChange' | 'type' | 'value'\n> & {\n  /** Optional controlled state for the value of the search input. */\n  value?: string;\n  /** Event handler called when the search value changes. */\n  onValueChange?: (search: string) => void;\n};\ntype ItemProps = Children &\n  Omit<DivProps, 'disabled' | 'onSelect' | 'value'> & {\n    /** Whether this item is currently disabled. */\n    disabled?: boolean;\n    /** Whether this item is forcibly rendered regardless of filtering. */\n    forceMount?: boolean;\n    /** Optional keywords to match against when filtering. */\n    keywords?: string[];\n    /**\n     * A unique value for this item. If no value is provided, it will be\n     * inferred from `children` or the rendered `textContent`. If your\n     * `textContent` changes between renders, you _must_ provide a stable,\n     * unique `value`.\n     */\n    value?: string;\n    /**\n     * Event handler for when this item is selected, either via click or\n     * keyboard selection.\n     */\n    onSelect?: (value: string) => void;\n  };\n\ntype ListProps = Children &\n  DivProps & {\n    /** Accessible label for this List of suggestions. Not shown visibly. */\n    label?: string;\n  };\ntype LoadingProps = Children &\n  DivProps & {\n    /** Accessible label for this loading progressbar. Not shown visibly. */\n    label?: string;\n    /** Estimated progress of loading asynchronous options. */\n    progress?: number;\n  };\ntype SeparatorProps = DivProps & {\n  /**\n   * Whether this separator should always be rendered. Useful if you disable\n   * automatic filtering.\n   */\n  alwaysRender?: boolean;\n};\ntype State = {\n  filtered: { count: number; groups: Set<string>; items: Map<string, number> };\n  search: string;\n  value: string;\n};\ntype Store = {\n  emit: () => void;\n  setState: <K extends keyof State>(\n    key: K,\n    value: State[K],\n    opts?: any\n  ) => void;\n  snapshot: () => State;\n  subscribe: (callback: () => void) => () => void;\n};\n\nconst GROUP_SELECTOR = `[cmdk-group=\"\"]`;\nconst GROUP_ITEMS_SELECTOR = `[cmdk-group-items=\"\"]`;\nconst GROUP_HEADING_SELECTOR = `[cmdk-group-heading=\"\"]`;\nconst ITEM_SELECTOR = `[cmdk-item=\"\"]`;\nconst VALID_ITEM_SELECTOR = `${ITEM_SELECTOR}:not([aria-disabled=\"true\"])`;\nconst SELECT_EVENT = `cmdk-item-select`;\nconst VALUE_ATTR = `data-value`;\nconst defaultFilter: CommandProps['filter'] = (value, search, keywords) =>\n  commandScore(value, search, keywords);\n\n// @ts-ignore\nconst CommandContext = React.createContext<Context>(undefined);\nconst useCommand = () => React.useContext(CommandContext);\nconst StoreContext = React.createContext<Store>(undefined as any);\n// FORK\nconst ActionsContext = React.createContext<Actions>(undefined as any);\nconst useStore = () => React.useContext(StoreContext);\n\n// FORK\nexport const useCommandActions = () => {\n  const context = React.useContext(ActionsContext);\n\n  if (context === undefined) {\n    throw new Error(\n      'useCommandActions must be used within a Command component'\n    );\n  }\n\n  return context;\n};\n\n// @ts-ignore\nconst GroupContext = React.createContext<Group>(undefined);\n\n// const getId = (() => {\n//   let i = 0;\n//   return () => `${i++}`;\n// })();\n// const useIdCompatibility = () => {\n//   React.useState(getId);\n//   const [id] = React.useState(getId);\n//   return 'cmdk' + id;\n// };\n\nconst Command = React.forwardRef<HTMLDivElement, CommandProps>(\n  (props, forwardedRef) => {\n    const state = useLazyRef<State>(() => ({\n      filtered: {\n        /** The count of all visible items. */\n        count: 0,\n        /** Set of groups with at least one visible item. */\n        groups: new Set(),\n        /** Map from visible item id to its search score. */\n        items: new Map(),\n      },\n      /** Value of the search query. */\n      search: '',\n      /** Currently selected item value. */\n      value: props.value ?? props.defaultValue ?? '',\n    }));\n    const allItems = useLazyRef<Set<string>>(() => new Set()); // [...itemIds]\n    const allGroups = useLazyRef<Map<string, Set<string>>>(() => new Map()); // groupId → [...itemIds]\n    const ids = useLazyRef<Map<string, { value: string; keywords?: string[] }>>(\n      () => new Map()\n    ); // id → { value, keywords }\n    const listeners = useLazyRef<Set<() => void>>(() => new Set()); // [...rerenders]\n    const propsRef = useAsRef(props);\n    const {\n      children,\n      filter,\n      label,\n      loop,\n      shouldFilter,\n      value,\n      vimBindings = true,\n      onValueChange,\n      ...etc\n    } = props;\n\n    const listId = useId();\n    const labelId = useId();\n    const inputId = useId();\n\n    const listInnerRef = React.useRef<HTMLDivElement>(null);\n\n    const schedule = useScheduleLayoutEffect();\n\n    /** Controlled mode `value` handling. */\n    useLayoutEffect(() => {\n      if (value !== undefined) {\n        const v = value.trim();\n        state.current.value = v;\n        store.emit();\n      }\n    }, [value]);\n\n    useLayoutEffect(() => {\n      schedule(6, scrollSelectedIntoView);\n    }, []);\n\n    const store: Store = React.useMemo(() => {\n      return {\n        emit: () => {\n          listeners.current.forEach((l) => l());\n        },\n        setState: (key, value, opts) => {\n          if (Object.is(state.current[key], value)) return;\n\n          state.current[key] = value;\n\n          if (key === 'search') {\n            // Filter synchronously before emitting back to children\n            filterItems();\n            sort();\n            schedule(1, selectFirstItem);\n          } else if (key === 'value') {\n            // opts is a boolean referring to whether it should NOT be scrolled into view\n            if (!opts) {\n              // Scroll the selected item into view\n              schedule(5, scrollSelectedIntoView);\n            }\n            if (propsRef.current?.value !== undefined) {\n              // If controlled, just call the callback instead of updating state internally\n              const newValue = (value ?? '') as string;\n              propsRef.current.onValueChange?.(newValue);\n\n              return;\n            }\n          }\n\n          // Notify subscribers that state has changed\n          store.emit();\n        },\n        snapshot: () => {\n          return state.current;\n        },\n        subscribe: (cb) => {\n          listeners.current.add(cb);\n\n          return () => listeners.current.delete(cb);\n        },\n      };\n    }, []);\n\n    const context: Context = React.useMemo(\n      () => ({\n        inputId,\n        label: label ?? props['aria-label']!,\n        labelId,\n        listId,\n        listInnerRef,\n        filter: () => {\n          return propsRef.current.shouldFilter!;\n        },\n        getDisablePointerSelection: () => {\n          return propsRef.current.disablePointerSelection!;\n        },\n        // Track group lifecycle (mount, unmount)\n        group: (id) => {\n          if (!allGroups.current.has(id)) {\n            allGroups.current.set(id, new Set());\n          }\n\n          return () => {\n            ids.current.delete(id);\n            allGroups.current.delete(id);\n          };\n        },\n        // Track item lifecycle (mount, unmount)\n        item: (id, groupId) => {\n          allItems.current.add(id);\n\n          // Track this item within the group\n          if (groupId) {\n            if (allGroups.current.has(groupId)) {\n              allGroups.current.get(groupId)!.add(id);\n            } else {\n              allGroups.current.set(groupId, new Set([id]));\n            }\n          }\n\n          // Batch this, multiple items can mount in one pass\n          // and we should not be filtering/sorting/emitting each time\n          schedule(3, () => {\n            filterItems();\n            sort();\n\n            // Could be initial mount, select the first item if none already selected\n            if (!state.current.value) {\n              selectFirstItem();\n            }\n\n            store.emit();\n          });\n\n          return () => {\n            ids.current.delete(id);\n            allItems.current.delete(id);\n            state.current.filtered.items.delete(id);\n            const selectedItem = getSelectedItem();\n\n            // Batch this, multiple items could be removed in one pass\n            schedule(4, () => {\n              filterItems();\n\n              // The item removed have been the selected one,\n              // so selection should be moved to the first\n              if (selectedItem?.getAttribute('id') === id) selectFirstItem();\n\n              store.emit();\n            });\n          };\n        },\n        // Keep id → {value, keywords} mapping up-to-date\n        value: (id, value, keywords) => {\n          if (value !== ids.current.get(id)?.value) {\n            ids.current.set(id, { keywords, value });\n            state.current.filtered.items.set(id, score(value, keywords)!);\n            schedule(2, () => {\n              sort();\n              store.emit();\n            });\n          }\n        },\n      }),\n      []\n    );\n\n    function score(value: string, keywords?: string[]) {\n      const filter = propsRef.current?.filter ?? defaultFilter;\n\n      return value ? filter?.(value, state.current.search, keywords) : 0;\n    }\n\n    /** Sorts items by score, and groups by highest item score. */\n    function sort() {\n      if (\n        !state.current.search ||\n        // Explicitly false, because true | undefined is the default\n        propsRef.current.shouldFilter === false\n      ) {\n        return;\n      }\n\n      const scores = state.current.filtered.items;\n\n      // Sort the groups\n      const groups: [string, number][] = [];\n      state.current.filtered.groups.forEach((value) => {\n        const items = allGroups.current.get(value);\n\n        // Get the maximum score of the group's items\n        let max = 0;\n        items?.forEach((item) => {\n          const score = scores.get(item)!;\n          max = Math.max(score, max);\n        });\n\n        groups.push([value, max]);\n      });\n\n      // Sort items within groups to bottom\n      // Sort items outside of groups\n      // Sort groups to bottom (pushes all non-grouped items to the top)\n      const listInsertionElement = listInnerRef.current;\n\n      // Sort the items\n      getValidItems()\n        .sort((a, b) => {\n          const valueA = a.getAttribute('id');\n          const valueB = b.getAttribute('id');\n\n          return (scores.get(valueB!) ?? 0) - (scores.get(valueA!) ?? 0);\n        })\n        .forEach((item) => {\n          const group = item.closest(GROUP_ITEMS_SELECTOR);\n\n          if (group) {\n            group.append(\n              item.parentElement === group\n                ? item\n                : item.closest(`${GROUP_ITEMS_SELECTOR} > *`)!\n            );\n          } else {\n            listInsertionElement!.append(\n              item.parentElement === listInsertionElement\n                ? item\n                : item.closest(`${GROUP_ITEMS_SELECTOR} > *`)!\n            );\n          }\n        });\n\n      groups\n        .sort((a, b) => b[1] - a[1])\n        .forEach((group) => {\n          const element = listInnerRef.current?.querySelector(\n            `${GROUP_SELECTOR}[${VALUE_ATTR}=\"${encodeURIComponent(group[0])}\"]`\n          );\n          element?.parentElement?.append(element);\n        });\n    }\n\n    function selectFirstItem() {\n      const item = getValidItems().find(\n        (item) => item.getAttribute('aria-disabled') !== 'true'\n      );\n      const value = item?.getAttribute(VALUE_ATTR);\n      // @ts-ignore\n      store.setState('value', value ?? undefined);\n    }\n\n    /** Filters the current items. */\n    function filterItems() {\n      if (\n        !state.current.search ||\n        // Explicitly false, because true | undefined is the default\n        propsRef.current.shouldFilter === false\n      ) {\n        state.current.filtered.count = allItems.current.size;\n\n        // Do nothing, each item will know to show itself because search is empty\n        return;\n      }\n\n      // Reset the groups\n      state.current.filtered.groups = new Set();\n      let itemCount = 0;\n\n      // Check which items should be included\n      for (const id of allItems.current) {\n        const value = ids.current.get(id)?.value ?? '';\n        const keywords = ids.current.get(id)?.keywords ?? [];\n        const rank = score(value, keywords)!;\n        state.current.filtered.items.set(id, rank);\n\n        if (rank > 0) itemCount++;\n      }\n\n      // Check which groups have at least 1 item shown\n      for (const [groupId, group] of allGroups.current) {\n        for (const itemId of group) {\n          if (state.current.filtered.items.get(itemId)! > 0) {\n            state.current.filtered.groups.add(groupId);\n\n            break;\n          }\n        }\n      }\n\n      state.current.filtered.count = itemCount;\n    }\n\n    function scrollSelectedIntoView() {\n      const item = getSelectedItem();\n\n      if (item) {\n        if (item.parentElement?.firstChild === item) {\n          // First item in Group, ensure heading is in view\n          item\n            .closest(GROUP_SELECTOR)\n            ?.querySelector(GROUP_HEADING_SELECTOR)\n            ?.scrollIntoView({ block: 'nearest' });\n        }\n\n        // Ensure the item is always in view\n        item.scrollIntoView({ block: 'nearest' });\n      }\n    }\n\n    /** Getters */\n\n    function getSelectedItem() {\n      return listInnerRef.current?.querySelector(\n        `${ITEM_SELECTOR}[aria-selected=\"true\"]`\n      );\n    }\n\n    function getValidItems() {\n      return Array.from(\n        listInnerRef.current?.querySelectorAll(VALID_ITEM_SELECTOR) || []\n      );\n    }\n\n    /** Setters */\n\n    function updateSelectedToIndex(index: number) {\n      const items = getValidItems();\n      const item = items[index];\n\n      if (item) store.setState('value', item.getAttribute(VALUE_ATTR)!);\n    }\n\n    function updateSelectedByItem(change: -1 | 1) {\n      const selected = getSelectedItem()!;\n      const items = getValidItems();\n      const index = items.indexOf(selected);\n\n      // Get item at this index\n      let newSelected = items[index + change];\n\n      if (propsRef.current?.loop) {\n        newSelected =\n          index + change < 0\n            ? items.at(-1)!\n            : index + change === items.length\n              ? items[0]\n              : items[index + change];\n      }\n      if (newSelected)\n        store.setState('value', newSelected.getAttribute(VALUE_ATTR)!);\n    }\n\n    function updateSelectedByGroup(change: -1 | 1) {\n      const selected = getSelectedItem();\n      let group = selected?.closest(GROUP_SELECTOR);\n      let item: HTMLElement;\n\n      // @ts-ignore\n      while (group && !item) {\n        group =\n          change > 0\n            ? findNextSibling(group, GROUP_SELECTOR)\n            : findPreviousSibling(group, GROUP_SELECTOR);\n        item = group!.querySelector(VALID_ITEM_SELECTOR)!;\n      }\n\n      // @ts-ignore\n      if (item) {\n        store.setState('value', item.getAttribute(VALUE_ATTR)!);\n      } else {\n        updateSelectedByItem(change);\n      }\n    }\n\n    const last = () => updateSelectedToIndex(getValidItems().length - 1);\n\n    const next = (e: React.KeyboardEvent) => {\n      e.preventDefault();\n\n      if (e.metaKey) {\n        // Last item\n        last();\n      } else if (e.altKey) {\n        // Next group\n        updateSelectedByGroup(1);\n      } else {\n        // Next item\n        updateSelectedByItem(1);\n      }\n    };\n\n    const prev = (e: React.KeyboardEvent) => {\n      e.preventDefault();\n\n      if (e.metaKey) {\n        // First item\n        updateSelectedToIndex(0);\n      } else if (e.altKey) {\n        // Previous group\n        updateSelectedByGroup(-1);\n      } else {\n        // Previous item\n        updateSelectedByItem(-1);\n      }\n    };\n\n    // FORK: refactor\n    const selectItem = () => {\n      const item = getSelectedItem();\n\n      if (item) {\n        const event = new Event(SELECT_EVENT);\n        item.dispatchEvent(event);\n      }\n    };\n\n    const setSearch = (search: string) => {\n      store.setState('search', search);\n    };\n\n    const actions: Actions = React.useMemo(() => {\n      return {\n        selectCurrentItem: selectItem,\n        selectFirstItem,\n        selectItem: updateSelectedToIndex,\n        selectLastItem: last,\n        selectNextItem: next,\n        selectPrevItem: prev,\n        setSearch,\n        selectNextGroup: () => updateSelectedByGroup(1),\n        selectPrevGroup: () => updateSelectedByGroup(-1),\n      };\n    }, []);\n    // FORK END\n\n    return (\n      <Primitive.div\n        ref={forwardedRef}\n        tabIndex={-1}\n        {...etc}\n        onKeyDown={(e) => {\n          etc.onKeyDown?.(e);\n\n          if (!e.defaultPrevented) {\n            switch (e.key) {\n              case 'ArrowDown': {\n                next(e);\n\n                break;\n              }\n              case 'ArrowUp': {\n                prev(e);\n\n                break;\n              }\n              case 'End': {\n                // Last item\n                e.preventDefault();\n                last();\n\n                break;\n              }\n              case 'Enter': {\n                // Check if IME composition is finished before triggering onSelect\n                // This prevents unwanted triggering while user is still inputting text with IME\n                // e.keyCode === 229 is for the Japanese IME and Safari.\n                // isComposing does not work with Japanese IME and Safari combination.\n                if (!e.nativeEvent.isComposing && e.keyCode !== 229) {\n                  // Trigger item onSelect\n                  e.preventDefault();\n                  const item = getSelectedItem();\n\n                  if (item) {\n                    const event = new Event(SELECT_EVENT);\n                    item.dispatchEvent(event);\n                  }\n                }\n              }\n              case 'Home': {\n                // First item\n                e.preventDefault();\n                updateSelectedToIndex(0);\n\n                break;\n              }\n              case 'j':\n              case 'n': {\n                // vim keybind down\n                if (vimBindings && e.ctrlKey) {\n                  next(e);\n                }\n\n                break;\n              }\n              case 'k':\n              case 'p': {\n                // vim keybind up\n                if (vimBindings && e.ctrlKey) {\n                  prev(e);\n                }\n\n                break;\n              }\n            }\n          }\n        }}\n        cmdk-root=\"\"\n      >\n        <label\n          id={context.labelId}\n          // Screen reader only\n          style={srOnlyStyles}\n          cmdk-label=\"\"\n          htmlFor={context.inputId}\n        >\n          {label}\n        </label>\n\n        {SlottableWithNestedChildren(props, (child) => (\n          <StoreContext.Provider value={store}>\n            {/* FORK: provide actions */}\n            <ActionsContext.Provider value={actions}>\n              <CommandContext.Provider value={context}>\n                {child}\n              </CommandContext.Provider>\n            </ActionsContext.Provider>\n          </StoreContext.Provider>\n        ))}\n      </Primitive.div>\n    );\n  }\n);\n\n/**\n * Command menu item. Becomes active on pointer enter or through keyboard\n * navigation. Preferably pass a `value`, otherwise the value will be inferred\n * from `children` or the rendered item's `textContent`.\n */\nconst Item = React.forwardRef<HTMLDivElement, ItemProps>(\n  (props, forwardedRef) => {\n    const id = useId();\n    const ref = React.useRef<HTMLDivElement>(null);\n    const groupContext = React.useContext(GroupContext);\n    const context = useCommand();\n    const propsRef = useAsRef(props);\n    const forceMount = propsRef.current?.forceMount ?? groupContext?.forceMount;\n\n    useLayoutEffect(() => {\n      if (!forceMount) {\n        return context.item(id, groupContext?.id);\n      }\n    }, [forceMount]);\n\n    const value = useValue(id, ref, [props.value, props.children, ref]);\n\n    const store = useStore();\n    const selected = useCmdk(\n      (state) => state.value && state.value === value.current\n    );\n    const render = useCmdk((state) =>\n      forceMount\n        ? true\n        : context.filter() === false\n          ? true\n          : state.search\n            ? state.filtered.items.get(id)! > 0\n            : true\n    );\n\n    React.useEffect(() => {\n      const element = ref.current;\n\n      if (!element || props.disabled) return;\n\n      element.addEventListener(SELECT_EVENT, onSelect);\n\n      return () => element.removeEventListener(SELECT_EVENT, onSelect);\n    }, [render, props.onSelect, props.disabled]);\n\n    function onSelect() {\n      select();\n      propsRef.current.onSelect?.(value.current!);\n    }\n\n    function select() {\n      store.setState('value', value.current!, true);\n    }\n\n    if (!render) return null;\n\n    const {\n      disabled,\n      forceMount: ___,\n      keywords: ____,\n      value: _,\n      onSelect: __,\n      ...etc\n    } = props;\n\n    return (\n      <Primitive.div\n        ref={mergeRefs([ref, forwardedRef])}\n        {...etc}\n        id={id}\n        onClick={disabled ? undefined : onSelect}\n        onPointerMove={\n          disabled || context.getDisablePointerSelection() ? undefined : select\n        }\n        aria-disabled={Boolean(disabled)}\n        aria-selected={Boolean(selected)}\n        data-disabled={Boolean(disabled)}\n        data-selected={Boolean(selected)}\n        cmdk-item=\"\"\n        role=\"option\"\n      >\n        {props.children}\n      </Primitive.div>\n    );\n  }\n);\n\n/**\n * Group command menu items together with a heading. Grouped items are always\n * shown together.\n */\nconst Group = React.forwardRef<HTMLDivElement, GroupProps>(\n  (props, forwardedRef) => {\n    const { children, forceMount, heading, ...etc } = props;\n    const id = useId();\n    const ref = React.useRef<HTMLDivElement>(null);\n    const headingRef = React.useRef<HTMLDivElement>(null);\n    const headingId = useId();\n    const context = useCommand();\n    const render = useCmdk((state) =>\n      forceMount\n        ? true\n        : context.filter() === false\n          ? true\n          : state.search\n            ? state.filtered.groups.has(id)\n            : true\n    );\n\n    useLayoutEffect(() => {\n      return context.group(id);\n    }, []);\n\n    useValue(id, ref, [props.value, props.heading, headingRef]);\n\n    const contextValue = React.useMemo(\n      () => ({ id, forceMount }),\n      [forceMount]\n    );\n\n    return (\n      <Primitive.div\n        ref={mergeRefs([ref, forwardedRef])}\n        {...etc}\n        cmdk-group=\"\"\n        hidden={render ? undefined : true}\n        role=\"presentation\"\n      >\n        {heading && (\n          <div\n            id={headingId}\n            ref={headingRef}\n            aria-hidden\n            cmdk-group-heading=\"\"\n          >\n            {heading}\n          </div>\n        )}\n\n        {SlottableWithNestedChildren(props, (child) => (\n          <div\n            aria-labelledby={heading ? headingId : undefined}\n            cmdk-group-items=\"\"\n            role=\"group\"\n          >\n            <GroupContext.Provider value={contextValue}>\n              {child}\n            </GroupContext.Provider>\n          </div>\n        ))}\n      </Primitive.div>\n    );\n  }\n);\n\n/**\n * A visual and semantic separator between items or groups. Visible when the\n * search query is empty or `alwaysRender` is true, hidden otherwise.\n */\nconst Separator = React.forwardRef<HTMLDivElement, SeparatorProps>(\n  (props, forwardedRef) => {\n    const { alwaysRender, ...etc } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const render = useCmdk((state) => !state.search);\n\n    if (!alwaysRender && !render) return null;\n\n    return (\n      <Primitive.div\n        ref={mergeRefs([ref, forwardedRef])}\n        {...etc}\n        cmdk-separator=\"\"\n        role=\"separator\"\n      />\n    );\n  }\n);\n\n/**\n * Command menu input. All props are forwarded to the underyling `input`\n * element.\n */\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  (props, forwardedRef) => {\n    const { onValueChange, ...etc } = props;\n    const isControlled = props.value != null;\n    const store = useStore();\n    const search = useCmdk((state) => state.search);\n    const value = useCmdk((state) => state.value);\n    const context = useCommand();\n\n    const selectedItemId = React.useMemo(() => {\n      const item = context.listInnerRef.current?.querySelector(\n        `${ITEM_SELECTOR}[${VALUE_ATTR}=\"${encodeURIComponent(value)}\"]`\n      );\n\n      return item?.getAttribute('id');\n    }, []);\n\n    React.useEffect(() => {\n      if (props.value != null) {\n        store.setState('search', props.value);\n      }\n    }, [props.value]);\n\n    return (\n      <Primitive.input\n        ref={forwardedRef}\n        {...etc}\n        id={context.inputId}\n        value={isControlled ? props.value : search}\n        onChange={(e) => {\n          if (!isControlled) {\n            store.setState('search', e.target.value);\n          }\n\n          onValueChange?.(e.target.value);\n        }}\n        aria-activedescendant={selectedItemId!}\n        aria-autocomplete=\"list\"\n        aria-controls={context.listId}\n        aria-expanded={true}\n        aria-labelledby={context.labelId}\n        autoComplete=\"off\"\n        autoCorrect=\"off\"\n        cmdk-input=\"\"\n        role=\"combobox\"\n        spellCheck={false}\n        type=\"text\"\n      />\n    );\n  }\n);\n\n/**\n * Contains `Item`, `Group`, and `Separator`. Use the `--cmdk-list-height` CSS\n * variable to animate height based on the number of results.\n */\nconst List = React.forwardRef<HTMLDivElement, ListProps>(\n  (props, forwardedRef) => {\n    const { children, label = 'Suggestions', ...etc } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const height = React.useRef<HTMLDivElement>(null);\n    const context = useCommand();\n\n    React.useEffect(() => {\n      if (height.current && ref.current) {\n        const el = height.current;\n        const wrapper = ref.current;\n        let animationFrame: any;\n        const observer = new ResizeObserver(() => {\n          animationFrame = requestAnimationFrame(() => {\n            const height = el.offsetHeight;\n            wrapper.style.setProperty(\n              `--cmdk-list-height`,\n              height.toFixed(1) + 'px'\n            );\n          });\n        });\n        observer.observe(el);\n\n        return () => {\n          cancelAnimationFrame(animationFrame);\n          observer.unobserve(el);\n        };\n      }\n    }, []);\n\n    return (\n      <Primitive.div\n        ref={mergeRefs([ref, forwardedRef])}\n        {...etc}\n        id={context.listId}\n        aria-label={label}\n        cmdk-list=\"\"\n        role=\"listbox\"\n      >\n        {SlottableWithNestedChildren(props, (child) => (\n          <div\n            ref={mergeRefs([height, context.listInnerRef])}\n            cmdk-list-sizer=\"\"\n          >\n            {child}\n          </div>\n        ))}\n      </Primitive.div>\n    );\n  }\n);\n\n/** Renders the command menu in a Radix Dialog. */\nconst Dialog = React.forwardRef<HTMLDivElement, DialogProps>(\n  (props, forwardedRef) => {\n    const {\n      container,\n      contentClassName,\n      open,\n      overlayClassName,\n      onOpenChange,\n      ...etc\n    } = props;\n\n    return (\n      <RadixDialog.Root open={open} onOpenChange={onOpenChange}>\n        <RadixDialog.Portal container={container}>\n          <RadixDialog.Overlay className={overlayClassName} cmdk-overlay=\"\" />\n          <RadixDialog.Content\n            className={contentClassName}\n            aria-label={props.label}\n            cmdk-dialog=\"\"\n          >\n            <Command ref={forwardedRef} {...etc} />\n          </RadixDialog.Content>\n        </RadixDialog.Portal>\n      </RadixDialog.Root>\n    );\n  }\n);\n\n/** Automatically renders when there are no results for the search query. */\nconst Empty = React.forwardRef<HTMLDivElement, EmptyProps>(\n  (props, forwardedRef) => {\n    const render = useCmdk((state) => state.filtered.count === 0);\n\n    if (!render) return null;\n\n    return (\n      <Primitive.div\n        ref={forwardedRef}\n        {...props}\n        cmdk-empty=\"\"\n        role=\"presentation\"\n      />\n    );\n  }\n);\n\n/**\n * You should conditionally render this with `progress` while loading\n * asynchronous items.\n */\nconst Loading = React.forwardRef<HTMLDivElement, LoadingProps>(\n  (props, forwardedRef) => {\n    const { children, label = 'Loading...', progress, ...etc } = props;\n\n    return (\n      <Primitive.div\n        ref={forwardedRef}\n        {...etc}\n        aria-label={label}\n        aria-valuemax={100}\n        aria-valuemin={0}\n        aria-valuenow={progress}\n        cmdk-loading=\"\"\n        role=\"progressbar\"\n      >\n        {SlottableWithNestedChildren(props, (child) => (\n          <div aria-hidden>{child}</div>\n        ))}\n      </Primitive.div>\n    );\n  }\n);\n\nconst pkg = Object.assign(Command, {\n  Dialog,\n  Empty,\n  Group,\n  Input,\n  Item,\n  List,\n  Loading,\n  Separator,\n});\n\nexport { useCmdk as useCommandState };\n\nexport { pkg as Command };\n\nexport { defaultFilter };\n\nexport { Command as CommandRoot };\n\nexport { List as CommandList };\n\nexport { Item as CommandItem };\n\nexport { Input as CommandInput };\n\nexport { Group as CommandGroup };\n\nexport { Separator as CommandSeparator };\n\nexport { Dialog as CommandDialog };\n\nexport { Empty as CommandEmpty };\n\nexport { Loading as CommandLoading };\n\n/** Helpers */\n\nfunction findNextSibling(el: Element, selector: string) {\n  let sibling = el.nextElementSibling;\n\n  while (sibling) {\n    if (sibling.matches(selector)) return sibling;\n\n    sibling = sibling.nextElementSibling;\n  }\n}\n\nfunction findPreviousSibling(el: Element, selector: string) {\n  let sibling = el.previousElementSibling;\n\n  while (sibling) {\n    if (sibling.matches(selector)) return sibling;\n\n    sibling = sibling.previousElementSibling;\n  }\n}\n\nfunction useAsRef<T>(data: T) {\n  const ref = React.useRef<T>(data);\n\n  useLayoutEffect(() => {\n    ref.current = data;\n  });\n\n  return ref;\n}\n\nconst useLayoutEffect =\n  typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect;\n\nfunction useLazyRef<T>(fn: () => T) {\n  const ref = React.useRef<T>(undefined);\n\n  if (ref.current === undefined) {\n    ref.current = fn();\n  }\n\n  return ref as React.MutableRefObject<T>;\n}\n\n// ESM is still a nightmare with Next.js so I'm just gonna copy the package code in\n// https://github.com/gregberge/react-merge-refs\n// Copyright (c) 2020 Greg Bergé\nfunction mergeRefs<T = any>(\n  refs: (React.MutableRefObject<T> | React.Ref<T>)[]\n): React.RefCallback<T> {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        (ref as React.MutableRefObject<T | null>).current = value;\n      }\n    });\n  };\n}\n\n/** Run a selector against the store state. */\nfunction useCmdk<T = any>(selector: (state: State) => T): T {\n  const store = useStore();\n  const cb = () => selector(store.snapshot());\n\n  return useSyncExternalStore(store.subscribe, cb, cb);\n}\n\nfunction useValue(\n  id: string,\n  ref: React.RefObject<HTMLElement | null>,\n  deps: (React.ReactNode | React.RefObject<HTMLElement | null> | string)[],\n  aliases: string[] = []\n) {\n  const valueRef = React.useRef<string>(undefined);\n  const context = useCommand();\n\n  useLayoutEffect(() => {\n    const value = (() => {\n      for (const part of deps) {\n        if (typeof part === 'string') {\n          return part.trim();\n        }\n        if (typeof part === 'object' && 'current' in part!) {\n          if (part.current) {\n            return part.current.textContent?.trim();\n          }\n\n          return valueRef.current;\n        }\n      }\n    })();\n\n    const keywords = aliases.map((alias) => alias.trim());\n\n    context.value(id, value!, keywords);\n    ref.current?.setAttribute(VALUE_ATTR, value!);\n    valueRef.current = value;\n  });\n\n  return valueRef;\n}\n\n/** Imperatively run a function on the next layout effect cycle. */\nconst useScheduleLayoutEffect = () => {\n  const [s, ss] = React.useState<object>();\n  const fns = useLazyRef(() => new Map<number | string, () => void>());\n\n  useLayoutEffect(() => {\n    fns.current.forEach((f) => f());\n    fns.current = new Map();\n  }, [s]);\n\n  return (id: number | string, cb: () => void) => {\n    fns.current.set(id, cb);\n    ss({});\n  };\n};\n\nfunction renderChildren(children: React.ReactElement<any>) {\n  const childrenType = children.type as any;\n\n  // The children is a component\n  if (typeof childrenType === 'function') return childrenType(children.props);\n  // The children is a component with `forwardRef`\n  else if ('render' in childrenType) return childrenType.render(children.props);\n  // It's a string, boolean, etc.\n  else return children;\n}\n\nfunction SlottableWithNestedChildren(\n  { asChild, children }: { asChild?: boolean; children?: React.ReactNode },\n  render: (child: React.ReactNode) => JSX.Element\n) {\n  if (asChild && React.isValidElement(children)) {\n    return React.cloneElement(\n      renderChildren(children),\n      { ref: (children as any).ref },\n      render((children.props as any).children)\n    );\n  }\n\n  return render(children);\n}\n\nconst srOnlyStyles = {\n  borderWidth: '0',\n  clip: 'rect(0, 0, 0, 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: '0',\n  position: 'absolute',\n  whiteSpace: 'nowrap',\n  width: '1px',\n} as const;\n","// The scores are arranged so that a continuous match of characters will\n// result in a total score of 1.\n//\n// The best case, this character is a match, and either this is the start\n// of the string, or the previous character was also a match.\nconst // The goodness of an exact-case match should be higher than a\n  // case-insensitive match by a small amount.\n  //\n  // i.e. \"HTML\" is more likely than \"haml\" when \"HM\" is typed.\n  //\n  // This will not change the order of suggestions based on SCORE_* until\n  // 1000 characters are inserted between matches.\n  PENALTY_CASE_MISMATCH = 0.9999,\n  // Match higher for letters closer to the beginning of the word\n  // PENALTY_DISTANCE_FROM_START = 0.9,\n  // If the word has more characters than the user typed, it should\n  // be penalised slightly.\n  //\n  // i.e. \"html\" is more likely than \"html5\" if I type \"html\".\n  //\n  // However, it may well be the case that there's a sensible secondary\n  // ordering (like alphabetical) that it makes sense to rely on when\n  // there are many prefix matches, so we don't make the penalty increase\n  // with the number of tokens.\n  PENALTY_NOT_COMPLETE = 0.99,\n  // The goodness of a match should decay slightly with each missing\n  // character.\n  //\n  // i.e. \"bad\" is more likely than \"bard\" when \"bd\" is typed.\n  //\n  // This will not change the order of suggestions based on SCORE_* until\n  // 100 characters are inserted between matches.\n  PENALTY_SKIPPED = 0.999,\n  // Any other match isn't ideal, but we include it for completeness.\n  SCORE_CHARACTER_JUMP = 0.17,\n  SCORE_CONTINUE_MATCH = 1,\n  SCORE_NON_SPACE_WORD_JUMP = 0.8,\n  // A new match at the start of a word scores better than a new match\n  // elsewhere as it's more likely that the user will type the starts\n  // of fragments.\n  // NOTE: We score word jumps between spaces slightly higher than slashes, brackets\n  // hyphens, etc.\n  SCORE_SPACE_WORD_JUMP = 0.9,\n  // If the user transposed two letters, it should be significantly penalized.\n  //\n  // i.e. \"ouch\" is more likely than \"curtain\" when \"uc\" is typed.\n  SCORE_TRANSPOSITION = 0.1;\n\nconst COUNT_GAPS_REGEXP = /[\"#&(+./@[\\\\_{]/g,\n  COUNT_SPACE_REGEXP = /[\\s-]/g,\n  IS_GAP_REGEXP = /[\"#&(+./@[\\\\_{]/,\n  IS_SPACE_REGEXP = /[\\s-]/;\n\nfunction commandScoreInner(\n  string: any,\n  abbreviation: any,\n  lowerString: any,\n  lowerAbbreviation: any,\n  stringIndex: any,\n  abbreviationIndex: any,\n  memoizedResults: any\n) {\n  if (abbreviationIndex === abbreviation.length) {\n    if (stringIndex === string.length) {\n      return SCORE_CONTINUE_MATCH;\n    }\n\n    return PENALTY_NOT_COMPLETE;\n  }\n\n  const memoizeKey = `${stringIndex},${abbreviationIndex}`;\n\n  if (memoizedResults[memoizeKey] !== undefined) {\n    return memoizedResults[memoizeKey];\n  }\n\n  const abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);\n  let index = lowerString.indexOf(abbreviationChar, stringIndex);\n  let highScore = 0;\n\n  let score: any, spaceBreaks: any, transposedScore: any, wordBreaks: any;\n\n  while (index >= 0) {\n    score = commandScoreInner(\n      string,\n      abbreviation,\n      lowerString,\n      lowerAbbreviation,\n      index + 1,\n      abbreviationIndex + 1,\n      memoizedResults\n    );\n\n    if (score > highScore) {\n      if (index === stringIndex) {\n        score *= SCORE_CONTINUE_MATCH;\n      } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {\n        score *= SCORE_NON_SPACE_WORD_JUMP;\n        wordBreaks = string\n          .slice(stringIndex, index - 1)\n          .match(COUNT_GAPS_REGEXP);\n\n        if (wordBreaks && stringIndex > 0) {\n          score *= Math.pow(PENALTY_SKIPPED, wordBreaks.length);\n        }\n      } else if (IS_SPACE_REGEXP.test(string.charAt(index - 1))) {\n        score *= SCORE_SPACE_WORD_JUMP;\n        spaceBreaks = string\n          .slice(stringIndex, index - 1)\n          .match(COUNT_SPACE_REGEXP);\n\n        if (spaceBreaks && stringIndex > 0) {\n          score *= Math.pow(PENALTY_SKIPPED, spaceBreaks.length);\n        }\n      } else {\n        score *= SCORE_CHARACTER_JUMP;\n\n        if (stringIndex > 0) {\n          score *= Math.pow(PENALTY_SKIPPED, index - stringIndex);\n        }\n      }\n      if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex)) {\n        score *= PENALTY_CASE_MISMATCH;\n      }\n    }\n    if (\n      (score < SCORE_TRANSPOSITION &&\n        lowerString.charAt(index - 1) ===\n          lowerAbbreviation.charAt(abbreviationIndex + 1)) ||\n      (lowerAbbreviation.charAt(abbreviationIndex + 1) ===\n        lowerAbbreviation.charAt(abbreviationIndex) && // allow duplicate letters. Ref #7428\n        lowerString.charAt(index - 1) !==\n          lowerAbbreviation.charAt(abbreviationIndex))\n    ) {\n      transposedScore = commandScoreInner(\n        string,\n        abbreviation,\n        lowerString,\n        lowerAbbreviation,\n        index + 1,\n        abbreviationIndex + 2,\n        memoizedResults\n      );\n\n      if (transposedScore * SCORE_TRANSPOSITION > score) {\n        score = transposedScore * SCORE_TRANSPOSITION;\n      }\n    }\n    if (score > highScore) {\n      highScore = score;\n    }\n\n    index = lowerString.indexOf(abbreviationChar, index + 1);\n  }\n\n  memoizedResults[memoizeKey] = highScore;\n\n  return highScore;\n}\n\nfunction formatInput(string: string) {\n  // convert all valid space characters to space so they match each other\n  return string.toLowerCase().replaceAll(COUNT_SPACE_REGEXP, ' ');\n}\n\nexport function commandScore(\n  string: string,\n  abbreviation: string,\n  aliases?: string[]\n): number {\n  /* NOTE:\n   * in the original, we used to do the lower-casing on each recursive call, but this meant that toLowerCase()\n   * was the dominating cost in the algorithm, passing both is a little ugly, but considerably faster.\n   */\n  string =\n    aliases && aliases.length > 0\n      ? `${string + ' ' + aliases.join(' ')}`\n      : string;\n\n  return commandScoreInner(\n    string,\n    abbreviation,\n    formatInput(string),\n    formatInput(abbreviation),\n    0,\n    0,\n    {}\n  );\n}\n"],"mappings":"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","names":["useLayoutEffect","value","filter","score","item","height","useLayoutEffect"]}