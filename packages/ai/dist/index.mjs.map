{"version":3,"sources":["../src/lib/BaseAIPlugin.ts","../src/lib/transforms/insertAINodes.ts","../src/lib/transforms/removeAIMarks.ts","../src/lib/transforms/removeAINodes.ts","../src/lib/transforms/undoAI.ts","../src/lib/transforms/withAIBatch.ts","../src/lib/streaming/streamDeserializeInlineMd.ts","../src/lib/streaming/streamDeserializeMd.ts","../src/react/ai/AIPlugin.ts","../src/react/ai-chat/AIChatPlugin.ts","../src/react/ai-chat/transforms/acceptAIChat.ts","../src/react/ai-chat/transforms/insertBelowAIChat.ts","../src/react/ai-chat/transforms/replaceSelectionAIChat.ts","../src/react/ai-chat/transforms/removeAnchorAIChat.ts","../src/react/ai-chat/utils/getEditorPrompt.ts","../src/react/ai-chat/utils/getMarkdown.ts","../src/react/ai-chat/utils/resetAIChat.ts","../src/react/ai-chat/utils/submitAIChat.ts","../src/react/ai-chat/withAIChat.ts","../src/lib/streaming/utils/escapeInput.ts","../src/lib/streaming/utils/getListNode.ts","../src/lib/streaming/utils/isSameNode.ts","../src/lib/streaming/utils/nodesWithProps.ts","../src/lib/streaming/utils/utils.ts","../src/lib/streaming/streamInsertChunk.ts","../src/lib/streaming/streamSerializeMd.ts"],"sourcesContent":["import {\n  type OmitFirst,\n  type PluginConfig,\n  bindFirst,\n  createTSlatePlugin,\n  KEYS,\n} from 'platejs';\n\nimport { removeAIMarks, undoAI } from './transforms';\nimport { insertAINodes } from './transforms/insertAINodes';\nimport { removeAINodes } from './transforms/removeAINodes';\n\nexport type BaseAIPluginConfig = PluginConfig<\n  'ai',\n  {},\n  {},\n  {\n    ai: {\n      insertNodes: OmitFirst<typeof insertAINodes>;\n      removeMarks: OmitFirst<typeof removeAIMarks>;\n      removeNodes: OmitFirst<typeof removeAINodes>;\n    };\n  }\n>;\n\nexport const BaseAIPlugin = createTSlatePlugin({\n  key: KEYS.ai,\n  node: { isDecoration: false, isLeaf: true },\n}).extendTransforms(({ editor }) => ({\n  insertNodes: bindFirst(insertAINodes, editor),\n  removeMarks: bindFirst(removeAIMarks, editor),\n  removeNodes: bindFirst(removeAINodes, editor),\n  undo: bindFirst(undoAI, editor),\n}));\n","import type { Descendant, Path, SlateEditor } from 'platejs';\n\nexport const insertAINodes = (\n  editor: SlateEditor,\n  nodes: Descendant[],\n  {\n    target,\n  }: {\n    target?: Path;\n  } = {}\n) => {\n  if (!target && !editor.selection?.focus.path) return;\n\n  const aiNodes = nodes.map((node) => ({\n    ...node,\n    ai: true,\n  }));\n\n  editor.tf.withoutNormalizing(() => {\n    editor.tf.insertNodes(aiNodes, {\n      at: editor.api.end(target || editor.selection!.focus.path),\n      select: true,\n    });\n    editor.tf.collapse({ edge: 'end' });\n  });\n};\n","import { type SlateEditor, type TLocation, getPluginType, KEYS } from 'platejs';\n\nexport const removeAIMarks = (\n  editor: SlateEditor,\n  { at = [] }: { at?: TLocation } = {}\n) => {\n  const nodeType = getPluginType(editor, KEYS.ai);\n\n  editor.tf.unsetNodes(nodeType, {\n    at,\n    match: (n) => (n as any)[nodeType],\n  });\n};\n","import { type Path, type SlateEditor, TextApi } from 'platejs';\n\nexport const removeAINodes = (\n  editor: SlateEditor,\n  { at = [] }: { at?: Path } = {}\n) => {\n  editor.tf.removeNodes({\n    at,\n    match: (n) => TextApi.isText(n) && !!(n as any).ai,\n  });\n};\n","import type { SlateEditor } from 'platejs';\n\nexport const undoAI = (editor: SlateEditor) => {\n  if (\n    (editor.history.undos.at(-1) as any)?.ai &&\n    editor.api.some({\n      at: [],\n      match: (n) => !!(n as any).ai,\n    })\n  ) {\n    editor.undo();\n    editor.history.redos.pop();\n  }\n};\n","import type { History, SlateEditor } from 'platejs';\n\nexport type AIBatch = History['undos'][number] & { ai?: boolean };\n\nexport const withAIBatch = (\n  editor: SlateEditor,\n  fn: () => void,\n  {\n    split,\n  }: {\n    split?: boolean;\n  } = {}\n) => {\n  if (split) {\n    editor.tf.withNewBatch(fn);\n  } else {\n    editor.tf.withMerging(fn);\n  }\n\n  const lastBatch = editor.history.undos?.at(-1) as AIBatch | undefined;\n\n  if (lastBatch) {\n    lastBatch.ai = true;\n  }\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { type DeserializeMdOptions, MarkdownPlugin } from '@platejs/markdown';\n\nexport const streamDeserializeInlineMd = (\n  editor: PlateEditor,\n  text: string,\n  options?: DeserializeMdOptions\n) => {\n  return editor\n    .getApi(MarkdownPlugin)\n    .markdown.deserializeInline(text, options);\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { type DeserializeMdOptions, MarkdownPlugin } from '@platejs/markdown';\nimport { type TElement, getPluginType, KEYS, TextApi } from 'platejs';\n\nimport { AIChatPlugin } from '../../react';\nimport { getChunkTrimmed } from './utils';\nimport { escapeInput } from './utils/escapeInput';\n\nconst statMdxTagRegex = /<([A-Za-z][A-Za-z0-9._:-]*)(?:\\s[^>]*)?>/;\nexport const streamDeserializeMd = (\n  editor: PlateEditor,\n  data: string,\n  options?: DeserializeMdOptions\n) => {\n  const input = escapeInput(data);\n\n  const value = withoutDeserializeInMdx(editor, input);\n\n  if (Array.isArray(value)) return value;\n\n  let blocks = [];\n\n  blocks = editor.getApi(MarkdownPlugin).markdown.deserialize(input, {\n    ...options,\n    preserveEmptyParagraphs: false,\n  });\n\n  const trimmedData = getChunkTrimmed(data);\n\n  const lastBlock = blocks.at(-1) as TElement | undefined;\n\n  const addNewLine = trimmedData === '\\n\\n';\n  const unshiftNewLine =\n    getChunkTrimmed(data, { direction: 'left' }) === '\\n\\n';\n\n  const isCodeBlockOrTable =\n    lastBlock?.type === 'code_block' || lastBlock?.type === 'table';\n\n  let result = blocks;\n\n  /**\n   * Deserialize the sting like `123\\n\\n` will be `123` base on markdown spec\n   * but we want to keep the `\\n\\n`\n   */\n\n  if (\n    lastBlock &&\n    !isCodeBlockOrTable &&\n    trimmedData.length > 0 &&\n    !addNewLine\n  ) {\n    const textNode = [\n      {\n        text: trimmedData,\n      },\n    ];\n\n    const lastChild = lastBlock.children.at(-1);\n\n    /** Itâ€™s like normalizing and merging the text nodes. */\n    if (\n      lastChild &&\n      TextApi.isText(lastChild) &&\n      Object.keys(lastChild).length === 1\n    ) {\n      lastBlock.children.pop();\n\n      const textNode = [\n        {\n          text: lastChild.text + trimmedData,\n        },\n      ];\n\n      lastBlock.children.push(...textNode);\n    } else {\n      lastBlock.children.push(...textNode);\n    }\n\n    result = [...blocks.slice(0, -1), lastBlock];\n  }\n\n  if (addNewLine && !isCodeBlockOrTable) {\n    result.push({\n      children: [{ text: '' }],\n      type: KEYS.p,\n    });\n  }\n\n  if (unshiftNewLine && !isCodeBlockOrTable) {\n    result.unshift({\n      children: [{ text: '' }],\n      type: KEYS.p,\n    });\n  }\n\n  return result;\n};\n\nconst withoutDeserializeInMdx = (editor: PlateEditor, input: string) => {\n  const mdxName = editor.getOption(AIChatPlugin, '_mdxName');\n\n  if (mdxName) {\n    const isMdxEnd = input.includes(`</${mdxName}>`);\n\n    if (isMdxEnd) {\n      editor.setOption(AIChatPlugin, '_mdxName', null);\n      return false;\n    } else {\n      return [\n        {\n          children: [\n            {\n              text: input,\n            },\n          ],\n          type: getPluginType(editor, KEYS.p),\n        },\n      ];\n    }\n  } else {\n    const newMdxName = statMdxTagRegex.exec(input)?.[1];\n\n    // Avoid incorrect detection in the code block\n    if (input.startsWith(`<${newMdxName}`)) {\n      editor.setOption(AIChatPlugin, '_mdxName', newMdxName ?? null);\n    }\n  }\n};\n","import type { ExtendConfig } from 'platejs';\n\nimport { toPlatePlugin } from 'platejs/react';\n\nimport { type BaseAIPluginConfig, BaseAIPlugin } from '../../lib';\n\nexport type AIPluginConfig = ExtendConfig<BaseAIPluginConfig>;\n\nexport const AIPlugin = toPlatePlugin(BaseAIPlugin);\n","import type { TriggerComboboxPluginOptions } from '@platejs/combobox';\nimport type { UseChatHelpers } from 'ai/react';\n\nimport { BlockSelectionPlugin } from '@platejs/selection/react';\nimport {\n  type EditorNodesOptions,\n  type NodeEntry,\n  type OmitFirst,\n  type Path,\n  type PluginConfig,\n  type SlateEditor,\n  bindFirst,\n  ElementApi,\n  getPluginType,\n  KEYS,\n} from 'platejs';\nimport { createTPlatePlugin } from 'platejs/react';\n\nimport type { AIBatch } from '../../lib';\n\nimport { AIPlugin } from '../ai/AIPlugin';\nimport { removeAnchorAIChat } from './transforms';\nimport { acceptAIChat } from './transforms/acceptAIChat';\nimport { insertBelowAIChat } from './transforms/insertBelowAIChat';\nimport { replaceSelectionAIChat } from './transforms/replaceSelectionAIChat';\nimport {\n  type EditorPromptParams,\n  getEditorPrompt,\n} from './utils/getEditorPrompt';\nimport { resetAIChat } from './utils/resetAIChat';\nimport { submitAIChat } from './utils/submitAIChat';\nimport { withAIChat } from './withAIChat';\n\nexport type AIChatPluginConfig = PluginConfig<\n  'aiChat',\n  {\n    _blockChunks: string;\n    _blockPath: Path | null;\n    /** @private Using For streamInsertChunk */\n    _mdxName: string | null;\n    /** @private The Editor used to generate the AI response. */\n    aiEditor: SlateEditor | null;\n    chat: Partial<UseChatHelpers>;\n    /** @deprecated Use api.aiChat.node({streaming:true}) instead */\n    experimental_lastTextId: string | null;\n    /**\n     * Specifies how the assistant message is handled:\n     *\n     * - 'insert': Directly inserts content into the editor without preview.\n     * - 'chat': Initiates an interactive session to review and refine content\n     *   before insertion.\n     */\n    mode: 'chat' | 'insert';\n    open: boolean;\n    /** Whether the AI response is currently streaming. Cursor mode only. */\n    streaming: boolean;\n    /**\n     * Template function for generating the user prompt. Supports the following\n     * placeholders:\n     *\n     * - {block}: Replaced with the markdown of the blocks in selection.\n     * - {editor}: Replaced with the markdown of the entire editor content.\n     * - {selection}: Replaced with the markdown of the current selection.\n     * - {prompt}: Replaced with the actual user prompt.\n     */\n    promptTemplate: (props: EditorPromptParams) => string;\n    /**\n     * Template function for generating the system message. Supports the same\n     * placeholders as `promptTemplate`.\n     */\n    systemTemplate: (props: EditorPromptParams) => string | void;\n  } & TriggerComboboxPluginOptions,\n  {\n    aiChat: {\n      reset: OmitFirst<typeof resetAIChat>;\n      submit: OmitFirst<typeof submitAIChat>;\n      hide: () => void;\n      node: (\n        options?: EditorNodesOptions & { anchor?: boolean; streaming?: boolean }\n      ) => NodeEntry | undefined;\n      reload: () => void;\n      show: () => void;\n      stop: () => void;\n    };\n  },\n  {\n    aiChat: {\n      accept: OmitFirst<typeof acceptAIChat>;\n      insertBelow: OmitFirst<typeof insertBelowAIChat>;\n      replaceSelection: OmitFirst<typeof replaceSelectionAIChat>;\n      removeAnchor: (options?: EditorNodesOptions) => void;\n    };\n  }\n>;\n\nexport const AIChatPlugin = createTPlatePlugin<AIChatPluginConfig>({\n  key: KEYS.aiChat,\n  dependencies: ['ai'],\n  node: {\n    isElement: true,\n  },\n  options: {\n    _blockChunks: '',\n    _blockPath: null,\n    _mdxName: null,\n    aiEditor: null,\n    chat: { messages: [] } as any,\n    experimental_lastTextId: null,\n    mode: 'chat',\n    open: false,\n    streaming: false,\n    trigger: ' ',\n    triggerPreviousCharPattern: /^\\s?$/,\n    promptTemplate: () => '{prompt}',\n    systemTemplate: () => {},\n  },\n})\n  .overrideEditor(withAIChat)\n  .extendApi<\n    Pick<\n      AIChatPluginConfig['api']['aiChat'],\n      'node' | 'reset' | 'stop' | 'submit'\n    >\n  >(({ editor, getOption, getOptions, setOption, type }) => {\n    return {\n      reset: bindFirst(resetAIChat, editor),\n      submit: bindFirst(submitAIChat, editor),\n      node: (options = {}) => {\n        const { anchor = false, streaming = false, ...rest } = options;\n\n        if (anchor) {\n          return editor.api.node({\n            at: [],\n            match: (n) => ElementApi.isElement(n) && n.type === type,\n            ...rest,\n          });\n        }\n\n        if (streaming) {\n          if (!getOption('streaming')) return;\n\n          const path = getOption('_blockPath');\n          if (!path) return;\n\n          return editor.api.node({\n            at: path,\n            mode: 'lowest',\n            reverse: true,\n            match: (t) => !!t[getPluginType(editor, KEYS.ai)],\n            ...rest,\n          });\n        }\n\n        return editor.api.node({\n          match: (n) => n[getPluginType(editor, KEYS.ai)],\n          ...rest,\n        });\n      },\n      reload: () => {\n        const { chat, mode } = getOptions();\n\n        if (mode === 'insert') {\n          editor.getTransforms(AIPlugin).ai.undo();\n        }\n\n        void chat.reload?.({\n          body: {\n            system: getEditorPrompt(editor, {\n              promptTemplate: getOptions().systemTemplate,\n            }),\n          },\n        });\n      },\n      stop: () => {\n        setOption('streaming', false);\n        getOptions().chat.stop?.();\n      },\n    };\n  })\n  .extendApi(({ api, editor, getOptions, setOption, tf, type }) => ({\n    hide: () => {\n      api.aiChat.reset();\n\n      setOption('open', false);\n\n      if (editor.getOption(BlockSelectionPlugin, 'isSelectingSome')) {\n        // TODO\n        // editor.getApi(BlockSelectionPlugin).blockSelection.focus();\n      } else {\n        editor.tf.focus();\n      }\n\n      const lastBatch = editor.history.undos.at(-1) as AIBatch;\n\n      if (lastBatch?.ai) {\n        delete lastBatch.ai;\n      }\n\n      tf.aiChat.removeAnchor();\n    },\n    show: () => {\n      api.aiChat.reset();\n\n      getOptions().chat.setMessages?.([]);\n\n      setOption('open', true);\n    },\n  }))\n  .extendTransforms(({ editor }) => ({\n    accept: bindFirst(acceptAIChat, editor),\n    insertBelow: bindFirst(insertBelowAIChat, editor),\n    removeAnchor: bindFirst(removeAnchorAIChat, editor),\n    replaceSelection: bindFirst(replaceSelectionAIChat, editor),\n  }));\n","import { KEYS } from 'platejs';\nimport { type PlateEditor, getEditorPlugin } from 'platejs/react';\n\nimport { withAIBatch } from '../../../lib';\nimport { AIPlugin } from '../../ai/AIPlugin';\nimport { type AIChatPluginConfig, AIChatPlugin } from '../AIChatPlugin';\n\nexport const acceptAIChat = (editor: PlateEditor) => {\n  const { tf } = getEditorPlugin(editor, AIPlugin);\n  const api = editor.getApi<AIChatPluginConfig>({ key: KEYS.ai });\n\n  const lastAINodePath = api.aiChat.node({ at: [], reverse: true })![1];\n\n  withAIBatch(editor, () => {\n    tf.ai.removeMarks();\n    editor.getTransforms(AIChatPlugin).aiChat.removeAnchor();\n  });\n\n  api.aiChat.hide();\n  editor.tf.focus();\n\n  const focusPoint = editor.api.end(lastAINodePath)!;\n\n  editor.tf.setSelection({\n    anchor: focusPoint,\n    focus: focusPoint,\n  });\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { BlockSelectionPlugin } from '@platejs/selection/react';\nimport cloneDeep from 'lodash/cloneDeep.js';\nimport { type SlateEditor, KEYS, PathApi, RangeApi } from 'platejs';\n\nimport type { AIChatPluginConfig } from '../AIChatPlugin';\n\nimport { createFormattedBlocks } from './replaceSelectionAIChat';\n\nexport const insertBelowAIChat = (\n  editor: PlateEditor,\n  sourceEditor: SlateEditor,\n  { format = 'single' }: { format?: 'all' | 'none' | 'single' } = {}\n) => {\n  if (!sourceEditor || sourceEditor.api.isEmpty()) return;\n\n  const isBlockSelecting = editor.getOption(\n    BlockSelectionPlugin,\n    'isSelectingSome'\n  );\n\n  editor.getApi<AIChatPluginConfig>({ key: KEYS.ai }).aiChat.hide();\n\n  const insertBlocksAndSelect =\n    editor.getTransforms(BlockSelectionPlugin).blockSelection\n      .insertBlocksAndSelect;\n\n  if (isBlockSelecting) {\n    const selectedBlocks = editor\n      .getApi(BlockSelectionPlugin)\n      .blockSelection.getNodes();\n\n    const selectedIds = editor.getOptions(BlockSelectionPlugin).selectedIds;\n\n    if (!selectedIds || selectedIds.size === 0) return;\n\n    const lastBlock = selectedBlocks.at(-1);\n\n    if (!lastBlock) return;\n\n    const nextPath = PathApi.next(lastBlock[1]);\n\n    if (format === 'none') {\n      insertBlocksAndSelect(cloneDeep(sourceEditor.children), {\n        at: nextPath,\n      });\n\n      return;\n    }\n\n    const formattedBlocks = createFormattedBlocks({\n      blocks: cloneDeep(sourceEditor.children),\n      format,\n      sourceBlock: lastBlock,\n    });\n\n    if (!formattedBlocks) return;\n\n    insertBlocksAndSelect(formattedBlocks, {\n      at: nextPath,\n    });\n  } else {\n    const [, end] = RangeApi.edges(editor.selection!);\n    const endPath = [end.path[0]];\n    const currentBlock = editor.api.node({\n      at: endPath,\n      block: true,\n      mode: 'lowest',\n    });\n\n    if (!currentBlock) return;\n    if (format === 'none') {\n      insertBlocksAndSelect(cloneDeep(sourceEditor.children), {\n        at: PathApi.next(endPath),\n      });\n\n      return;\n    }\n\n    const formattedBlocks = createFormattedBlocks({\n      blocks: cloneDeep(sourceEditor.children),\n      format,\n      sourceBlock: currentBlock,\n    });\n\n    if (!formattedBlocks) return;\n\n    insertBlocksAndSelect(formattedBlocks, {\n      at: PathApi.next(endPath),\n    });\n  }\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport {\n  BlockSelectionPlugin,\n  removeBlockSelectionNodes,\n} from '@platejs/selection/react';\nimport cloneDeep from 'lodash/cloneDeep.js';\nimport {\n  type NodeEntry,\n  type SlateEditor,\n  type TElement,\n  KEYS,\n  NodeApi,\n  TextApi,\n} from 'platejs';\n\nimport type { AIChatPluginConfig } from '../AIChatPlugin';\n\nexport const createFormattedBlocks = ({\n  blocks,\n  format,\n  sourceBlock,\n}: {\n  blocks: TElement[];\n  format: 'all' | 'none' | 'single';\n  sourceBlock: NodeEntry;\n}) => {\n  if (format === 'none') return cloneDeep(blocks);\n\n  const [sourceNode] = sourceBlock;\n  const firstTextEntry = NodeApi.firstText(sourceNode);\n\n  if (!firstTextEntry) return null;\n\n  const blockProps = NodeApi.extractProps(sourceNode);\n  const textProps = NodeApi.extractProps(firstTextEntry[0]);\n\n  const applyTextFormatting = (node: any): any => {\n    if (TextApi.isText(node)) {\n      return { ...textProps, ...node };\n    }\n    if (node.children) {\n      return {\n        ...node,\n        children: node.children.map(applyTextFormatting),\n      };\n    }\n\n    return node;\n  };\n\n  return blocks.map((block, index) => {\n    if (format === 'single' && index > 0) {\n      return block;\n    }\n\n    return applyTextFormatting({\n      ...block,\n      ...blockProps,\n    });\n  });\n};\n\nexport const replaceSelectionAIChat = (\n  editor: PlateEditor,\n  sourceEditor: SlateEditor,\n  { format = 'single' }: { format?: 'all' | 'none' | 'single' } = {}\n) => {\n  if (!sourceEditor || sourceEditor.api.isEmpty()) return;\n\n  const isBlockSelecting = editor.getOption(\n    BlockSelectionPlugin,\n    'isSelectingSome'\n  );\n\n  editor.getApi<AIChatPluginConfig>({ key: KEYS.ai }).aiChat.hide();\n\n  // If no blocks selected, treat it like a normal selection replacement\n  if (!isBlockSelecting) {\n    const firstBlock = editor.api.node({\n      block: true,\n      mode: 'lowest',\n    });\n\n    if (\n      firstBlock &&\n      editor.api.isSelected(firstBlock[1], { contains: true }) &&\n      format !== 'none'\n    ) {\n      const formattedBlocks = createFormattedBlocks({\n        blocks: cloneDeep(sourceEditor.children),\n        format,\n        sourceBlock: firstBlock,\n      });\n\n      if (!formattedBlocks) return;\n\n      /** When user selection is cover the whole code block */\n      if (\n        firstBlock[0].type === KEYS.codeLine &&\n        sourceEditor.children[0].type === KEYS.codeBlock &&\n        sourceEditor.children.length === 1\n      ) {\n        editor.tf.insertFragment(formattedBlocks[0].children);\n      } else {\n        editor.tf.insertFragment(formattedBlocks);\n      }\n\n      editor.tf.focus();\n\n      return;\n    }\n\n    editor.tf.insertFragment(sourceEditor.children);\n    editor.tf.focus();\n\n    return;\n  }\n\n  const blockSelectionApi = editor.getApi(BlockSelectionPlugin).blockSelection;\n  const selectedBlocks = blockSelectionApi.getNodes();\n\n  if (selectedBlocks.length === 0) return;\n  // If format is 'none' or multiple blocks with 'single',\n  // just insert the content as is\n  if (format === 'none' || (format === 'single' && selectedBlocks.length > 1)) {\n    editor.tf.withoutNormalizing(() => {\n      removeBlockSelectionNodes(editor);\n\n      editor.tf.withNewBatch(() => {\n        editor\n          .getTransforms(BlockSelectionPlugin)\n          .blockSelection.insertBlocksAndSelect(\n            cloneDeep(sourceEditor.children),\n            {\n              at: selectedBlocks[0][1],\n            }\n          );\n      });\n    });\n\n    editor.getApi(BlockSelectionPlugin).blockSelection.focus();\n\n    return;\n  }\n\n  // Apply formatting from first block when:\n  // - formatting is 'all', or\n  // - only one block is selected\n  const [, firstBlockPath] = selectedBlocks[0];\n  const formattedBlocks = createFormattedBlocks({\n    blocks: cloneDeep(sourceEditor.children),\n    format,\n    sourceBlock: selectedBlocks[0],\n  });\n\n  if (!formattedBlocks) return;\n\n  editor.tf.withoutNormalizing(() => {\n    removeBlockSelectionNodes(editor);\n\n    editor.tf.withNewBatch(() => {\n      editor\n        .getTransforms(BlockSelectionPlugin)\n        .blockSelection.insertBlocksAndSelect(formattedBlocks, {\n          at: firstBlockPath,\n        });\n    });\n  });\n\n  editor.getApi(BlockSelectionPlugin).blockSelection.focus();\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport {\n  type RemoveNodesOptions,\n  ElementApi,\n  getPluginType,\n  KEYS,\n} from 'platejs';\n\nexport const removeAnchorAIChat = (\n  editor: PlateEditor,\n  options?: RemoveNodesOptions\n) => {\n  editor.tf.withoutSaving(() => {\n    editor.tf.removeNodes({\n      at: [],\n      match: (n) =>\n        ElementApi.isElement(n) &&\n        n.type === getPluginType(editor, KEYS.aiChat),\n      ...options,\n    });\n  });\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { isSelecting } from '@platejs/selection';\nimport { BlockSelectionPlugin } from '@platejs/selection/react';\n\nimport { getMarkdown } from './getMarkdown';\n\nexport type EditorPrompt =\n  | ((params: EditorPromptParams) => string)\n  | PromptConfig\n  | string;\n\nexport interface EditorPromptParams {\n  editor: PlateEditor;\n  isBlockSelecting: boolean;\n  isSelecting: boolean;\n}\n\nexport type MarkdownType = 'block' | 'editor' | 'selection';\n\nexport interface PromptConfig {\n  default: string;\n  blockSelecting?: string;\n  selecting?: string;\n}\n\nconst replacePlaceholders = (\n  editor: PlateEditor,\n  text: string,\n  {\n    prompt,\n  }: {\n    prompt?: string;\n  }\n): string => {\n  let result = text.replace('{prompt}', prompt || '');\n\n  const placeholders: Record<string, MarkdownType> = {\n    '{block}': 'block',\n    '{editor}': 'editor',\n    '{selection}': 'selection',\n  };\n\n  Object.entries(placeholders).forEach(([placeholder, type]) => {\n    if (result.includes(placeholder)) {\n      result = result.replace(placeholder, getMarkdown(editor, type));\n    }\n  });\n\n  return result;\n};\n\nconst createPromptFromConfig = (\n  config: PromptConfig,\n  params: EditorPromptParams\n): string => {\n  const { isBlockSelecting, isSelecting } = params;\n\n  if (isBlockSelecting && config.blockSelecting) {\n    return config.blockSelecting ?? config.default;\n  } else if (isSelecting && config.selecting) {\n    return config.selecting ?? config.default;\n  } else {\n    return config.default;\n  }\n};\n\nexport const getEditorPrompt = (\n  editor: PlateEditor,\n  {\n    prompt = '',\n    promptTemplate = () => '{prompt}',\n  }: {\n    prompt?: EditorPrompt;\n    promptTemplate?: (params: EditorPromptParams) => string | void;\n  } = {}\n): string | undefined => {\n  const params: EditorPromptParams = {\n    editor,\n    isBlockSelecting: editor.getOption(BlockSelectionPlugin, 'isSelectingSome'),\n    isSelecting: isSelecting(editor),\n  };\n\n  const template = promptTemplate(params);\n\n  if (!template) return;\n\n  let promptText = '';\n\n  if (typeof prompt === 'function') {\n    promptText = prompt(params);\n  } else if (typeof prompt === 'object') {\n    promptText = createPromptFromConfig(prompt, params);\n  } else {\n    promptText = prompt;\n  }\n\n  return replacePlaceholders(editor, template, {\n    prompt: promptText,\n  });\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { serializeMd } from '@platejs/markdown';\nimport { BlockSelectionPlugin } from '@platejs/selection/react';\nimport { type TElement, KEYS } from 'platejs';\n\n// Internal\nexport const getMarkdown = (\n  editor: PlateEditor,\n  type: 'block' | 'editor' | 'selection'\n) => {\n  if (type === 'editor') {\n    return serializeMd(editor);\n  }\n  if (type === 'block') {\n    const blocks = editor.getOption(BlockSelectionPlugin, 'isSelectingSome')\n      ? editor.getApi(BlockSelectionPlugin).blockSelection.getNodes()\n      : editor.api.nodes({\n          mode: 'highest',\n          match: (n) => editor.api.isBlock(n),\n        });\n\n    const nodes = Array.from(blocks, (entry) => entry[0]);\n\n    return serializeMd(editor, { value: nodes });\n  }\n  if (type === 'selection') {\n    const fragment = editor.api.fragment<TElement>();\n\n    // Remove any block formatting\n    if (fragment.length === 1) {\n      const modifiedFragment = [\n        {\n          children: fragment[0].children,\n          type: KEYS.p,\n        },\n      ];\n\n      return serializeMd(editor, { value: modifiedFragment });\n    }\n\n    return serializeMd(editor, { value: fragment });\n  }\n\n  return '';\n};\n","import { KEYS } from 'platejs';\nimport { type PlateEditor, getEditorPlugin } from 'platejs/react';\n\nimport type { AIChatPluginConfig } from '../AIChatPlugin';\n\nimport { AIPlugin } from '../../ai/AIPlugin';\n\nexport const resetAIChat = (editor: PlateEditor) => {\n  const { api, getOptions } = getEditorPlugin<AIChatPluginConfig>(editor, {\n    key: KEYS.aiChat,\n  });\n\n  api.aiChat.stop();\n\n  const chat = getOptions().chat;\n\n  if (chat.messages && chat.messages.length > 0) {\n    chat.setMessages?.([]);\n  }\n\n  editor.getTransforms(AIPlugin).ai.undo();\n};\n","import type { ChatRequestOptions } from 'ai';\n\nimport { isSelecting } from '@platejs/selection';\nimport { KEYS } from 'platejs';\nimport { type PlateEditor, getEditorPlugin } from 'platejs/react';\n\nimport type { AIChatPluginConfig } from '../AIChatPlugin';\n\nimport { AIPlugin } from '../../ai/AIPlugin';\nimport { type EditorPrompt, getEditorPrompt } from './getEditorPrompt';\n\nexport const submitAIChat = (\n  editor: PlateEditor,\n  {\n    mode,\n    options,\n    prompt,\n    system,\n  }: {\n    mode?: 'chat' | 'insert';\n    options?: ChatRequestOptions;\n    prompt?: EditorPrompt;\n    system?: EditorPrompt;\n  } = {}\n) => {\n  const { getOptions, setOption } = getEditorPlugin<AIChatPluginConfig>(\n    editor,\n    {\n      key: KEYS.aiChat,\n    }\n  );\n\n  const { chat, promptTemplate, systemTemplate } = getOptions();\n\n  if (!prompt && chat.input?.length === 0) {\n    return;\n  }\n  if (!prompt) {\n    prompt = chat.input;\n  }\n  if (!mode) {\n    mode = isSelecting(editor) ? 'chat' : 'insert';\n  }\n  if (mode === 'insert') {\n    editor.getTransforms(AIPlugin).ai.undo();\n  }\n\n  setOption('mode', mode);\n\n  chat.setInput?.('');\n\n  void chat.append?.(\n    {\n      content:\n        getEditorPrompt(editor, {\n          prompt,\n          promptTemplate,\n        }) ?? '',\n      role: 'user',\n    },\n    {\n      body: {\n        system: getEditorPrompt(editor, {\n          prompt: system,\n          promptTemplate: systemTemplate,\n        }),\n      },\n      ...options,\n    }\n  );\n};\n","import type { OverrideEditor } from 'platejs/react';\n\nimport { ElementApi, KEYS } from 'platejs';\n\nimport { AIPlugin } from '../ai/AIPlugin';\nimport { type AIChatPluginConfig, AIChatPlugin } from './AIChatPlugin';\n\nexport const withAIChat: OverrideEditor<AIChatPluginConfig> = ({\n  api,\n  editor,\n  getOptions,\n  tf: { insertText, normalizeNode, setSelection },\n  type,\n}) => {\n  const tf = editor.getTransforms(AIPlugin);\n\n  const matchesTrigger = (text: string) => {\n    const { trigger } = getOptions();\n\n    if (trigger instanceof RegExp) {\n      return trigger.test(text);\n    }\n    if (Array.isArray(trigger)) {\n      return trigger.includes(text);\n    }\n\n    return text === trigger;\n  };\n\n  return {\n    transforms: {\n      insertText(text, options) {\n        const { triggerPreviousCharPattern, triggerQuery } = getOptions();\n\n        const fn = () => {\n          if (\n            !editor.selection ||\n            !matchesTrigger(text) ||\n            (triggerQuery && !triggerQuery(editor))\n          ) {\n            return;\n          }\n\n          // Make sure an input is created at the beginning of line or after a whitespace\n          const previousChar = editor.api.string(\n            editor.api.range('before', editor.selection)\n          );\n\n          const matchesPreviousCharPattern =\n            triggerPreviousCharPattern?.test(previousChar);\n\n          if (!matchesPreviousCharPattern) return;\n\n          const nodeEntry = editor.api.block({ highest: true });\n\n          if (!nodeEntry || !editor.api.isEmpty(nodeEntry[0])) return;\n\n          api.aiChat.show();\n\n          return true;\n        };\n\n        if (fn()) return;\n\n        return insertText(text, options);\n      },\n      normalizeNode(entry) {\n        const [node, path] = entry;\n\n        if (node[KEYS.ai] && !getOptions().open) {\n          tf.ai.removeMarks({ at: path });\n\n          return;\n        }\n\n        if (\n          ElementApi.isElement(node) &&\n          node.type === type &&\n          !getOptions().open\n        ) {\n          editor.getTransforms(AIChatPlugin).aiChat.removeAnchor({ at: path });\n\n          return;\n        }\n\n        return normalizeNode(entry);\n      },\n    },\n  };\n};\n","import { isCompleteMath } from '../..';\n\nexport const escapeInput = (data: string) => {\n  let res = data;\n\n  // test case: should correctly handle inline math\n  if (\n    data.startsWith('$$') &&\n    !data.startsWith('$$\\n') &&\n    !isCompleteMath(data)\n  ) {\n    res = data.replace('$$', String.raw`\\$\\$`);\n  }\n\n  return res;\n};\n","import type { TElement } from 'platejs';\nimport type { PlateEditor } from 'platejs/react';\n\nexport const getListNode = (editor: PlateEditor, node: TElement): TElement => {\n  if (node.listStyleType && node.listStart) {\n    const previousNode = editor.api.previous({\n      at: editor.selection?.focus,\n    })?.[0];\n\n    // if previous node is also an indent list, don't need to do additional work\n    if (previousNode?.listStyleType && previousNode?.listStart) {\n      return node;\n    } else {\n      if (node.listStart === 1) return node;\n\n      return {\n        ...node,\n        listRestartPolite: node.listStart,\n      };\n    }\n  }\n\n  return node;\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { type TElement, type TText, isDefined, KEYS } from 'platejs';\n\nconst LIST_STYLE_TYPE = 'listStyleType';\n\nexport const isSameNode = (\n  editor: PlateEditor,\n  node1: TElement | TText,\n  node2: TElement | TText\n) => {\n  if (\n    node1.type !== editor.getType(KEYS.p) ||\n    node2.type !== editor.getType(KEYS.p)\n  )\n    return node1.type === node2.type;\n\n  if (isDefined(node1[LIST_STYLE_TYPE]) || isDefined(node2[LIST_STYLE_TYPE])) {\n    return node1[LIST_STYLE_TYPE] === node2[LIST_STYLE_TYPE];\n  }\n\n  return node1.type === node2.type;\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { type Descendant, ElementApi } from 'platejs';\n\nimport type { SteamInsertChunkOptions } from '../streamInsertChunk';\n\nimport { getListNode } from './getListNode';\n\nexport const nodesWithProps = (\n  editor: PlateEditor,\n  nodes: Descendant[],\n  options: SteamInsertChunkOptions\n): Descendant[] => {\n  return nodes.map((node): Descendant => {\n    if (ElementApi.isElement(node)) {\n      return {\n        ...getListNode(editor, node),\n        ...options.elementProps,\n        children: nodesWithProps(editor, node.children, options),\n      };\n    } else {\n      return {\n        ...options.textProps,\n        ...node,\n        text: node.text,\n      };\n    }\n  });\n};\n","export const getChunkTrimmed = (\n  chunk: string,\n  {\n    direction = 'right',\n  }: {\n    direction?: 'left' | 'right';\n  } = {}\n) => {\n  const str = direction === 'right' ? chunk.trimEnd() : chunk.trimStart();\n\n  if (direction === 'right') {\n    return chunk.slice(str.length);\n  } else {\n    return chunk.slice(0, chunk.length - str.length);\n  }\n};\n\nexport function isCompleteCodeBlock(str: string) {\n  const trimmed = str.trim();\n\n  const startsWithCodeBlock = trimmed.startsWith('```');\n  const endsWithCodeBlock = trimmed.endsWith('```');\n\n  return startsWithCodeBlock && endsWithCodeBlock;\n}\n\nexport function isCompleteMath(str: string) {\n  const trimmed = str.trim();\n\n  const startsWithMath = trimmed.startsWith('$$');\n  const endsWithMath = trimmed.endsWith('$$');\n\n  return startsWithMath && endsWithMath;\n}\n","import type { PlateEditor } from 'platejs/react';\n\nimport {\n  type Path,\n  type SlateEditor,\n  getPluginType,\n  KEYS,\n  NodeApi,\n  PathApi,\n} from 'platejs';\n\nimport { AIChatPlugin } from '../../react';\nimport { streamDeserializeInlineMd } from './streamDeserializeInlineMd';\nimport { streamDeserializeMd } from './streamDeserializeMd';\nimport { streamSerializeMd } from './streamSerializeMd';\nimport { isSameNode } from './utils/isSameNode';\nimport { nodesWithProps } from './utils/nodesWithProps';\n\nexport interface SteamInsertChunkOptions {\n  elementProps?: any;\n  textProps?: any;\n}\n\nconst getNextPath = (path: Path, length: number) => {\n  let result = path;\n\n  for (let i = 0; i < length; i++) {\n    result = PathApi.next(result);\n  }\n  return result;\n};\n\n/** @experimental */\nexport function streamInsertChunk(\n  editor: PlateEditor,\n  chunk: string,\n  options: SteamInsertChunkOptions = {}\n) {\n  const { _blockChunks, _blockPath } = editor.getOptions(AIChatPlugin);\n\n  if (_blockPath === null) {\n    const blocks = streamDeserializeMd(editor, chunk);\n    const path = getCurrentBlockPath(editor);\n    const startBlock = editor.api.node(path)![0];\n\n    const startInEmptyParagraph =\n      NodeApi.string(startBlock).length === 0 &&\n      startBlock.type === getPluginType(editor, KEYS.p);\n\n    // if start in empty paragraph, remove it\n    if (startInEmptyParagraph) {\n      editor.tf.removeNodes({ at: path });\n    }\n\n    if (blocks.length > 0) {\n      editor.tf.insertNodes(nodesWithProps(editor, [blocks[0]], options), {\n        at: path,\n        nextBlock: !startInEmptyParagraph,\n        select: true,\n      });\n\n      editor.setOption(AIChatPlugin, '_blockPath', getCurrentBlockPath(editor));\n      editor.setOption(AIChatPlugin, '_blockChunks', chunk);\n\n      if (blocks.length > 1) {\n        const nextBlocks = blocks.slice(1);\n\n        const nextPath = getCurrentBlockPath(editor);\n\n        editor.tf.insertNodes(nodesWithProps(editor, nextBlocks, options), {\n          at: nextPath,\n          nextBlock: true,\n          select: true,\n        });\n\n        const lastBlock = editor.api.node(\n          getNextPath(nextPath, nextBlocks.length)\n        )!;\n\n        editor.setOption(AIChatPlugin, '_blockPath', lastBlock[1]);\n\n        const lastBlockChunks = streamSerializeMd(\n          editor,\n          {\n            value: [lastBlock[0]],\n          },\n          chunk\n        );\n\n        editor.setOption(AIChatPlugin, '_blockChunks', lastBlockChunks);\n      }\n    }\n  } else {\n    const tempBlockChunks = _blockChunks + chunk;\n    const tempBlocks = streamDeserializeMd(editor, tempBlockChunks);\n\n    // console.log(\n    //   JSON.stringify(chunk),\n    //   'chunk',\n    //   '-------------------------------------------------------------------------------------------'\n    // );\n    // console.log(\n    //   'ðŸš€ ~ Streaming ~ tempBlockChunks:',\n    //   JSON.stringify(tempBlockChunks)\n    // );\n\n    // console.log('ðŸš€ ~ Streaming ~ tempBlocks:', JSON.stringify(tempBlocks));\n\n    if (tempBlocks.length === 0) {\n      return console.warn(\n        `unsupport md nodes: ${JSON.stringify(tempBlockChunks)}`\n      );\n    }\n\n    if (tempBlocks.length === 1) {\n      const currentBlock = editor.api.node(_blockPath)![0];\n\n      // If the types are the same\n      if (isSameNode(editor, currentBlock, tempBlocks[0])) {\n        const chunkNodes = streamDeserializeInlineMd(editor as any, chunk);\n\n        // Deserialize the chunk and add it to the end of the current block\n        editor.tf.insertNodes(nodesWithProps(editor, chunkNodes, options), {\n          at: editor.api.end(_blockPath),\n          select: true,\n        });\n\n        const updatedBlock = editor.api.node(_blockPath)!;\n        const serializedBlock = streamSerializeMd(\n          editor,\n          {\n            value: [updatedBlock[0]],\n          },\n          tempBlockChunks\n        );\n\n        const blockText = NodeApi.string(tempBlocks[0]);\n\n        // Verify if the editor content matches the chunk\n        if (\n          serializedBlock === tempBlockChunks &&\n          blockText === serializedBlock\n        ) {\n          editor.setOption(AIChatPlugin, '_blockChunks', tempBlockChunks);\n        } else {\n          editor.tf.replaceNodes(\n            nodesWithProps(editor, [tempBlocks[0]], options),\n            {\n              at: _blockPath,\n              select: true,\n            }\n          );\n\n          const serializedBlock = streamSerializeMd(\n            editor,\n            {\n              value: [tempBlocks[0]],\n            },\n            tempBlockChunks\n          );\n\n          editor.setOption(\n            AIChatPlugin,\n            '_blockChunks',\n            // one block includes multiple children\n            tempBlocks[0].type === getPluginType(editor, KEYS.codeBlock) ||\n              tempBlocks[0].type === getPluginType(editor, KEYS.table) ||\n              tempBlocks[0].type === getPluginType(editor, KEYS.equation)\n              ? tempBlockChunks\n              : serializedBlock\n          );\n        }\n      } else {\n        const serializedBlock = streamSerializeMd(\n          editor,\n          {\n            value: [tempBlocks[0]],\n          },\n          tempBlockChunks\n        );\n\n        editor.tf.replaceNodes(\n          nodesWithProps(editor, [tempBlocks[0]], options),\n          {\n            at: _blockPath,\n            select: true,\n          }\n        );\n\n        editor.setOption(AIChatPlugin, '_blockChunks', serializedBlock);\n      }\n    } else {\n      editor.tf.replaceNodes(nodesWithProps(editor, [tempBlocks[0]], options), {\n        at: _blockPath,\n        select: true,\n      });\n\n      if (tempBlocks.length > 1) {\n        const newEndBlockPath = getNextPath(_blockPath, tempBlocks.length - 1);\n\n        editor.tf.insertNodes(\n          nodesWithProps(editor, tempBlocks.slice(1), options),\n          {\n            at: PathApi.next(_blockPath),\n            select: true,\n          }\n        );\n\n        editor.setOption(AIChatPlugin, '_blockPath', newEndBlockPath);\n\n        const endBlock = editor.api.node(newEndBlockPath)![0];\n\n        const serializedBlock = streamSerializeMd(\n          editor,\n          {\n            value: [endBlock],\n          },\n          tempBlockChunks\n        );\n\n        editor.setOption(AIChatPlugin, '_blockChunks', serializedBlock);\n      }\n    }\n  }\n}\n\nexport const getCurrentBlockPath = (editor: SlateEditor) => {\n  const getAnchorPreviousPath = (editor: SlateEditor): Path | undefined => {\n    const anchorNode = editor\n      .getApi(AIChatPlugin)\n      .aiChat.node({ anchor: true });\n\n    if (anchorNode) {\n      return PathApi.previous(anchorNode[1])!;\n    }\n  };\n\n  const getFocusPath = (editor: SlateEditor): Path | undefined => {\n    return editor.selection?.focus.path.slice(0, 1);\n  };\n\n  const path = getAnchorPreviousPath(editor) ?? getFocusPath(editor) ?? [0];\n\n  const entry = editor.api.node(path);\n\n  // streaming in table or columns shouldn't remove them\n  if (\n    entry &&\n    (entry[0].type === getPluginType(editor, KEYS.columnGroup) ||\n      entry[0].type === getPluginType(editor, KEYS.table))\n  ) {\n    return editor.api.above()?.[1] ?? path;\n  }\n\n  return path;\n};\n","import type { PlateEditor } from 'platejs/react';\n\nimport { type SerializeMdOptions, MarkdownPlugin } from '@platejs/markdown';\nimport {\n  type Descendant,\n  ElementApi,\n  getPluginKey,\n  KEYS,\n  TextApi,\n} from 'platejs';\n\nimport { getChunkTrimmed, isCompleteCodeBlock, isCompleteMath } from './utils';\n\n// fixes test: should serialize heading with tailing line break\n// fixes test: incomplete line breaks\nconst trimEndHeading = (\n  editor: PlateEditor,\n  value: Descendant[]\n): { trimmedText: string; value: Descendant[] } => {\n  const headingKeys = new Set([\n    KEYS.h1,\n    KEYS.h2,\n    KEYS.h3,\n    KEYS.h4,\n    KEYS.h5,\n    KEYS.h6,\n  ]);\n  const lastBlock = value.at(-1);\n\n  if (\n    lastBlock &&\n    headingKeys.has(\n      (getPluginKey(editor, lastBlock.type as string) ?? lastBlock.type) as any\n    ) &&\n    ElementApi.isElement(lastBlock)\n  ) {\n    const lastTextNode = lastBlock.children.at(-1);\n\n    if (TextApi.isText(lastTextNode)) {\n      const trimmedText = getChunkTrimmed(lastTextNode?.text as string);\n\n      // Create a new lastBlock with immutable operations\n      const newChildren = [\n        ...lastBlock.children.slice(0, -1),\n        { text: lastTextNode.text.trimEnd() },\n      ];\n\n      const newLastBlock = {\n        ...lastBlock,\n        children: newChildren,\n      };\n\n      return {\n        trimmedText: trimmedText,\n        value: [...value.slice(0, -1), newLastBlock],\n      };\n    }\n  }\n\n  return { trimmedText: '', value };\n};\n\nexport const streamSerializeMd = (\n  editor: PlateEditor,\n  options: SerializeMdOptions,\n  chunk: string\n) => {\n  const { value: optionsValue, ...restOptions } = options;\n  const { value } = trimEndHeading(editor, optionsValue ?? editor.children);\n\n  let result = '';\n\n  result = editor.getApi(MarkdownPlugin).markdown.serialize({\n    preserveEmptyParagraphs: false,\n    value: value,\n    ...restOptions,\n  });\n\n  const trimmedChunk = getChunkTrimmed(chunk);\n\n  if (isCompleteCodeBlock(result) && !chunk.endsWith('```')) {\n    result = result.trimEnd().slice(0, -3) + trimmedChunk;\n  }\n\n  if (isCompleteMath(result) && !chunk.endsWith('$$')) {\n    result = result.trimEnd().slice(0, -3) + trimmedChunk;\n  }\n\n  // clean HTML spaces and zero-width characters\n  result = result.replace(/&#x20;/g, ' ');\n  result = result.replace(/&#x200B;/g, ' ');\n  result = result.replace(/\\u200B/g, '');\n\n  // remove extra \\n but not include \\n itself\n  // FIXME maybe failed when chunk is more than two'\\n'\n  if (trimmedChunk !== '\\n\\n') {\n    result = result.trimEnd() + trimmedChunk;\n  }\n\n  // Handle empty paragraph case for streaming\n  if (chunk.endsWith('\\n\\n')) {\n    if (result === '\\n') {\n      // Single empty paragraph case\n      result = '';\n    } else if (result.endsWith('\\n\\n')) {\n      // Multiple paragraphs ending with empty paragraph\n      result = result.slice(0, -1);\n    }\n  }\n\n  // replace &#x20; to real space\n\n  // remove Markdown escape characters (including those potentially added in the chunk)\n  result = result.replace(/\\\\([\\\\`*_{}\\\\[\\]()#+\\-\\\\.!~<>|$])/g, '$1');\n\n  return result;\n};\n"],"mappings":"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","names":["KEYS","KEYS","MarkdownPlugin","getPluginType","KEYS","TextApi","BlockSelectionPlugin","bindFirst","ElementApi","getPluginType","KEYS","KEYS","KEYS","BlockSelectionPlugin","cloneDeep","KEYS","KEYS","TextApi","formattedBlocks","BlockSelectionPlugin","KEYS","cloneDeep","getPluginType","KEYS","BlockSelectionPlugin","BlockSelectionPlugin","KEYS","isSelecting","BlockSelectionPlugin","KEYS","getEditorPlugin","getEditorPlugin","KEYS","isSelecting","KEYS","getEditorPlugin","getEditorPlugin","KEYS","isSelecting","ElementApi","KEYS","KEYS","ElementApi","KEYS","bindFirst","ElementApi","getPluginType","BlockSelectionPlugin","KEYS","ElementApi","ElementApi","MarkdownPlugin","TextApi","textNode","KEYS","getPluginType","getPluginType","KEYS","NodeApi","PathApi","MarkdownPlugin","ElementApi","KEYS","TextApi","KEYS","ElementApi","TextApi","MarkdownPlugin","PathApi","NodeApi","getPluginType","KEYS","serializedBlock","editor"]}