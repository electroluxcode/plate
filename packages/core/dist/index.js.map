{"version":3,"sources":["../src/index.ts","../src/lib/editor/withSlate.ts","../src/internal/plugin/resolvePlugins.ts","../src/lib/plugin/createSlatePlugin.ts","../src/internal/utils/isFunction.ts","../src/internal/utils/mergePlugins.ts","../src/lib/plugin/getEditorPlugin.ts","../src/internal/plugin/resolvePlugin.ts","../src/lib/plugin/getSlatePlugin.ts","../src/lib/plugins/AstPlugin.ts","../src/lib/plugins/HistoryPlugin.ts","../src/lib/plugins/paragraph/BaseParagraphPlugin.ts","../src/lib/plugins/override/withBreakRules.ts","../src/lib/plugins/override/withDeleteRules.ts","../src/lib/plugins/override/withMergeRules.ts","../src/lib/plugins/override/withNormalizeRules.ts","../src/lib/plugins/override/OverridePlugin.ts","../src/internal/plugin/pipeInsertFragment.ts","../src/internal/plugin/pipeTransformData.ts","../src/internal/plugin/pipeTransformFragment.ts","../src/lib/utils/applyDeepToNodes.ts","../src/lib/utils/defaultsDeepToNodes.ts","../src/lib/utils/getInjectMatch.ts","../src/lib/utils/getInjectedPlugins.ts","../src/lib/utils/getPluginNodeProps.ts","../src/lib/static/pipeRenderElementStatic.tsx","../src/lib/static/components/slate-nodes.tsx","../src/lib/static/pluginRenderElementStatic.tsx","../src/lib/static/utils/createStaticString.ts","../src/lib/static/utils/getNodeDataAttributes.ts","../src/lib/static/utils/getRenderNodeStaticProps.ts","../src/internal/plugin/pipeInjectNodeProps.tsx","../src/internal/plugin/isEditOnlyDisabled.ts","../src/internal/plugin/pluginInjectNodeProps.ts","../src/lib/static/utils/getSelectedDomBlocks.ts","../src/lib/static/utils/getSelectedDomFragment.tsx","../src/lib/static/utils/getSelectedDomNode.ts","../src/lib/static/utils/isSelectOutside.ts","../src/lib/static/utils/pipeDecorate.ts","../src/lib/static/utils/stripHtmlClassNames.ts","../src/lib/static/utils/stripSlateDataAttributes.ts","../src/lib/static/pluginRenderLeafStatic.tsx","../src/lib/static/components/PlateStatic.tsx","../src/lib/static/pluginRenderTextStatic.tsx","../src/lib/static/serializeHtml.tsx","../src/lib/static/deserialize/checkUtils.ts","../src/lib/static/deserialize/htmlStringToEditorDOM.ts","../src/lib/static/editor/withStatic.tsx","../src/lib/plugins/affinity/AffinityPlugin.ts","../src/lib/plugins/affinity/queries/getEdgeNodes.ts","../src/lib/plugins/affinity/queries/getMarkBoundaryAffinity.ts","../src/lib/plugins/affinity/queries/isNodeAffinity.ts","../src/lib/plugins/affinity/transforms/setAffinitySelection.ts","../src/lib/plugins/chunking/ChunkingPlugin.ts","../src/lib/plugins/chunking/withChunking.ts","../src/lib/plugins/debug/DebugPlugin.ts","../src/lib/plugins/dom/DOMPlugin.ts","../src/lib/plugins/dom/withScrolling.ts","../src/lib/plugins/html/HtmlPlugin.ts","../src/lib/plugins/html/constants.ts","../src/lib/plugins/html/utils/isHtmlElement.ts","../src/lib/plugins/html/utils/traverseHtmlNode.ts","../src/lib/plugins/html/utils/traverseHtmlElements.ts","../src/lib/plugins/html/utils/cleanHtmlBrElements.ts","../src/lib/plugins/html/utils/cleanHtmlCrLf.ts","../src/lib/plugins/html/utils/cleanHtmlEmptyElements.ts","../src/lib/plugins/html/utils/replaceTagName.ts","../src/lib/plugins/html/utils/cleanHtmlFontElements.ts","../src/lib/plugins/html/utils/isHtmlFragmentHref.ts","../src/lib/plugins/html/utils/unwrapHtmlElement.ts","../src/lib/plugins/html/utils/cleanHtmlLinkElements.ts","../src/lib/plugins/html/utils/isHtmlText.ts","../src/lib/plugins/html/utils/traverseHtmlTexts.ts","../src/lib/plugins/html/utils/cleanHtmlTextNodes.ts","../src/lib/plugins/html/utils/inlineTagNames.ts","../src/lib/plugins/html/utils/isHtmlInlineElement.ts","../src/lib/plugins/html/utils/isHtmlBlockElement.ts","../src/lib/plugins/html/utils/isHtmlTable.ts","../src/lib/plugins/html/utils/copyBlockMarksToSpanChild.ts","../src/lib/utils/normalizeDescendantsToDocumentFragment.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseString.ts","../src/lib/plugins/html/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts","../src/lib/plugins/html/utils/collapse-white-space/stateTransforms.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceText.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceNode.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceChildren.ts","../src/lib/plugins/html/utils/collapse-white-space/inferWhiteSpaceRule.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceElement.ts","../src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpace.ts","../src/lib/plugins/html/utils/htmlBodyToFragment.ts","../src/lib/plugins/html/utils/deserializeHtmlNodeChildren.ts","../src/lib/plugins/html/utils/htmlBrToNewLine.ts","../src/lib/plugins/html/utils/htmlElementToElement.ts","../src/lib/plugins/html/utils/pluginDeserializeHtml.ts","../src/lib/plugins/html/utils/getDataNodeProps.ts","../src/lib/plugins/html/utils/pipeDeserializeHtmlElement.ts","../src/lib/plugins/html/utils/htmlElementToLeaf.ts","../src/lib/plugins/html/utils/pipeDeserializeHtmlLeaf.ts","../src/lib/plugins/html/utils/htmlTextNodeToString.ts","../src/lib/plugins/html/utils/deserializeHtmlNode.ts","../src/lib/plugins/html/utils/deserializeHtmlElement.ts","../src/lib/plugins/html/utils/htmlStringToDOMNode.ts","../src/lib/plugins/html/utils/deserializeHtml.ts","../src/lib/plugins/html/utils/findHtmlElement.ts","../src/lib/plugins/html/utils/getHtmlComments.ts","../src/lib/plugins/html/utils/isHtmlComment.ts","../src/lib/plugins/html/utils/isOlSymbol.ts","../src/lib/plugins/html/utils/parseHtmlDocument.ts","../src/lib/plugins/html/utils/parseHtmlElement.ts","../src/lib/plugins/html/utils/postCleanHtml.ts","../src/lib/plugins/html/utils/removeHtmlSurroundings.ts","../src/lib/plugins/html/utils/preCleanHtml.ts","../src/lib/plugins/html/utils/traverseHtmlComments.ts","../src/lib/plugins/html/utils/removeHtmlNodesBetweenComments.ts","../src/lib/plugins/length/LengthPlugin.ts","../src/lib/plugins/node-id/NodeIdPlugin.ts","../src/lib/plugins/node-id/withNodeId.ts","../src/lib/plugins/slate-extension/SlateExtensionPlugin.ts","../src/lib/utils/pipeOnNodeChange.ts","../src/lib/utils/pipeOnTextChange.ts","../src/internal/plugin/pipeNormalizeInitialValue.ts","../src/lib/plugins/slate-extension/transforms/init.ts","../src/lib/plugins/slate-extension/transforms/insertExitBreak.ts","../src/lib/plugins/slate-extension/transforms/resetBlock.ts","../src/lib/plugins/slate-extension/transforms/setValue.ts","../src/lib/static/internal/getPlainText.tsx","../src/lib/static/plugins/ViewPlugin.ts","../src/lib/static/plugins/getStaticPlugins.ts","../src/lib/utils/getSlateClass.ts","../src/lib/utils/hotkeys.ts","../src/lib/utils/isType.ts","../src/lib/utils/mergeDeepToNodes.ts","../src/lib/utils/omitPluginContext.ts","../src/lib/utils/overridePluginsByKey.ts","../src/lib/utils/pipeInsertDataQuery.ts","../src/lib/plugins/ParserPlugin.ts","../src/lib/plugins/getCorePlugins.ts","../src/lib/libs/nanoid.ts","../src/lib/libs/zustand.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import {\n  type Editor,\n  type TSelection,\n  type Value,\n  createEditor,\n} from '@platejs/slate';\nimport { nanoid } from 'nanoid';\n\nimport type { AnyPluginConfig, NodeComponents } from '../plugin/BasePlugin';\nimport type { AnySlatePlugin } from '../plugin/SlatePlugin';\nimport type { ChunkingConfig } from '../plugins/chunking';\nimport type { NodeIdConfig } from '../plugins/node-id/NodeIdPlugin';\nimport type { InferPlugins, SlateEditor, TSlateEditor } from './SlateEditor';\n\nimport { resolvePlugins } from '../../internal/plugin/resolvePlugins';\nimport { createSlatePlugin } from '../plugin/createSlatePlugin';\nimport { getPluginType, getSlatePlugin } from '../plugin/getSlatePlugin';\nimport { type CorePlugin, getCorePlugins } from '../plugins/getCorePlugins';\n\nexport type BaseWithSlateOptions<P extends AnyPluginConfig = CorePlugin> = {\n  /**\n   * Unique identifier for the editor instance.\n   *\n   * @default nanoid()\n   */\n  id?: string;\n  /**\n   * Determines which mark/element to apply at boundaries between different\n   * marks, based on cursor movement using the left/right arrow keys.\n   *\n   * Example: <text bold>Bold</text><cursor><text italic>Italic</text>\n   *\n   * If the cursor moved here from the left (via → key), typing applies\n   * **bold**.\n   *\n   * If the cursor moved here from the right (via ← key), typing applies\n   * _italic_.\n   *\n   * Without mark affinity, the preceding mark (**bold**) is always applied\n   * regardless of direction.\n   *\n   * @default true\n   */\n  affinity?: boolean;\n  /**\n   * Select the editor after initialization.\n   *\n   * @default false\n   *\n   * - `true` | 'end': Select the end of the editor\n   * - `false`: Do not select anything\n   * - `'start'`: Select the start of the editor\n   */\n  autoSelect?: boolean | 'end' | 'start';\n  /**\n   * Configure Slate's chunking optimization, which reduces latency while\n   * typing. Set to `false` to disable.\n   *\n   * @default true\n   * @see https://docs.slatejs.org/walkthroughs/09-performance\n   */\n  chunking?: ChunkingConfig['options'] | boolean;\n  /** Specifies the component for each plugin key. */\n  components?: NodeComponents;\n  /** Specifies the component for each plugin key. */\n  // components?: Partial<\n  //   Record<KeyofNodePlugins<InferPlugins<P[]>>, NodeComponent | null>\n  // >;\n  /**\n   * Specifies the maximum number of characters allowed in the editor. When the\n   * limit is reached, further input will be prevented.\n   */\n  maxLength?: number;\n  /**\n   * Configuration for automatic node ID generation and management.\n   *\n   * Unless set to `false`, the editor automatically adds unique IDs to nodes\n   * through the core NodeIdPlugin:\n   *\n   * - Normalizes the initial value for missing IDs\n   * - Adds IDs to new nodes during insertion\n   * - Preserves or reuses IDs on undo/redo and copy/paste operations\n   * - Handles ID conflicts and duplicates\n   *\n   * @default { idKey: 'id', filterInline: true, filterText: true, idCreator: () => nanoid(10) }\n   */\n  nodeId?: NodeIdConfig['options'] | boolean;\n  // override?: {\n  //   components?: Partial<\n  //     Record<KeyofNodePlugins<InferPlugins<P[]>>, NodeComponent | null>\n  //   >;\n  // };\n  /**\n   * Array of plugins to be loaded into the editor. Plugins extend the editor's\n   * functionality and define custom behavior.\n   */\n  plugins?: P[];\n  /**\n   * Editor read-only initial state. For dynamic read-only control, use the\n   * `Plate.readOnly` prop instead.\n   *\n   * @default false\n   */\n  readOnly?: boolean;\n  /**\n   * Initial selection state for the editor. Defines where the cursor should be\n   * positioned when the editor loads.\n   */\n  selection?: TSelection;\n  /**\n   * When `true`, normalizes the initial `value` passed to the editor. This is\n   * useful when adding normalization rules to already existing content or when\n   * the initial value might not conform to the current schema.\n   *\n   * Note: Normalization may take time for large documents.\n   *\n   * @default false\n   */\n  shouldNormalizeEditor?: boolean;\n  /**\n   * When `true`, skips the initial value, selection, and normalization logic.\n   * Useful when the editor state is managed externally (e.g., with Yjs\n   * collaboration) or when you want to manually control the initialization\n   * process.\n   *\n   * @default false\n   */\n  skipInitialization?: boolean;\n};\n\nexport type WithSlateOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = BaseWithSlateOptions<P> &\n  Pick<\n    Partial<AnySlatePlugin>,\n    | 'api'\n    | 'decorate'\n    | 'extendEditor'\n    | 'inject'\n    | 'normalizeInitialValue'\n    | 'options'\n    | 'override'\n    | 'transforms'\n  > & {\n    // override?: {\n    //   /** Enable or disable plugins */\n    //   enabled?: Partial<Record<KeyofPlugins<InferPlugins<P[]>>, boolean>>;\n    //   plugins?: Partial<\n    //     Record<\n    //       KeyofPlugins<InferPlugins<P[]>>,\n    //       PartialEditorPlugin<AnyPluginConfig>\n    //     >\n    //   >;\n    // };\n    /**\n     * Initial content for the editor.\n     *\n     * Can be:\n     *\n     * - A static value (array of nodes)\n     * - An HTML string that will be deserialized\n     * - A function that returns a value or Promise<value>\n     * - `null` for an empty editor\n     *\n     * @default [{ type: 'p'; children: [{ text: '' }] }]\n     */\n    value?: ((editor: SlateEditor) => Promise<V> | V) | V | string | null;\n    /** Function to configure the root plugin */\n    rootPlugin?: (plugin: AnySlatePlugin) => AnySlatePlugin;\n    /**\n     * Callback called when the editor is ready (after initialization\n     * completes).\n     */\n    onReady?: (ctx: {\n      editor: SlateEditor;\n      isAsync: boolean;\n      value: V;\n    }) => void;\n  };\n\n/**\n * Applies Plate enhancements to an editor instance (non-React version).\n *\n * @remarks\n *   This function supports server-side usage as it doesn't include React-specific\n *   features like component rendering or hooks integration.\n * @see {@link createSlateEditor} for a higher-level non-React editor creation function.\n * @see {@link createPlateEditor} for a React-specific version of editor creation.\n * @see {@link usePlateEditor} for a memoized React version.\n * @see {@link withPlate} for the React-specific enhancement function.\n */\nexport const withSlate = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>(\n  e: Editor,\n  {\n    id,\n    affinity = true,\n    autoSelect,\n    chunking = true,\n    maxLength,\n    nodeId,\n    plugins = [],\n    readOnly = false,\n    rootPlugin,\n    selection,\n    shouldNormalizeEditor,\n    skipInitialization,\n    value,\n    onReady,\n    ...pluginConfig\n  }: WithSlateOptions<V, P> = {}\n): TSlateEditor<V, InferPlugins<P[]>> => {\n  const editor = e as SlateEditor;\n\n  editor.id = id ?? editor.id ?? nanoid();\n  editor.meta.key = editor.meta.key ?? nanoid();\n  editor.meta.isFallback = false;\n  editor.dom = {\n    composing: false,\n    currentKeyboardEvent: null,\n    focused: false,\n    prevSelection: null,\n    readOnly,\n  };\n\n  editor.getApi = () => editor.api as any;\n  editor.getTransforms = () => editor.transforms as any;\n  editor.getPlugin = (plugin) => getSlatePlugin(editor, plugin) as any;\n  editor.getType = (pluginKey) => getPluginType(editor, pluginKey);\n  editor.getInjectProps = (plugin) => {\n    const nodeProps =\n      editor.getPlugin<AnySlatePlugin>(plugin).inject?.nodeProps ?? ({} as any);\n\n    nodeProps.nodeKey = nodeProps.nodeKey ?? editor.getType(plugin.key);\n    nodeProps.styleKey = nodeProps.styleKey ?? nodeProps.nodeKey;\n\n    return nodeProps;\n  };\n  editor.getOptionsStore = (plugin) => {\n    return editor.getPlugin(plugin).optionsStore;\n  };\n  editor.getOptions = (plugin) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return editor.getPlugin(plugin).options;\n\n    return editor.getOptionsStore(plugin).get('state');\n  };\n  editor.getOption = (plugin, key, ...args) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return editor.getPlugin(plugin).options[key];\n\n    if (!(key in store.get('state')) && !(key in store.selectors)) {\n      editor.api.debug.error(\n        `editor.getOption: ${key as string} option is not defined in plugin ${plugin.key}.`,\n        'OPTION_UNDEFINED'\n      );\n      return;\n    }\n\n    return (store.get as any)(key, ...args);\n  };\n  editor.setOption = (plugin: any, key: any, ...args: any) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return;\n\n    if (!(key in store.get('state'))) {\n      editor.api.debug.error(\n        `editor.setOption: ${key} option is not defined in plugin ${plugin.key}.`,\n        'OPTION_UNDEFINED'\n      );\n      return;\n    }\n\n    (store.set as any)(key, ...args);\n  };\n  editor.setOptions = (plugin: any, options: any) => {\n    const store = editor.getOptionsStore(plugin);\n\n    if (!store) return;\n    if (typeof options === 'object') {\n      store.set('state', (draft: any) => {\n        Object.assign(draft, options);\n      });\n    } else if (typeof options === 'function') {\n      store.set('state', options);\n    }\n  };\n\n  // Plugin initialization code\n  const corePlugins = getCorePlugins({\n    affinity,\n    chunking,\n    maxLength,\n    nodeId,\n    plugins,\n  });\n\n  let rootPluginInstance = createSlatePlugin({\n    key: 'root',\n    priority: 10_000,\n    ...pluginConfig,\n    override: {\n      ...pluginConfig.override,\n      components: {\n        ...pluginConfig.components,\n        ...pluginConfig.override?.components,\n      },\n    },\n    plugins: [...corePlugins, ...plugins],\n  });\n\n  // Apply rootPlugin configuration if provided\n  if (rootPlugin) {\n    rootPluginInstance = rootPlugin(rootPluginInstance) as any;\n  }\n\n  resolvePlugins(editor, [rootPluginInstance]);\n\n  /** Ignore normalizeNode overrides if shouldNormalizeNode returns false */\n  const normalizeNode = editor.tf.normalizeNode;\n  editor.tf.normalizeNode = (...args) => {\n    if (!editor.api.shouldNormalizeNode(args[0])) {\n      return;\n    }\n\n    return normalizeNode(...args);\n  };\n  editor.normalizeNode = editor.tf.normalizeNode;\n\n  if (!skipInitialization) {\n    editor.tf.init({\n      autoSelect,\n      selection,\n      shouldNormalizeEditor,\n      value,\n      onReady: onReady as any,\n    });\n  }\n\n  return editor as any;\n};\n\nexport type CreateSlateEditorOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = WithSlateOptions<V, P> & {\n  /**\n   * Initial editor to be extended with `withSlate`.\n   *\n   * @default createEditor()\n   */\n  editor?: Editor;\n};\n\n/**\n * Creates a Slate editor (non-React version).\n *\n * This function creates a fully configured Plate editor instance that can be\n * used in non-React environments or server-side contexts. It applies all the\n * specified plugins and configurations to create a functional editor.\n *\n * Examples:\n *\n * ```ts\n * const editor = createSlateEditor({\n *   plugins: [ParagraphPlugin, HeadingPlugin],\n *   value: [{ type: 'p', children: [{ text: 'Hello world!' }] }],\n * });\n *\n * // Editor with custom configuration\n * const editor = createSlateEditor({\n *   plugins: [ParagraphPlugin],\n *   maxLength: 1000,\n *   nodeId: { idCreator: () => uuidv4() },\n *   autoSelect: 'end',\n * });\n *\n * // Server-side editor\n * const editor = createSlateEditor({\n *   plugins: [ParagraphPlugin],\n *   value: '<p>HTML content</p>',\n *   skipInitialization: true,\n * });\n * ```\n *\n * @see {@link createPlateEditor} for a React-specific version of editor creation.\n * @see {@link usePlateEditor} for a memoized React version.\n * @see {@link withSlate} for the underlying function that applies Slate enhancements to an editor.\n */\nexport const createSlateEditor = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>({\n  editor = createEditor(),\n  ...options\n}: CreateSlateEditorOptions<V, P> = {}) => {\n  return withSlate<V, P>(editor, options);\n};\n","import {\n  assignLegacyApi,\n  assignLegacyTransforms,\n  syncLegacyMethods,\n} from '@platejs/slate';\nimport { isDefined } from '@udecode/utils';\nimport merge from 'lodash/merge.js';\nimport { createZustandStore } from 'zustand-x';\n\nimport type { SlateEditor, SlatePlugin, SlatePlugins } from '../../lib';\n\nimport { getEditorPlugin } from '../../lib/plugin';\nimport { mergePlugins } from '../utils/mergePlugins';\nimport { resolvePlugin } from './resolvePlugin';\n\n/**\n * Initialize and configure the editor's plugin system. This function sets up\n * the editor's plugins, resolving core and custom plugins, and applying any\n * overrides specified in the plugins.\n */\nexport const resolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins = []\n) => {\n  editor.plugins = {};\n  editor.meta.pluginList = [];\n  editor.meta.shortcuts = {} as Record<\n    string,\n    SlatePlugin['shortcuts'][string]\n  >;\n  editor.meta.components = {};\n  editor.meta.pluginCache = {\n    decorate: [],\n    handlers: {\n      onChange: [],\n      onNodeChange: [],\n      onTextChange: [],\n    },\n    inject: {\n      nodeProps: [],\n    },\n    node: {\n      isContainer: [],\n      isLeaf: [],\n      isText: [],\n      leafProps: [],\n      textProps: [],\n      types: {},\n    },\n    normalizeInitialValue: [],\n    render: {\n      aboveEditable: [],\n      aboveNodes: [],\n      aboveSlate: [],\n      afterContainer: [],\n      afterEditable: [],\n      beforeContainer: [],\n      beforeEditable: [],\n      belowNodes: [],\n      belowRootNodes: [],\n    },\n    rules: {\n      match: [],\n    },\n    useHooks: [],\n  };\n\n  const resolvedPlugins = resolveAndSortPlugins(editor, plugins);\n\n  applyPluginsToEditor(editor, resolvedPlugins);\n\n  resolvePluginOverrides(editor);\n\n  resolvePluginStores(editor);\n\n  // Last pass\n  editor.meta.pluginList.forEach((plugin: SlatePlugin) => {\n    if (plugin.extendEditor) {\n      editor = plugin.extendEditor(getEditorPlugin(editor, plugin) as any);\n\n      // Sync any editor methods that were modified by extendEditor\n      syncLegacyMethods(editor);\n    }\n\n    // Sync overridden plugin methods to legacy editor methods\n    resolvePluginMethods(editor, plugin);\n\n    if (plugin.node?.isContainer) {\n      editor.meta.pluginCache.node.isContainer.push(plugin.key);\n    }\n\n    editor.meta.pluginCache.node.types[plugin.node.type] = plugin.key;\n\n    if (plugin.inject?.nodeProps) {\n      editor.meta.pluginCache.inject.nodeProps.push(plugin.key);\n    }\n\n    if (plugin.render?.node) {\n      editor.meta.components[plugin.key] = plugin.render.node;\n    }\n\n    if (\n      plugin.node?.isLeaf &&\n      (plugin.node?.isDecoration === true || plugin.render.leaf)\n    ) {\n      editor.meta.pluginCache.node.isLeaf.push(plugin.key);\n    }\n\n    if (plugin.node.isLeaf && plugin.node.isDecoration === false) {\n      editor.meta.pluginCache.node.isText.push(plugin.key);\n    }\n\n    if (plugin.node?.leafProps) {\n      editor.meta.pluginCache.node.leafProps.push(plugin.key);\n    }\n\n    if (plugin.node.textProps) {\n      editor.meta.pluginCache.node.textProps.push(plugin.key);\n    }\n\n    if (plugin.render.aboveEditable) {\n      editor.meta.pluginCache.render.aboveEditable.push(plugin.key);\n    }\n\n    if (plugin.render.aboveSlate) {\n      editor.meta.pluginCache.render.aboveSlate.push(plugin.key);\n    }\n\n    if (plugin.render.afterEditable) {\n      editor.meta.pluginCache.render.afterEditable.push(plugin.key);\n    }\n\n    if (plugin.render.beforeEditable) {\n      editor.meta.pluginCache.render.beforeEditable.push(plugin.key);\n    }\n\n    if (plugin.rules?.match) {\n      editor.meta.pluginCache.rules.match.push(plugin.key);\n    }\n\n    if (plugin.render.afterContainer) {\n      editor.meta.pluginCache.render.afterContainer.push(plugin.key);\n    }\n\n    if (plugin.render.beforeContainer) {\n      editor.meta.pluginCache.render.beforeContainer.push(plugin.key);\n    }\n\n    if (plugin.render.belowRootNodes) {\n      editor.meta.pluginCache.render.belowRootNodes.push(plugin.key);\n    }\n\n    if (plugin.normalizeInitialValue) {\n      editor.meta.pluginCache.normalizeInitialValue.push(plugin.key);\n    }\n\n    if (plugin.decorate) {\n      editor.meta.pluginCache.decorate.push(plugin.key);\n    }\n\n    if (plugin.render.aboveNodes) {\n      editor.meta.pluginCache.render.aboveNodes.push(plugin.key);\n    }\n\n    if (plugin.render.belowNodes) {\n      editor.meta.pluginCache.render.belowNodes.push(plugin.key);\n    }\n\n    if ((plugin as any).useHooks) {\n      editor.meta.pluginCache.useHooks.push(plugin.key);\n    }\n\n    if ((plugin as any).handlers?.onChange) {\n      editor.meta.pluginCache.handlers.onChange.push(plugin.key);\n    }\n    if ((plugin as any).handlers?.onNodeChange) {\n      editor.meta.pluginCache.handlers.onNodeChange.push(plugin.key);\n    }\n    if ((plugin as any).handlers?.onTextChange) {\n      editor.meta.pluginCache.handlers.onTextChange.push(plugin.key);\n    }\n  });\n\n  resolvePluginShortcuts(editor);\n\n  return editor;\n};\n\nconst resolvePluginStores = (editor: SlateEditor) => {\n  // Create zustand stores for each plugin\n  editor.meta.pluginList.forEach((plugin) => {\n    let store = createZustandStore(plugin.options, {\n      mutative: true,\n      name: plugin.key,\n    });\n\n    // Apply option extensions\n    if (\n      (plugin as any).__selectorExtensions &&\n      (plugin as any).__selectorExtensions.length > 0\n    ) {\n      (plugin as any).__selectorExtensions.forEach((extension: any) => {\n        const extendedOptions = extension(getEditorPlugin(editor, plugin));\n\n        store = store.extendSelectors(() => extendedOptions);\n      });\n    }\n\n    plugin.optionsStore = store;\n  });\n};\n\nconst resolvePluginMethods = (editor: SlateEditor, plugin: any) => {\n  // Merge APIs\n  Object.entries(plugin.api).forEach(([apiKey, apiFunction]) => {\n    (editor.api as any)[apiKey] = apiFunction;\n  });\n\n  // Apply API and transform extensions\n  if (plugin.__apiExtensions && plugin.__apiExtensions.length > 0) {\n    plugin.__apiExtensions.forEach(\n      ({ extension, isOverride, isPluginSpecific, isTransform }: any) => {\n        const newExtensions = extension(getEditorPlugin(editor, plugin) as any);\n\n        if (isOverride) {\n          // Handle combined API and transforms override\n          if (newExtensions.api) {\n            merge(editor.api, newExtensions.api);\n            merge(plugin.api, newExtensions.api);\n            assignLegacyApi(editor, editor.api);\n          }\n          if (newExtensions.transforms) {\n            merge(editor.transforms, newExtensions.transforms);\n            merge(plugin.transforms, newExtensions.transforms);\n            assignLegacyTransforms(editor, newExtensions.transforms);\n          }\n        } else if (isTransform) {\n          // Handle transforms\n          if (isPluginSpecific) {\n            // Plugin-specific transform\n            if (!(editor.transforms as any)[plugin.key]) {\n              (editor.transforms as any)[plugin.key] = {};\n            }\n            if (!(plugin.transforms as any)[plugin.key]) {\n              (plugin.transforms as any)[plugin.key] = {};\n            }\n\n            merge((editor.transforms as any)[plugin.key], newExtensions);\n            merge((plugin.transforms as any)[plugin.key], newExtensions);\n          } else {\n            // Editor-wide transform\n            merge(editor.transforms, newExtensions);\n            merge(plugin.transforms, newExtensions);\n            assignLegacyTransforms(editor, newExtensions);\n          }\n        } else {\n          // Handle APIs\n          if (isPluginSpecific) {\n            // Plugin-specific API\n            if (!(editor.api as any)[plugin.key]) {\n              (editor.api as any)[plugin.key] = {};\n            }\n            if (!(plugin.api as any)[plugin.key]) {\n              (plugin.api as any)[plugin.key] = {};\n            }\n\n            merge((editor.api as any)[plugin.key], newExtensions);\n            merge((plugin.api as any)[plugin.key], newExtensions);\n          } else {\n            // Editor-wide API\n            merge(editor.api, newExtensions);\n            merge(plugin.api, newExtensions);\n            assignLegacyApi(editor, editor.api);\n          }\n        }\n      }\n    );\n    delete plugin.__apiExtensions;\n  }\n};\n\nconst resolvePluginShortcuts = (editor: SlateEditor) => {\n  editor.meta.shortcuts = {} as Record<\n    string,\n    SlatePlugin['shortcuts'][string]\n  >; // Initialize with a more specific type\n\n  editor.meta.pluginList.forEach((plugin) => {\n    Object.entries(plugin.shortcuts).forEach(([originalKey, hotkey]) => {\n      const namespacedKey = `${plugin.key}.${originalKey}`;\n\n      if (hotkey === null) {\n        // If hotkey is null, remove the namespaced shortcut\n        delete (\n          editor.meta.shortcuts as Record<\n            string,\n            SlatePlugin['shortcuts'][string]\n          >\n        )[namespacedKey];\n      } else if (hotkey && typeof hotkey === 'object') {\n        const resolvedHotkey = { ...hotkey } as NonNullable<\n          SlatePlugin['shortcuts'][string]\n        >;\n\n        // If no custom handler is provided, try to use plugin transform method as handler\n        if (!resolvedHotkey.handler) {\n          const pluginSpecificTransforms = (plugin.transforms as any)?.[\n            plugin.key\n          ];\n          const pluginSpecificApi = (plugin.api as any)?.[plugin.key];\n\n          if (pluginSpecificTransforms?.[originalKey]) {\n            resolvedHotkey.handler = () => {\n              return pluginSpecificTransforms[originalKey]();\n            };\n          } else if (pluginSpecificApi?.[originalKey]) {\n            resolvedHotkey.handler = () => {\n              return pluginSpecificApi[originalKey]();\n            };\n          }\n        }\n\n        // Set shortcut priority, falling back to plugin priority\n        resolvedHotkey.priority = resolvedHotkey.priority ?? plugin.priority;\n\n        (\n          editor.meta.shortcuts as Record<\n            string,\n            SlatePlugin['shortcuts'][string]\n          >\n        )[namespacedKey] = resolvedHotkey;\n      }\n    });\n  });\n};\n\nconst flattenAndResolvePlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): Map<string, SlatePlugin> => {\n  const pluginMap = new Map<string, SlatePlugin>();\n\n  const processPlugin = (plugin: SlatePlugin) => {\n    const resolvedPlugin = resolvePlugin(editor, plugin);\n\n    if (resolvedPlugin.key) {\n      const existingPlugin = pluginMap.get(resolvedPlugin.key);\n\n      if (existingPlugin) {\n        pluginMap.set(\n          resolvedPlugin.key,\n          mergePlugins(existingPlugin, resolvedPlugin)\n        );\n      } else {\n        pluginMap.set(resolvedPlugin.key, resolvedPlugin);\n      }\n    } else {\n      // If the plugin has no key, we just just skip it.\n    }\n\n    if (resolvedPlugin.plugins && resolvedPlugin.plugins.length > 0) {\n      resolvedPlugin.plugins.forEach(processPlugin);\n    }\n  };\n\n  plugins.forEach(processPlugin);\n\n  return pluginMap;\n};\n\nexport const resolveAndSortPlugins = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n): SlatePlugins => {\n  // Step 1: Resolve, flatten, and merge all plugins\n  const pluginMap = flattenAndResolvePlugins(editor, plugins);\n\n  // Step 2: Filter out disabled plugins\n  const enabledPlugins = Array.from(pluginMap.values()).filter(\n    (plugin) => plugin.enabled !== false\n  );\n\n  // Step 3: Sort plugins by priority\n  enabledPlugins.sort((a, b) => b.priority - a.priority);\n\n  // Step 4: Reorder based on dependencies\n  const orderedPlugins: SlatePlugins = [];\n  const visited = new Set<string>();\n\n  const visit = (plugin: SlatePlugin) => {\n    if (visited.has(plugin.key)) return;\n\n    visited.add(plugin.key);\n\n    plugin.dependencies?.forEach((depKey) => {\n      const depPlugin = pluginMap.get(depKey);\n\n      if (depPlugin) {\n        visit(depPlugin);\n      } else {\n        editor.api.debug.warn(\n          `Plugin \"${plugin.key}\" depends on missing plugin \"${depKey}\"`,\n          'PLUGIN_DEPENDENCY_MISSING'\n        );\n      }\n    });\n\n    orderedPlugins.push(plugin);\n  };\n\n  enabledPlugins.forEach(visit);\n\n  return orderedPlugins;\n};\n\nexport const applyPluginsToEditor = (\n  editor: SlateEditor,\n  plugins: SlatePlugins\n) => {\n  editor.meta.pluginList = plugins;\n  editor.plugins = Object.fromEntries(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n};\n\nexport const resolvePluginOverrides = (editor: SlateEditor) => {\n  const applyOverrides = (plugins: SlatePlugin[]): SlatePlugin[] => {\n    let overriddenPlugins = [...plugins];\n\n    const enabledOverrides: Record<string, boolean> = {};\n    const componentOverrides: Record<\n      string,\n      { component: any; priority: number }\n    > = {};\n    const pluginOverrides: Record<string, Partial<SlatePlugin>> = {};\n\n    // Collect all overrides\n    for (const plugin of plugins) {\n      if (plugin.override.enabled) {\n        Object.assign(enabledOverrides, plugin.override.enabled);\n      }\n      // TODO react\n      if ((plugin.override as any).components) {\n        Object.entries((plugin.override as any).components).forEach(\n          ([key, component]) => {\n            if (\n              !componentOverrides[key] ||\n              plugin.priority > componentOverrides[key].priority\n            ) {\n              componentOverrides[key] = {\n                component,\n                priority: plugin.priority,\n              };\n            }\n          }\n        );\n      }\n      if (plugin.override.plugins) {\n        Object.entries(plugin.override.plugins).forEach(([key, value]) => {\n          pluginOverrides[key] = mergePlugins(pluginOverrides[key], value);\n\n          if (value.enabled !== undefined) {\n            enabledOverrides[key] = value.enabled;\n          }\n        });\n      }\n    }\n\n    // Apply overrides\n    overriddenPlugins = overriddenPlugins.map((p) => {\n      let updatedPlugin = { ...p };\n\n      // Apply plugin overrides\n      if (pluginOverrides[p.key]) {\n        updatedPlugin = mergePlugins(updatedPlugin, pluginOverrides[p.key]);\n      }\n      // Apply component overrides\n      // TODO react\n      if (\n        componentOverrides[p.key] &&\n        ((!(p as any).render.node && !(p as any).node.component) ||\n          componentOverrides[p.key].priority > p.priority)\n      ) {\n        (updatedPlugin as any).render.node =\n          componentOverrides[p.key].component;\n        (updatedPlugin as any).node.component =\n          componentOverrides[p.key].component;\n      }\n\n      // Apply enabled overrides\n      const enabled = enabledOverrides[p.key] ?? updatedPlugin.enabled;\n\n      if (isDefined(enabled)) {\n        updatedPlugin.enabled = enabled;\n      }\n\n      return updatedPlugin;\n    });\n\n    return overriddenPlugins\n      .filter((p) => p.enabled !== false)\n      .map((plugin) => ({\n        ...plugin,\n        plugins: applyOverrides(plugin.plugins || []),\n      }));\n  };\n\n  applyPluginsToEditor;\n\n  editor.meta.pluginList = applyOverrides(editor.meta.pluginList as any);\n  editor.plugins = Object.fromEntries(\n    editor.meta.pluginList.map((plugin) => [plugin.key, plugin])\n  );\n};\n","import { type Modify, isDefined } from '@udecode/utils';\n\nimport type { SlateEditor } from '../editor/SlateEditor';\nimport type { AnyPluginConfig, PluginConfig } from './BasePlugin';\nimport type {\n  SlatePlugin,\n  SlatePluginMethods,\n  SlatePlugins,\n} from './SlatePlugin';\n\nimport { isFunction } from '../../internal/utils/isFunction';\nimport { mergePlugins } from '../../internal/utils/mergePlugins';\n\ntype SlatePluginConfig<\n  K extends string = any,\n  O = {},\n  A = {},\n  T = {},\n  S = {},\n> = Omit<\n  Partial<\n    Modify<\n      SlatePlugin<PluginConfig<K, O, A, T, S>>,\n      { node?: Partial<SlatePlugin<PluginConfig<K, O, A, T, S>>['node']> }\n    >\n  >,\n  keyof SlatePluginMethods | 'optionsStore'\n>;\n\ntype TSlatePluginConfig<C extends AnyPluginConfig = PluginConfig> = Omit<\n  Partial<\n    Modify<\n      SlatePlugin<C>,\n      {\n        node?: Partial<SlatePlugin<C>['node']>;\n      }\n    >\n  >,\n  keyof SlatePluginMethods | 'optionsStore'\n>;\n\n/**\n * Creates a new Plate plugin with the given configuration.\n *\n * @remarks\n *   - The plugin's key is required and specified by the K generic.\n *   - The `__extensions` array stores functions to be applied when `resolvePlugin`\n *       is called with an editor.\n *   - The `extend` method adds new extensions to be applied later.\n *   - The `extendPlugin` method extends an existing plugin (including nested\n *       plugins) or adds a new one if not found.\n *\n * @example\n *   const myPlugin = createSlatePlugin<\n *     'myPlugin',\n *     MyOptions,\n *     MyApi,\n *     MyTransforms\n *   >({\n *     key: 'myPlugin',\n *     options: { someOption: true },\n *     transforms: { someTransform: () => {} },\n *   });\n *\n *   const extendedPlugin = myPlugin.extend({\n *     options: { anotherOption: false },\n *   });\n *\n *   const pluginWithNestedExtension = extendedPlugin.extendPlugin(\n *     nestedPlugin,\n *     { options: { nestedOption: true } }\n *   );\n *\n * @template K - The literal type of the plugin key.\n * @template O - The type of the plugin options.\n * @template A - The type of the plugin utilities.\n * @template T - The type of the plugin transforms.\n * @template S - The type of the plugin storage.\n * @param {Partial<SlatePlugin<K, O, A, T, S>>} config - The configuration\n *   object for the plugin.\n * @returns {SlatePlugin<K, O, A, T, S>} A new Plate plugin instance with the\n *   following properties and methods:\n *\n *   - All properties from the input config, merged with default values.\n *   - `configure`: A method to create a new plugin instance with updated options.\n *   - `extend`: A method to create a new plugin instance with additional\n *       configuration.\n *   - `extendPlugin`: A method to extend an existing plugin (including nested\n *       plugins) or add a new one if not found.\n */\nexport function createSlatePlugin<\n  K extends string = any,\n  O = {},\n  A = {},\n  T = {},\n  S = {},\n>(\n  config:\n    | ((editor: SlateEditor) => SlatePluginConfig<K, O, A, T, S>)\n    | SlatePluginConfig<K, O, A, T, S> = {}\n): SlatePlugin<PluginConfig<K, O, A, T, S>> {\n  let baseConfig: Partial<SlatePlugin<PluginConfig<K, O, A, T, S>>>;\n  let initialExtension: any;\n\n  if (isFunction(config)) {\n    baseConfig = { key: '' as K };\n    initialExtension = (editor: any) => config(editor);\n  } else {\n    baseConfig = config as any;\n  }\n\n  const key = baseConfig.key ?? '';\n\n  const plugin = mergePlugins(\n    {\n      key,\n      __apiExtensions: [],\n      __configuration: null,\n      __extensions: initialExtension ? [initialExtension] : [],\n      __selectorExtensions: [],\n      api: {},\n      dependencies: [],\n      editor: {},\n      handlers: {},\n      inject: {},\n      node: { type: key },\n      options: {},\n      override: {},\n      parser: {},\n      parsers: {},\n      plugins: [],\n      priority: 100,\n      render: {},\n      rules: {},\n      shortcuts: {},\n      transforms: {},\n    },\n    config\n  ) as unknown as SlatePlugin<PluginConfig<K, O, A, T, S>>;\n\n  if (plugin.node.isLeaf && !isDefined(plugin.node.isDecoration)) {\n    plugin.node.isDecoration = true;\n  }\n\n  plugin.configure = (config) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__configuration = (ctx) =>\n      isFunction(config) ? config(ctx as any) : config;\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.configurePlugin = (p, config) => {\n    const newPlugin = { ...plugin };\n\n    const configureNestedPlugin = (\n      plugins: SlatePlugins\n    ): { found: boolean; plugins: SlatePlugins } => {\n      let found = false;\n\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n\n          return createSlatePlugin({\n            ...nestedPlugin,\n            __configuration: (ctx: any) =>\n              isFunction(config) ? config(ctx) : config,\n          } as any);\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result = configureNestedPlugin(nestedPlugin.plugins);\n\n          if (result.found) {\n            found = true;\n\n            return { ...nestedPlugin, plugins: result.plugins };\n          }\n        }\n\n        return nestedPlugin;\n      });\n\n      return { found, plugins: updatedPlugins };\n    };\n\n    const result = configureNestedPlugin(newPlugin.plugins as any);\n    newPlugin.plugins = result.plugins as any;\n\n    // We're not adding a new plugin if not found\n\n    return createSlatePlugin(newPlugin);\n  };\n\n  plugin.extendEditorApi = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: false },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendSelectors = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__selectorExtensions = [\n      ...(newPlugin.__selectorExtensions as any),\n      extension,\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendApi = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendEditorTransforms = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: false, isTransform: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extendTransforms = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      { extension, isPluginSpecific: true, isTransform: true },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.overrideEditor = (extension) => {\n    const newPlugin = { ...plugin };\n    newPlugin.__apiExtensions = [\n      ...(newPlugin.__apiExtensions as any),\n      {\n        extension,\n        isOverride: true,\n        isPluginSpecific: false,\n        isTransform: true,\n      },\n    ];\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.extend = (extendConfig) => {\n    let newPlugin = { ...plugin };\n\n    if (isFunction(extendConfig)) {\n      newPlugin.__extensions = [\n        ...(newPlugin.__extensions as any),\n        extendConfig,\n      ];\n    } else {\n      newPlugin = mergePlugins(newPlugin, extendConfig as any);\n    }\n\n    return createSlatePlugin(newPlugin) as any;\n  };\n\n  plugin.clone = () => mergePlugins(plugin);\n\n  plugin.extendPlugin = (p, extendConfig) => {\n    const newPlugin = { ...plugin };\n\n    const extendNestedPlugin = (\n      plugins: SlatePlugins\n    ): { found: boolean; plugins: SlatePlugins } => {\n      let found = false;\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n\n          return createSlatePlugin({\n            ...nestedPlugin,\n            __extensions: [\n              ...(nestedPlugin.__extensions as any),\n              (ctx: any) =>\n                isFunction(extendConfig) ? extendConfig(ctx) : extendConfig,\n            ],\n          } as any);\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result = extendNestedPlugin(nestedPlugin.plugins);\n\n          if (result.found) {\n            found = true;\n\n            return { ...nestedPlugin, plugins: result.plugins };\n          }\n        }\n\n        return nestedPlugin;\n      });\n\n      return { found, plugins: updatedPlugins };\n    };\n\n    const result = extendNestedPlugin(newPlugin.plugins as any);\n    newPlugin.plugins = result.plugins as any;\n\n    // If the plugin wasn't found at any level, add it at the top level\n    if (!result.found) {\n      newPlugin.plugins.push(\n        createSlatePlugin({\n          key: p.key,\n          __extensions: [\n            (ctx: any) =>\n              isFunction(extendConfig)\n                ? extendConfig(ctx as any)\n                : (extendConfig as any),\n          ],\n        } as any)\n      );\n    }\n\n    return createSlatePlugin(newPlugin);\n  };\n\n  plugin.withComponent = (component) => {\n    return plugin.extend({\n      node: { component },\n      render: { node: component },\n    }) as any;\n  };\n\n  return plugin;\n}\n\n/**\n * Explicitly typed version of `createSlatePlugin`.\n *\n * @remarks\n *   While `createSlatePlugin` uses type inference, this function requires an\n *   explicit type parameter. Use this when you need precise control over the\n *   plugin's type structure or when type inference doesn't provide the desired\n *   result.\n */\nexport function createTSlatePlugin<C extends AnyPluginConfig = PluginConfig>(\n  config:\n    | ((editor: SlateEditor) => TSlatePluginConfig<C>)\n    | TSlatePluginConfig<C> = {}\n): SlatePlugin<C> {\n  return createSlatePlugin(config as any) as any;\n}\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function';\n}\n","import mergeWith from 'lodash/mergeWith.js';\n\nimport type { SlatePlugin } from '../../lib';\n\nexport function mergePlugins<T>(basePlugin: T, ...sourcePlugins: any[]): T {\n  return mergeWith(\n    {},\n    basePlugin,\n    ...sourcePlugins,\n    (objValue: unknown, srcValue: unknown, key: keyof SlatePlugin) => {\n      // Overwrite array (including plugins) without cloning\n      if (Array.isArray(srcValue)) {\n        return srcValue;\n      }\n      // Shallow merge options\n      if (key === 'options') {\n        return { ...(objValue as any), ...(srcValue as any) };\n      }\n    }\n  );\n}\n","import type { SlateEditor } from '../editor';\nimport type { AnyPluginConfig, WithRequiredKey } from './BasePlugin';\nimport type {\n  InferConfig,\n  SlatePlugin,\n  SlatePluginContext,\n} from './SlatePlugin';\n\nexport function getEditorPlugin<\n  P extends AnyPluginConfig | SlatePlugin<AnyPluginConfig>,\n>(\n  editor: SlateEditor,\n  p: WithRequiredKey<P>\n): SlatePluginContext<InferConfig<P> extends never ? P : InferConfig<P>> {\n  const plugin = editor.getPlugin(p) as any;\n\n  return {\n    api: editor.api,\n    editor,\n    plugin: plugin as any,\n    setOption: ((keyOrOptions: any, value: any) =>\n      editor.setOption(plugin, keyOrOptions, value)) as any,\n    setOptions: ((options: any) => editor.setOptions(plugin, options)) as any,\n    tf: editor.transforms,\n    type: plugin.node.type,\n    getOption: (key: any, ...args: any) =>\n      (editor.getOption as any)(plugin, key, ...args),\n    getOptions: () => editor.getOptions(plugin),\n  };\n}\n","import merge from 'lodash/merge.js';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type { PluginConfig } from '../../lib/plugin/BasePlugin';\nimport type { AnySlatePlugin, SlatePlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin/getEditorPlugin';\nimport { mergePlugins } from '../utils/mergePlugins';\n\n/**\n * Resolves and finalizes a plugin configuration for use in a Plate editor.\n *\n * This function processes a given plugin configuration, applying any extensions\n * and resolving nested plugins. It prepares the plugin for integration into the\n * Plate editor system by:\n *\n * 1. Cloning the plugin to avoid mutating the original\n * 2. Applying all stored extensions to the plugin\n * 3. Clearing the extensions array after application\n *\n * @example\n *   const plugin = createSlatePlugin({ key: 'myPlugin', ...otherOptions }).extend(...);\n *   const resolvedPlugin = resolvePlugin(editor, plugin);\n */\nexport const resolvePlugin = <P extends AnySlatePlugin>(\n  editor: SlateEditor,\n  _plugin: P\n): P => {\n  // Create a deep clone of the plugin\n  let plugin = mergePlugins({}, _plugin) as P;\n\n  plugin.__resolved = true;\n\n  // Apply the stored configuration first\n  if (plugin.__configuration) {\n    const configResult = plugin.__configuration(\n      getEditorPlugin(editor, plugin as any)\n    );\n\n    plugin = mergePlugins(plugin, configResult);\n\n    delete (plugin as any).__configuration;\n  }\n  // Apply all stored extensions\n  if (plugin.__extensions && plugin.__extensions.length > 0) {\n    plugin.__extensions.forEach((extension) => {\n      plugin = mergePlugins(\n        plugin,\n        extension(getEditorPlugin(editor, plugin as any))\n      );\n    });\n    plugin.__extensions = [];\n  }\n\n  const targetPluginToInject = plugin.inject?.targetPluginToInject;\n  const targetPlugins = plugin.inject?.targetPlugins;\n\n  if (targetPluginToInject && targetPlugins && targetPlugins.length > 0) {\n    plugin.inject = plugin.inject || {};\n    plugin.inject.plugins = merge(\n      {},\n      plugin.inject.plugins,\n      Object.fromEntries(\n        targetPlugins.map((targetPlugin) => {\n          const injectedPlugin = targetPluginToInject({\n            ...getEditorPlugin(editor, plugin as any),\n            targetPlugin,\n          });\n\n          return [targetPlugin, injectedPlugin];\n        })\n      )\n    );\n  }\n  if (plugin.node?.component) {\n    plugin.render.node = plugin.node.component;\n  }\n  if (plugin.render?.node) {\n    plugin.node.component = plugin.render.node;\n  }\n\n  validatePlugin(editor, plugin);\n\n  return plugin;\n};\n\nexport const validatePlugin = <\n  K extends string = any,\n  O = {},\n  A = {},\n  T = {},\n  S = {},\n>(\n  editor: SlateEditor,\n  plugin: SlatePlugin<PluginConfig<K, O, A, T, S>>\n) => {\n  if (!plugin.__extensions) {\n    editor.api.debug.error(\n      `Invalid plugin '${plugin.key}', you should use createSlatePlugin.`,\n      'USE_CREATE_PLUGIN'\n    );\n  }\n  if (plugin.node.isElement && plugin.node.isLeaf) {\n    editor.api.debug.error(\n      `Plugin ${plugin.key} cannot be both an element and a leaf.`,\n      'PLUGIN_NODE_TYPE'\n    );\n  }\n};\n","import type { SlateEditor } from '../editor';\nimport type {\n  AnyPluginConfig,\n  PluginConfig,\n  WithRequiredKey,\n} from './BasePlugin';\nimport type { AnySlatePlugin, SlatePlugin } from './SlatePlugin';\n\nimport { resolvePlugin } from '../../internal/plugin/resolvePlugin';\nimport { createSlatePlugin } from './createSlatePlugin';\n\n/** Get editor plugin by key or plugin object. */\nexport function getSlatePlugin<C extends AnyPluginConfig = PluginConfig>(\n  editor: SlateEditor,\n  p: WithRequiredKey<C>\n): C extends { node: any } ? C : SlatePlugin<C> {\n  let plugin = p as any;\n\n  const editorPlugin = editor.plugins[p.key] as any;\n\n  if (!editorPlugin) {\n    // When passing only { key }\n    if (!plugin.node) {\n      plugin = createSlatePlugin(plugin);\n    }\n\n    // Resolve is need when passing an external plugin with extensions (e.g. in withLink)\n    return plugin.__resolved ? plugin : resolvePlugin(editor, plugin);\n  }\n\n  return editorPlugin;\n}\n\n/** Get editor plugin type by key or plugin object. */\nexport function getPluginType(editor: SlateEditor, key: string): string {\n  const p = editor.getPlugin<AnySlatePlugin>({ key });\n\n  return p.node.type ?? p.key ?? '';\n}\n\n/** Get editor plugin types by key. */\nexport const getPluginTypes = (editor: SlateEditor, keys: string[]) =>\n  keys.map((key) => editor.getType(key));\n\nexport const getPluginKey = (\n  editor: SlateEditor,\n  type: string\n): string | undefined => editor.meta.pluginCache.node.types[type];\n\nexport const getPluginKeys = (\n  editor: SlateEditor,\n  types: string[]\n): string[] => {\n  return types\n    .map((type) => {\n      const pluginKey = getPluginKey(editor, type);\n      return pluginKey ?? type;\n    })\n    .filter(Boolean);\n};\n\nexport const getPluginByType = (editor: SlateEditor, type: string) => {\n  const key = getPluginKey(editor, type);\n  if (!key) return null;\n\n  return editor.getPlugin({ key });\n};\n\nexport const getContainerTypes = (editor: SlateEditor) => {\n  return getPluginTypes(editor, editor.meta.pluginCache.node.isContainer);\n};\n","import { createSlatePlugin } from '../plugin';\n\n/**\n * Enables support for deserializing inserted content from Slate Ast format to\n * Slate format while apply a small bug fix.\n */\nexport const AstPlugin = createSlatePlugin({\n  key: 'ast',\n  parser: {\n    format: 'application/x-slate-fragment',\n    deserialize: ({ data }) => {\n      const decoded = decodeURIComponent(window.atob(data));\n      let parsed;\n\n      try {\n        parsed = JSON.parse(decoded);\n      } catch {\n        /* empty */\n      }\n\n      return parsed;\n    },\n  },\n});\n","import { withHistory } from '@platejs/slate';\n\nimport type { SlateEditor } from '../editor';\n\nimport { type ExtendEditor, createSlatePlugin } from '../plugin';\n\nexport const withPlateHistory: ExtendEditor = ({ editor }) =>\n  withHistory(editor as any) as any as SlateEditor;\n\n/** @see {@link withHistory} */\nexport const HistoryPlugin = createSlatePlugin({\n  key: 'history',\n  extendEditor: withPlateHistory,\n});\n","import { type PluginConfig, createSlatePlugin } from '../../plugin';\n\nexport type ParagraphConfig = PluginConfig<'p'>;\n\nexport const BaseParagraphPlugin = createSlatePlugin({\n  key: 'p',\n  node: {\n    isElement: true,\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [\n          {\n            validNodeName: 'P',\n          },\n        ],\n        query: ({ element }) => element.style.fontFamily !== 'Consolas',\n      },\n    },\n  },\n  rules: {\n    merge: { removeEmpty: true },\n  },\n});\n","import { PathApi } from '@platejs/slate';\n\nimport type { OverrideEditor } from '../../plugin';\nimport type { BreakRules } from '../../plugin/BasePlugin';\n\nimport { getPluginByType } from '../../plugin/getSlatePlugin';\n\nexport const withBreakRules: OverrideEditor = (ctx) => {\n  const {\n    editor,\n    tf: { insertBreak },\n  } = ctx;\n  const checkMatchRulesOverride = (\n    rule: string,\n    blockNode: any,\n    blockPath: any\n  ): BreakRules | null => {\n    const matchRulesKeys = editor.meta.pluginCache.rules.match;\n    for (const key of matchRulesKeys) {\n      const overridePlugin = editor.getPlugin({ key });\n      if (\n        overridePlugin.rules?.break &&\n        overridePlugin.rules?.match?.({\n          ...ctx,\n          node: blockNode,\n          path: blockPath,\n          rule: rule as any,\n        })\n      ) {\n        return overridePlugin.rules.break;\n      }\n    }\n    return null;\n  };\n\n  const executeBreakAction = (\n    action: string | undefined,\n    blockPath: any\n  ): boolean => {\n    if (action === 'reset') {\n      editor.tf.resetBlock({ at: blockPath });\n      return true;\n    }\n    if (action === 'exit') {\n      editor.tf.insertExitBreak();\n      return true;\n    }\n    if (action === 'deleteExit') {\n      editor.tf.deleteBackward('character');\n      editor.tf.insertExitBreak();\n      return true;\n    }\n    if (action === 'lineBreak') {\n      editor.tf.insertSoftBreak();\n      return true;\n    }\n    return false;\n  };\n\n  return {\n    transforms: {\n      insertBreak() {\n        if (editor.selection && editor.api.isCollapsed()) {\n          const block = editor.api.block();\n          if (block) {\n            const [blockNode, blockPath] = block;\n            const plugin = getPluginByType(editor, blockNode.type);\n\n            const breakRules = plugin?.rules.break;\n\n            // Handle 'empty' scenario\n            if (\n              editor.api.isEmpty(editor.selection, {\n                block: true,\n              })\n            ) {\n              const overrideBreakRules = checkMatchRulesOverride(\n                'break.empty',\n                blockNode,\n                blockPath\n              );\n              const effectiveBreakRules = overrideBreakRules || breakRules;\n              const emptyAction = effectiveBreakRules?.empty;\n\n              if (executeBreakAction(emptyAction, blockPath)) return;\n              // if 'default', fall through to breakRules.default or standard behavior\n            }\n\n            // Handle 'emptyLineEnd' scenario\n            if (\n              !editor.api.isEmpty(editor.selection, {\n                block: true,\n              }) &&\n              editor.api.isAt({ end: true })\n            ) {\n              const range = editor.api.range('before', editor.selection!);\n              if (range) {\n                const char = editor.api.string(range);\n                if (char === '\\n') {\n                  const overrideBreakRules = checkMatchRulesOverride(\n                    'break.emptyLineEnd',\n                    blockNode,\n                    blockPath\n                  );\n                  const effectiveBreakRules = overrideBreakRules || breakRules;\n                  const emptyLineEndAction = effectiveBreakRules?.emptyLineEnd;\n\n                  if (executeBreakAction(emptyLineEndAction, blockPath)) return;\n                }\n              }\n            }\n\n            // Handle 'default' scenario (or fallthrough from 'empty: default' or 'emptyLineEnd: default')\n            const overrideDefaultBreakRules = checkMatchRulesOverride(\n              'break.default',\n              blockNode,\n              blockPath\n            );\n            const defaultAction = (overrideDefaultBreakRules || breakRules)\n              ?.default;\n\n            if (executeBreakAction(defaultAction, blockPath)) return;\n\n            const overrideSplitResetBreakRules = checkMatchRulesOverride(\n              'break.splitReset',\n              blockNode,\n              blockPath\n            );\n            const splitReset =\n              overrideSplitResetBreakRules?.splitReset ??\n              breakRules?.splitReset;\n\n            if (splitReset) {\n              const isAtStart = editor.api.isAt({ start: true });\n\n              insertBreak();\n\n              editor.tf.resetBlock({\n                at: isAtStart ? blockPath : PathApi.next(blockPath),\n              });\n              return;\n            }\n          }\n        }\n\n        // Standard Slate insertBreak if no custom breakRules handled it\n        insertBreak();\n      },\n    },\n  };\n};\n","import { PointApi, RangeApi } from '@platejs/slate';\n\nimport type { OverrideEditor } from '../../plugin';\nimport type { DeleteRules } from '../../plugin/BasePlugin';\n\nimport { getPluginByType } from '../../plugin/getSlatePlugin';\n\nexport const withDeleteRules: OverrideEditor = (ctx) => {\n  const {\n    editor,\n    tf: { deleteBackward, deleteForward, deleteFragment },\n  } = ctx;\n\n  const resetMarks = () => {\n    if (editor.api.isAt({ start: true })) {\n      editor.tf.removeMarks();\n    }\n  };\n\n  const checkMatchRulesOverride = (\n    rule: string,\n    blockNode: any,\n    blockPath: any\n  ): DeleteRules | null => {\n    const matchRulesKeys = editor.meta.pluginCache.rules.match;\n    for (const key of matchRulesKeys) {\n      const overridePlugin = editor.getPlugin({ key });\n      if (\n        overridePlugin.rules?.delete &&\n        overridePlugin.rules?.match?.({\n          ...ctx,\n          node: blockNode,\n          path: blockPath,\n          rule: rule as any,\n        })\n      ) {\n        return overridePlugin.rules.delete;\n      }\n    }\n    return null;\n  };\n\n  const executeDeleteAction = (\n    action: string | undefined,\n    blockPath: any\n  ): boolean => {\n    if (action === 'reset') {\n      editor.tf.resetBlock({ at: blockPath });\n      return true;\n    }\n    return false;\n  };\n\n  return {\n    transforms: {\n      deleteBackward(unit) {\n        if (editor.selection && editor.api.isCollapsed()) {\n          const block = editor.api.block();\n          if (block) {\n            const [blockNode, blockPath] = block;\n            const plugin = getPluginByType(editor, blockNode.type);\n\n            const deleteRules = plugin?.rules.delete;\n\n            // Handle 'start' scenario\n            if (editor.api.isAt({ start: true })) {\n              const overrideDeleteRules = checkMatchRulesOverride(\n                'delete.start',\n                blockNode,\n                blockPath\n              );\n              const effectiveDeleteRules = overrideDeleteRules || deleteRules;\n              const startAction = effectiveDeleteRules?.start;\n\n              if (executeDeleteAction(startAction, blockPath)) {\n                return;\n              }\n            }\n\n            // Handle 'empty' scenario\n            if (editor.api.isEmpty(editor.selection, { block: true })) {\n              const overrideDeleteRules = checkMatchRulesOverride(\n                'delete.empty',\n                blockNode,\n                blockPath\n              );\n              const effectiveDeleteRules = overrideDeleteRules || deleteRules;\n              const emptyAction = effectiveDeleteRules?.empty;\n\n              if (executeDeleteAction(emptyAction, blockPath)) return;\n            }\n          }\n\n          // Default behavior: reset first block when deleting at start of the document\n          if (\n            PointApi.equals(editor.selection!.anchor, editor.api.start([])!)\n          ) {\n            editor.tf.resetBlock({ at: [0] });\n            return;\n          }\n        }\n\n        deleteBackward(unit);\n        resetMarks();\n      },\n      deleteForward(unit) {\n        deleteForward(unit);\n        resetMarks();\n      },\n      deleteFragment(options) {\n        // Default behavior: reset entire editor when deleting full selection\n        if (\n          editor.selection &&\n          RangeApi.equals(editor.selection, editor.api.range([])!)\n        ) {\n          editor.tf.reset({\n            children: true,\n            select: true,\n          });\n          return;\n        }\n\n        deleteFragment(options);\n        resetMarks();\n      },\n    },\n  };\n};\n","import {\n  type Path,\n  type TElement,\n  ElementApi,\n  PathApi,\n  TextApi,\n} from '@platejs/slate';\n\nimport type { OverrideEditor } from '../../plugin';\nimport type { MergeRules } from '../../plugin/BasePlugin';\n\nimport { getPluginByType } from '../../plugin/getSlatePlugin';\n\nexport const withMergeRules: OverrideEditor = (ctx) => {\n  const {\n    editor,\n    tf: { removeNodes },\n  } = ctx;\n\n  const checkMatchRulesOverride = (\n    rule: string,\n    blockNode: any,\n    blockPath: any\n  ): MergeRules | null => {\n    const matchRulesKeys = editor.meta.pluginCache.rules.match;\n    for (const key of matchRulesKeys) {\n      const overridePlugin = editor.getPlugin({ key });\n      if (\n        overridePlugin.rules.merge &&\n        overridePlugin.rules?.match?.({\n          ...ctx,\n          node: blockNode,\n          path: blockPath,\n          rule: rule as any,\n        })\n      ) {\n        return overridePlugin.rules.merge;\n      }\n    }\n    return null;\n  };\n\n  return {\n    api: {\n      shouldMergeNodes(prevNodeEntry, nextNodeEntry, { reverse } = {}) {\n        const [prevNode, prevPath] = prevNodeEntry;\n        const [, nextPath] = nextNodeEntry;\n        const [curNode, curPath] = reverse ? prevNodeEntry : nextNodeEntry;\n        const [targetNode, targetPath] = reverse\n          ? nextNodeEntry\n          : prevNodeEntry;\n\n        if (\n          TextApi.isText(prevNode) &&\n          prevNode.text === '' &&\n          prevPath.at(-1) !== 0\n        ) {\n          editor.tf.removeNodes({ at: prevPath });\n          return false;\n        }\n\n        const shouldRemove = (node: TElement, path: Path) => {\n          // Override Slate's default: typically only pure text blocks like paragraph and heading nodes want this to be true, so plugin default is false.\n          const plugin = getPluginByType(editor, node.type);\n          if (!plugin) {\n            return true;\n          }\n\n          const mergeRules = plugin.rules.merge;\n          if (!mergeRules?.removeEmpty) {\n            return false;\n          }\n\n          // Check if any plugin with matchRules overrides the merge behavior\n          const overrideMergeRules = checkMatchRulesOverride(\n            'merge.removeEmpty',\n            node,\n            path\n          );\n\n          if (overrideMergeRules?.removeEmpty === false) {\n            return false;\n          }\n\n          return true;\n        };\n\n        // Don't delete target void blocks by default\n        if (ElementApi.isElement(targetNode) && editor.api.isVoid(targetNode)) {\n          // Remove if plugin allows it\n          if (shouldRemove(targetNode, targetPath)) {\n            editor.tf.removeNodes({ at: prevPath });\n          }\n          // Remove current node if empty before selecting the void block\n          else if (\n            ElementApi.isElement(curNode) &&\n            editor.api.isEmpty(curNode)\n          ) {\n            editor.tf.removeNodes({ at: curPath });\n          }\n          return false;\n        }\n\n        // Not void, remove prevNode if sibling and empty\n        if (\n          ElementApi.isElement(prevNode) &&\n          editor.api.isEmpty(prevNode) &&\n          PathApi.isSibling(prevPath, nextPath) &&\n          shouldRemove(prevNode, prevPath)\n        ) {\n          editor.tf.removeNodes({ at: prevPath });\n          return false;\n        }\n\n        return true;\n      },\n    },\n    transforms: {\n      removeNodes(options = {}) {\n        if (options.event?.type === 'mergeNodes' && options.at) {\n          const nodeEntry = editor.api.node(options.at);\n          if (nodeEntry) {\n            const [node, path] = nodeEntry;\n\n            if (ElementApi.isElement(node)) {\n              // Check if this node should be removed based on merge rules\n              const plugin = getPluginByType(editor, node.type);\n              if (plugin) {\n                const mergeRules = plugin.rules.merge;\n\n                // Check for override rules\n                const overrideMergeRules = checkMatchRulesOverride(\n                  'merge.removeEmpty',\n                  node,\n                  path\n                );\n\n                const shouldNotRemove =\n                  overrideMergeRules?.removeEmpty === false ||\n                  mergeRules?.removeEmpty === false;\n\n                if (shouldNotRemove) {\n                  // Don't remove the node, just return without calling removeNodes\n                  return;\n                }\n              }\n            }\n          }\n        }\n\n        removeNodes(options);\n      },\n    },\n  };\n};\n","import { ElementApi } from '@platejs/slate';\n\nimport type { NormalizeRules } from '../../plugin/BasePlugin';\nimport type { OverrideEditor } from '../../plugin/SlatePlugin';\n\nimport { getPluginByType } from '../../plugin/getSlatePlugin';\n\nexport const withNormalizeRules: OverrideEditor = (ctx) => {\n  const {\n    editor,\n    tf: { normalizeNode },\n  } = ctx;\n\n  const checkMatchRulesOverride = (\n    rule: string,\n    node: any,\n    path: any\n  ): NormalizeRules | null => {\n    const matchRulesKeys = editor.meta.pluginCache.rules.match;\n    for (const key of matchRulesKeys) {\n      const overridePlugin = editor.getPlugin({ key });\n      if (\n        overridePlugin.rules?.normalize &&\n        overridePlugin.rules?.match?.({\n          ...ctx,\n          node: node,\n          path: path,\n          rule: rule as any,\n        })\n      ) {\n        return overridePlugin.rules.normalize;\n      }\n    }\n    return null;\n  };\n\n  return {\n    transforms: {\n      normalizeNode([node, path]) {\n        if (ElementApi.isElement(node) && node.type) {\n          const plugin = getPluginByType(editor, node.type);\n          const normalizeRules = plugin?.rules.normalize;\n\n          // Handle 'removeEmpty' scenario\n          const overridenormalizeRules = checkMatchRulesOverride(\n            'normalize.removeEmpty',\n            node,\n            path\n          );\n          const effectivenormalizeRules =\n            overridenormalizeRules || normalizeRules;\n\n          if (\n            effectivenormalizeRules?.removeEmpty &&\n            editor.api.isEmpty(node)\n          ) {\n            editor.tf.removeNodes({ at: path });\n            return;\n          }\n        }\n\n        normalizeNode([node, path]);\n      },\n    },\n  };\n};\n","import { type OverrideEditor, getPluginByType } from '../../plugin';\nimport { createSlatePlugin } from '../../plugin/createSlatePlugin';\nimport { BaseParagraphPlugin } from '../paragraph';\nimport { withBreakRules } from './withBreakRules';\nimport { withDeleteRules } from './withDeleteRules';\nimport { withMergeRules } from './withMergeRules';\nimport { withNormalizeRules } from './withNormalizeRules';\n\n/**\n * Merge and register all the inline types and void types from the plugins and\n * options, using `editor.api.isInline`, `editor.api.markableVoid` and\n * `editor.api.isVoid`\n */\nexport const withOverrides: OverrideEditor = ({\n  api: { isInline, isSelectable, isVoid, markableVoid },\n  editor,\n}) => {\n  // Use pre-computed arrays from plugin resolution\n  return {\n    api: {\n      create: {\n        block: (node) => ({\n          children: [{ text: '' }],\n          type: editor.getType(BaseParagraphPlugin.key),\n          ...node,\n        }),\n      },\n      isInline(element) {\n        return getPluginByType(editor, element.type as string)?.node.isInline\n          ? true\n          : isInline(element);\n      },\n      isSelectable(element) {\n        return getPluginByType(editor, element.type as string)?.node\n          .isSelectable === false\n          ? false\n          : isSelectable(element);\n      },\n      isVoid(element) {\n        return getPluginByType(editor, element.type as string)?.node.isVoid\n          ? true\n          : isVoid(element);\n      },\n      markableVoid(element) {\n        return getPluginByType(editor, element.type as string)?.node\n          .isMarkableVoid\n          ? true\n          : markableVoid(element);\n      },\n    },\n  };\n};\n\n/** Override the editor api and transforms based on the plugins. */\nexport const OverridePlugin = createSlatePlugin({\n  key: 'override',\n})\n  .overrideEditor(withOverrides)\n  .overrideEditor(withBreakRules)\n  .overrideEditor(withDeleteRules)\n  .overrideEditor(withMergeRules)\n  .overrideEditor(withNormalizeRules);\n","import type { Descendant } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type { ParserOptions } from '../../lib/plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin';\n\n/** Pipe preInsert then insertFragment. */\nexport const pipeInsertFragment = (\n  editor: SlateEditor,\n  injectedPlugins: Partial<AnyEditorPlugin>[],\n  { fragment, ...options }: ParserOptions & { fragment: Descendant[] }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    injectedPlugins.some((p) => {\n      return (\n        p.parser?.preInsert?.({\n          ...getEditorPlugin(editor, p as any),\n          fragment,\n          ...options,\n        }) === true\n      );\n    });\n\n    editor.tf.insertFragment(fragment);\n  });\n};\n","import type { SlateEditor } from '../../lib/editor';\nimport type { ParserOptions } from '../../lib/plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin';\n\n/** Pipe editor.tf.insertData.transformData */\nexport const pipeTransformData = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { data, ...options }: ParserOptions\n) => {\n  plugins.forEach((p) => {\n    const transformData = p.parser?.transformData;\n\n    if (!transformData) return;\n\n    data = transformData({\n      ...getEditorPlugin(editor, p as any),\n      data,\n      ...options,\n    });\n  });\n\n  return data;\n};\n","import type { Descendant } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type { ParserOptions } from '../../lib/plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../../lib/plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../lib/plugin';\n\n/** Pipe editor.tf.insertData.transformFragment */\nexport const pipeTransformFragment = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  { fragment, ...options }: ParserOptions & { fragment: Descendant[] }\n) => {\n  plugins.forEach((p) => {\n    const transformFragment = p.parser?.transformFragment;\n\n    if (!transformFragment) return;\n\n    fragment = transformFragment({\n      fragment,\n      ...options,\n      ...getEditorPlugin(editor, p as any),\n    });\n  });\n\n  return fragment;\n};\n","import {\n  type NodeEntry,\n  type NodeOf,\n  type Path,\n  type QueryNodeOptions,\n  type TNode,\n  NodeApi,\n  queryNode,\n} from '@platejs/slate';\n\nexport interface ApplyDeepToNodesOptions<N extends TNode> {\n  // Function to call on each node following the query.\n  apply: (\n    node: NodeOf<N>,\n    source: (() => Record<string, any>) | Record<string, any>\n  ) => void;\n  // The destination node object.\n  node: N;\n  // The source object. Can be a factory.\n  source: (() => Record<string, any>) | Record<string, any>;\n  path?: Path;\n  // Query to filter the nodes.\n  query?: QueryNodeOptions;\n}\n\n/** Recursively apply an operation to children nodes with a query. */\nexport const applyDeepToNodes = <N extends TNode>({\n  apply,\n  node,\n  path = [],\n  query,\n  source,\n}: ApplyDeepToNodesOptions<N>) => {\n  const entry: NodeEntry<N> = [node, path];\n\n  if (queryNode<N>(entry, query)) {\n    if (typeof source === 'function') {\n      apply(node, source());\n    } else {\n      apply(node, source);\n    }\n  }\n  if (!NodeApi.isAncestor(node)) return;\n\n  node.children.forEach((child, index) => {\n    applyDeepToNodes({\n      apply,\n      node: child as any,\n      path: path.concat([index]),\n      query,\n      source,\n    });\n  });\n};\n","import type { TNode } from '@platejs/slate';\n\nimport defaults from 'lodash/defaults.js';\n\nimport {\n  type ApplyDeepToNodesOptions,\n  applyDeepToNodes,\n} from './applyDeepToNodes';\n\n/** Recursively merge a source object to children nodes with a query. */\nexport const defaultsDeepToNodes = <N extends TNode>(\n  options: Omit<ApplyDeepToNodesOptions<N>, 'apply'>\n) => {\n  applyDeepToNodes({ ...options, apply: defaults });\n};\n","import { type Path, type TNode, ElementApi } from '@platejs/slate';\n\nimport type { SlateEditor } from '../editor';\n\nimport { type EditorPlugin, getPluginKey, getPluginKeys } from '../plugin';\n\nexport const getInjectMatch = <E extends SlateEditor>(\n  editor: E,\n  plugin: EditorPlugin\n) => {\n  return (node: TNode, path: Path) => {\n    const {\n      inject: {\n        excludeBelowPlugins,\n        excludePlugins,\n        isBlock: _isBlock,\n        isElement: _isElement,\n        isLeaf,\n        maxLevel,\n        targetPlugins,\n      },\n    } = plugin;\n\n    const element = ElementApi.isElement(node) ? node : undefined;\n\n    if (_isElement && !element) return false;\n    if (_isBlock && (!element || !editor.api.isBlock(element))) return false;\n    if (isLeaf && element) return false;\n    if (element?.type) {\n      // Exclude plugins\n      if (excludePlugins?.includes(getPluginKey(editor, element.type)!)) {\n        return false;\n      }\n      // Target plugins\n      if (\n        targetPlugins &&\n        !targetPlugins.includes(getPluginKey(editor, element.type)!)\n      ) {\n        return false;\n      }\n    }\n    // Exclude below plugins\n    if (excludeBelowPlugins || maxLevel) {\n      if (maxLevel && path.length > maxLevel) {\n        return false;\n      }\n      if (excludeBelowPlugins) {\n        const excludeTypes = getPluginKeys(editor, excludeBelowPlugins);\n        const isBelow = editor.api.above({\n          at: path,\n          match: (n) =>\n            ElementApi.isElement(n) && excludeTypes.includes(n.type),\n        });\n\n        if (isBelow) return false;\n      }\n    }\n\n    return true;\n  };\n};\n","import type { SlateEditor } from '../editor';\nimport type { AnyEditorPlugin, SlatePlugins } from '../plugin/SlatePlugin';\n\n/**\n * Get all plugins having a defined `inject.plugins[plugin.key]`. It includes\n * `plugin` itself.\n */\nexport const getInjectedPlugins = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin\n): Partial<AnyEditorPlugin>[] => {\n  const injectedPlugins: SlatePlugins = [];\n\n  [...editor.meta.pluginList].reverse().forEach((p) => {\n    const injectedPlugin = p.inject.plugins?.[plugin.key];\n\n    if (injectedPlugin) injectedPlugins.push(injectedPlugin as any);\n  });\n\n  return [plugin, ...injectedPlugins];\n};\n","import type { TElement, TText } from '@platejs/slate';\nimport type { AnyObject } from '@udecode/utils';\n\nimport pick from 'lodash/pick.js';\n\nimport type { AnyEditorPlugin } from '../plugin';\n\nimport { type SlateRenderNodeProps, getNodeDataAttributeKeys } from '../static';\n\nexport const getPluginNodeProps = ({\n  attributes: nodeAttributes,\n  node,\n  plugin,\n  props,\n}: {\n  props: SlateRenderNodeProps;\n  attributes?: AnyObject;\n  node?: TElement | TText;\n  plugin?: AnyEditorPlugin;\n}): any => {\n  const newProps: any = { ...props, attributes: { ...props.attributes } };\n\n  if (plugin?.node.props) {\n    const pluginNodeProps =\n      (typeof plugin.node.props === 'function'\n        ? plugin.node.props(newProps as any)\n        : plugin.node.props) ?? {};\n\n    newProps.attributes = {\n      ...newProps.attributes,\n      ...pluginNodeProps,\n    };\n  }\n  if (nodeAttributes && plugin) {\n    // Add data attributes to attributes if attributes is already set\n    newProps.attributes = {\n      ...newProps.attributes,\n      ...pick(\n        nodeAttributes,\n        /**\n         * WARNING: Improper use of `dangerouslyAllowAttributes` WILL make your\n         * application vulnerable to cross-site scripting (XSS) or information\n         * exposure attacks.\n         *\n         * @see {@link BasePluginNode.dangerouslyAllowAttributes}\n         */\n        ...(plugin.node.dangerouslyAllowAttributes ?? []),\n        [...(node ? getNodeDataAttributeKeys(node) : [])]\n      ),\n    };\n  }\n\n  // remove attributes values that are undefined\n  Object.keys(newProps.attributes).forEach((key) => {\n    if (newProps.attributes?.[key] === undefined) {\n      delete newProps.attributes?.[key];\n    }\n  });\n\n  return newProps;\n};\n","import React from 'react';\n\nimport type { SlateEditor } from '../editor';\n\nimport { getPluginByType } from '../plugin';\nimport { SlateElement } from './components/slate-nodes';\nimport {\n  type SlateRenderElement,\n  pluginRenderElementStatic,\n} from './pluginRenderElementStatic';\nimport { getRenderNodeStaticProps } from './utils';\n\nexport const pipeRenderElementStatic = (\n  editor: SlateEditor,\n  {\n    renderElement: renderElementProp,\n  }: {\n    renderElement?: SlateRenderElement;\n  } = {}\n): SlateRenderElement => {\n  return function render(props) {\n    const plugin = getPluginByType(editor, props.element.type);\n\n    if (plugin?.node.isElement) {\n      return pluginRenderElementStatic(editor, plugin)(props as any);\n    }\n\n    if (renderElementProp) {\n      return renderElementProp(props);\n    }\n\n    const ctxProps = getRenderNodeStaticProps({\n      editor,\n      props: { ...props } as any,\n    }) as any;\n\n    return (\n      <SlateElement {...ctxProps}>\n        {props.children}\n\n        {editor.meta.pluginCache.render.belowRootNodes.map((key) => {\n          const plugin = editor.getPlugin({ key }) as any;\n          const Component = plugin.render.belowRootNodes;\n\n          return <Component key={key} {...ctxProps} />;\n        })}\n      </SlateElement>\n    );\n  };\n};\n","/* eslint-disable perfectionist/sort-jsx-props */\nimport React from 'react';\n\nimport type { Path, TElement, TText } from '@platejs/slate';\nimport type { UnknownObject } from '@udecode/utils';\n\nimport { clsx } from 'clsx';\n\nimport type {\n  AnyPluginConfig,\n  PluginConfig,\n  SlatePluginContext,\n} from '../../plugin';\nimport type {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderTextProps,\n} from '../../types';\n\nexport const useNodeAttributes = (props: any, ref?: any) => {\n  return {\n    ...props.attributes,\n    className:\n      clsx((props.attributes as any).className, props.className) || undefined,\n    ref,\n    style: { ...(props.attributes as any).style, ...props.style },\n  };\n};\n\nexport type SlateElementProps<\n  N extends TElement = TElement,\n  C extends AnyPluginConfig = PluginConfig,\n> = SlateNodeProps<C> &\n  RenderElementProps<N> & {\n    attributes: UnknownObject;\n    path: Path;\n  } & DeprecatedNodeProps;\n\ntype DeprecatedNodeProps = {\n  /**\n   * @deprecated Optional class to be merged with `attributes.className`.\n   * @default undefined\n   */\n  className?: string;\n  /**\n   * @deprecated Optional style to be merged with `attributes.style`\n   * @default undefined\n   */\n  style?: React.CSSProperties;\n};\n\nexport type SlateNodeProps<C extends AnyPluginConfig = PluginConfig> =\n  SlatePluginContext<C> & {\n    /**\n     * Optional ref to be merged with `attributes.ref`\n     *\n     * @default undefined\n     */\n    ref?: any;\n  };\n\nexport type SlateHTMLProps<\n  C extends AnyPluginConfig = PluginConfig,\n  T extends keyof HTMLElementTagNameMap = 'div',\n> = SlateNodeProps<C> & {\n  /** HTML attributes to pass to the underlying HTML element */\n  attributes: React.PropsWithoutRef<React.JSX.IntrinsicElements[T]> &\n    UnknownObject;\n  as?: T;\n  /** Class to be merged with `attributes.className` */\n  className?: string;\n  /** Style to be merged with `attributes.style` */\n  style?: React.CSSProperties;\n};\n\nexport type StyledSlateElementProps<\n  N extends TElement = TElement,\n  C extends AnyPluginConfig = PluginConfig,\n  T extends keyof HTMLElementTagNameMap = 'div',\n> = Omit<SlateElementProps<N, C>, keyof DeprecatedNodeProps> &\n  SlateHTMLProps<C, T>;\n\nexport const SlateElement = React.forwardRef(function SlateElement(\n  { as: Tag = 'div', children, ...props }: StyledSlateElementProps,\n  ref: React.ForwardedRef<HTMLDivElement>\n) {\n  const attributes = useNodeAttributes(props, ref);\n\n  const block = !!props.element.id && !!props.editor.api.isBlock(props.element);\n\n  return (\n    <Tag\n      data-slate-node=\"element\"\n      data-slate-inline={attributes['data-slate-inline']}\n      data-block-id={block ? props.element.id : undefined}\n      {...attributes}\n      style={\n        {\n          position: 'relative',\n          ...attributes?.style,\n        } as React.CSSProperties\n      }\n    >\n      {children}\n    </Tag>\n  );\n}) as <\n  N extends TElement = TElement,\n  C extends AnyPluginConfig = PluginConfig,\n  T extends keyof HTMLElementTagNameMap = 'div',\n>(\n  props: StyledSlateElementProps<N, C, T>\n) => React.ReactElement;\n\nexport type SlateTextProps<\n  N extends TText = TText,\n  C extends AnyPluginConfig = PluginConfig,\n> = SlateNodeProps<C> &\n  RenderTextProps<N> &\n  DeprecatedNodeProps & {\n    attributes: UnknownObject;\n  };\n\nexport type StyledSlateTextProps<\n  N extends TText = TText,\n  C extends AnyPluginConfig = PluginConfig,\n  T extends keyof HTMLElementTagNameMap = 'span',\n> = Omit<SlateTextProps<N, C>, keyof DeprecatedNodeProps> &\n  SlateHTMLProps<C, T>;\n\nexport const SlateText = React.forwardRef<\n  HTMLSpanElement,\n  StyledSlateTextProps\n>(({ as: Tag = 'span', children, ...props }, ref) => {\n  const attributes = useNodeAttributes(props, ref);\n\n  return <Tag {...attributes}>{children}</Tag>;\n}) as <\n  N extends TText = TText,\n  C extends AnyPluginConfig = PluginConfig,\n  T extends keyof HTMLElementTagNameMap = 'span',\n>(\n  props: StyledSlateTextProps<N, C, T>\n) => React.ReactElement;\n\nexport type SlateLeafProps<\n  N extends TText = TText,\n  C extends AnyPluginConfig = PluginConfig,\n> = SlateNodeProps<C> &\n  RenderLeafProps<N> &\n  DeprecatedNodeProps & {\n    attributes: UnknownObject;\n    inset?: boolean;\n  };\n\nexport type StyledSlateLeafProps<\n  N extends TText = TText,\n  C extends AnyPluginConfig = PluginConfig,\n  T extends keyof HTMLElementTagNameMap = 'span',\n> = Omit<SlateLeafProps<N, C>, keyof DeprecatedNodeProps> &\n  SlateHTMLProps<C, T>;\n\nconst NonBreakingSpace = () => (\n  <span style={{ fontSize: 0, lineHeight: 0 }} contentEditable={false}>\n    {String.fromCodePoint(160)}\n  </span>\n);\n\nexport const SlateLeaf = React.forwardRef<\n  HTMLSpanElement,\n  StyledSlateLeafProps\n>(({ as: Tag = 'span', children, inset, ...props }, ref) => {\n  const attributes = useNodeAttributes(props, ref);\n\n  if (inset) {\n    return (\n      <>\n        <NonBreakingSpace />\n        <Tag {...attributes}>\n          {children}\n          <NonBreakingSpace />\n        </Tag>\n      </>\n    );\n  }\n\n  return <Tag {...attributes}>{children}</Tag>;\n}) as <\n  N extends TText = TText,\n  C extends AnyPluginConfig = PluginConfig,\n  T extends keyof HTMLElementTagNameMap = 'span',\n>({\n  className,\n  ...props\n}: StyledSlateLeafProps<N, C, T>) => React.ReactElement;\n","import React from 'react';\n\nimport type { SlateEditor } from '../editor';\nimport type { AnyEditorPlugin } from '../plugin';\nimport type { RenderElementProps } from '../types/RenderElementProps';\n\nimport { SlateElement } from './components/slate-nodes';\nimport { getPluginDataAttributes } from './utils';\nimport { getRenderNodeStaticProps } from './utils/getRenderNodeStaticProps';\n\nexport type SlateRenderElement = (\n  props: RenderElementProps\n) => React.ReactElement<any> | undefined;\n\nexport const pluginRenderElementStatic = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin\n): SlateRenderElement =>\n  function render(nodeProps) {\n    const element = nodeProps.element;\n\n    const Component = editor.meta.components?.[plugin.key] as any;\n    const Element = Component ?? SlateElement;\n\n    let { children } = nodeProps;\n\n    const dataAttributes = getPluginDataAttributes(editor, plugin, element);\n\n    nodeProps = getRenderNodeStaticProps({\n      attributes: {\n        ...(element.attributes as any),\n        ...dataAttributes,\n      },\n      editor,\n      node: element,\n      plugin,\n      props: nodeProps as any,\n    }) as any;\n\n    editor.meta.pluginCache.render.belowNodes.forEach((key) => {\n      const hoc = editor.getPlugin({ key }).render.belowNodes!({\n        ...nodeProps,\n        key,\n      } as any);\n\n      if (hoc) {\n        children = hoc({ ...nodeProps, children } as any);\n      }\n    });\n\n    const defaultProps = Component ? {} : { as: plugin.render?.as };\n\n    let component: React.ReactNode = (\n      <Element {...defaultProps} {...nodeProps}>\n        {children}\n\n        {editor.meta.pluginCache.render.belowRootNodes.map((key) => {\n          const plugin = editor.getPlugin({ key }) as any;\n          const Component = plugin.render.belowRootNodes;\n\n          return <Component key={key} {...defaultProps} {...nodeProps} />;\n        })}\n      </Element>\n    );\n\n    editor.meta.pluginCache.render.aboveNodes.forEach((key) => {\n      const hoc = editor.getPlugin({ key }).render.aboveNodes!({\n        ...nodeProps,\n        key,\n      } as any);\n\n      if (hoc) {\n        component = hoc({ ...nodeProps, children: component } as any);\n      }\n    });\n\n    return component;\n  };\n","import React from 'react';\n\nexport function createStaticString({ text }: { text: string }) {\n  return React.createElement(\n    'span',\n    { 'data-slate-string': true },\n    text === '' ? '\\uFEFF' : text\n  );\n}\n","import { type TElement, type TText, TextApi } from '@platejs/slate';\nimport kebabCase from 'lodash/kebabCase.js';\n\nimport type { SlateEditor } from '../../editor';\n\nimport { type AnyEditorPlugin, getEditorPlugin } from '../../plugin';\n\nexport const getNodeDataAttributes = (\n  editor: SlateEditor,\n  node: TElement | TText,\n  {\n    isElement,\n    isLeaf,\n    isText,\n  }: { isElement?: boolean; isLeaf?: boolean; isText?: boolean }\n) => {\n  const dataAttributes = Object.keys(node).reduce((acc, key) => {\n    if (typeof node[key] === 'object') return acc;\n    if (isElement && key === 'children') return acc;\n    if ((isLeaf || isText) && key === 'text') return acc;\n\n    const plugin = editor.getPlugin({ key });\n\n    if (isLeaf && plugin?.node.isLeaf && plugin?.node.isDecoration !== true) {\n      return acc;\n    }\n\n    if (isText && plugin?.node.isLeaf && plugin?.node.isDecoration !== false) {\n      return acc;\n    }\n\n    const attributeName = keyToDataAttribute(key);\n\n    return { ...acc, [attributeName]: node[key] };\n  }, {});\n\n  return dataAttributes;\n};\n\nexport const getPluginDataAttributes = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin,\n  node: TElement | TText\n) => {\n  const isElement = plugin.node.isElement;\n  const isLeaf = plugin.node.isLeaf && plugin.node.isDecoration === true;\n  const isText = plugin.node.isLeaf && plugin.node.isDecoration === false;\n\n  const dataAttributes = getNodeDataAttributes(editor, node, {\n    isElement,\n    isLeaf,\n    isText,\n  });\n\n  const customAttributes =\n    plugin.node.toDataAttributes?.({\n      ...(plugin ? (getEditorPlugin(editor, plugin) as any) : {}),\n      node,\n    }) ?? {};\n\n  return { ...dataAttributes, ...customAttributes };\n};\n\nexport const getNodeDataAttributeKeys = (node: TElement | TText) => {\n  return Object.keys(node)\n    .filter(\n      (key) =>\n        typeof node[key] !== 'object' &&\n        (!TextApi.isText(node) || key !== 'text')\n    )\n    .map((key) => keyToDataAttribute(key));\n};\n\nexport const keyToDataAttribute = (key: string) => {\n  return `data-slate-${kebabCase(key)}`;\n};\n","import type { TElement, TText } from '@platejs/slate';\nimport type { AnyObject } from '@udecode/utils';\n\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../../editor';\nimport type { SlateRenderNodeProps } from '../types';\n\nimport { pipeInjectNodeProps } from '../../../internal/plugin/pipeInjectNodeProps';\nimport { type AnyEditorPlugin, getEditorPlugin } from '../../plugin';\nimport { getSlateClass } from '../../utils';\nimport { getPluginNodeProps } from '../../utils/getPluginNodeProps';\n\nexport const getRenderNodeStaticProps = ({\n  attributes: nodeAttributes,\n  editor,\n  node,\n  plugin,\n  props,\n}: {\n  editor: SlateEditor;\n  props: SlateRenderNodeProps;\n  attributes?: AnyObject;\n  node?: TElement | TText;\n  plugin?: AnyEditorPlugin;\n}): SlateRenderNodeProps => {\n  let newProps = {\n    ...props,\n    ...(plugin\n      ? (getEditorPlugin(editor, plugin) as any)\n      : {\n          api: editor.api,\n          editor,\n          tf: editor.transforms,\n        }),\n  };\n\n  const { className } = props;\n\n  const pluginProps = getPluginNodeProps({\n    attributes: nodeAttributes,\n    node,\n    plugin,\n    props: newProps,\n  });\n\n  newProps = {\n    ...pluginProps,\n    attributes: {\n      ...pluginProps.attributes,\n      className: clsx(getSlateClass(plugin?.node.type), className) || undefined,\n    },\n  };\n\n  newProps = pipeInjectNodeProps(\n    editor,\n    newProps,\n    (node) => editor.api.findPath(node)!\n  );\n\n  if (newProps.style && Object.keys(newProps.style).length === 0) {\n    delete newProps.style;\n  }\n\n  return newProps;\n};\n","import type { Path, TElement, TText } from '@platejs/slate';\n\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../../lib/editor';\n\nimport { isEditOnly } from './isEditOnlyDisabled';\nimport { pluginInjectNodeProps } from './pluginInjectNodeProps';\n\n/** Inject plugin props, editor. */\nexport const pipeInjectNodeProps = (\n  editor: SlateEditor,\n  nodeProps: any,\n  getElementPath: (node: TElement | TText) => Path,\n  readOnly = false\n) => {\n  editor.meta.pluginCache.inject.nodeProps.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n\n    const newAttributes = pluginInjectNodeProps(\n      editor,\n      plugin,\n      nodeProps,\n      getElementPath\n    );\n\n    // Since `inject.nodeProps` can have hooks, we can't return early.\n    if (isEditOnly(readOnly, plugin, 'inject')) {\n      return;\n    }\n\n    if (!newAttributes) return;\n\n    const attributes = nodeProps.attributes;\n\n    nodeProps.attributes = {\n      ...attributes,\n      ...newAttributes,\n      className:\n        clsx(attributes?.className, newAttributes.className) || undefined,\n      style: {\n        ...attributes?.style,\n        ...newAttributes.style,\n      },\n    };\n  });\n\n  return nodeProps;\n};\n","const DEFAULT = {\n  handlers: true,\n  inject: true,\n  normalizeInitialValue: false,\n  render: true,\n};\n\n/**\n * Check if a plugin feature is disabled in read-only mode based on editOnly\n * configuration.\n *\n * @param plugin The plugin to check\n * @param isReadOnly Whether the editor is in read-only mode\n * @param feature The feature to check ('render' | 'handlers' | 'inject' |\n *   'normalizeInitialValue')\n * @returns True if the feature should be disabled\n */\nexport const isEditOnly = (\n  readOnly: boolean,\n  plugin: any,\n  feature: keyof typeof DEFAULT\n): boolean => {\n  if (!readOnly) return false;\n\n  // If editOnly is true, use the default value for the feature\n  if (plugin.editOnly === true) {\n    return DEFAULT[feature];\n  }\n\n  // If editOnly is an object, use its value if specified, otherwise use default\n  if (typeof plugin.editOnly === 'object') {\n    return plugin.editOnly[feature] ?? DEFAULT[feature];\n  }\n\n  return false;\n};\n","import type { Path, TElement, TText } from '@platejs/slate';\n\nimport { isDefined } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../lib/editor';\nimport type {\n  EditorPlugin,\n  TransformOptions,\n} from '../../lib/plugin/SlatePlugin';\n\nimport {\n  type GetInjectNodePropsOptions,\n  type GetInjectNodePropsReturnType,\n  getEditorPlugin,\n} from '../../lib/plugin';\nimport { getInjectMatch } from '../../lib/utils/getInjectMatch';\n\n/**\n * Return if `element`, `text`, `nodeKey` is defined. Return if `node.type` is\n * not in `targetPlugins` (if defined). Return if `value = node[nodeKey]` is not\n * in `validNodeValues` (if defined). If `classNames[value]` is defined,\n * override `className` with it. If `styleKey` is defined, override `style` with\n * `[styleKey]: value`.\n */\nexport const pluginInjectNodeProps = (\n  editor: SlateEditor,\n  plugin: EditorPlugin,\n  nodeProps: GetInjectNodePropsOptions,\n  getElementPath: (node: TElement | TText) => Path\n): GetInjectNodePropsReturnType | undefined => {\n  const {\n    key,\n    inject: { nodeProps: injectNodeProps },\n  } = plugin;\n\n  const { element, text } = nodeProps;\n\n  const node = element ?? text;\n\n  if (!node) return;\n  if (!injectNodeProps) return;\n\n  const {\n    classNames,\n    defaultNodeValue,\n    nodeKey = editor.getType(key),\n    query,\n    styleKey = nodeKey as any,\n    transformClassName,\n    transformNodeValue,\n    transformProps,\n    transformStyle,\n    validNodeValues,\n  } = injectNodeProps;\n\n  const injectMatch = getInjectMatch(editor, plugin);\n\n  if (!injectMatch(node, getElementPath(node))) return;\n\n  const queryResult = query?.({\n    ...injectNodeProps,\n    ...(getEditorPlugin(editor, plugin) as any),\n    nodeProps,\n  });\n\n  if (query && !queryResult) {\n    return;\n  }\n\n  const nodeValue = node[nodeKey!] as any;\n\n  // early return if there is no reason to inject props\n  if (\n    !transformProps &&\n    (!isDefined(nodeValue) ||\n      (validNodeValues && !validNodeValues.includes(nodeValue)) ||\n      nodeValue === defaultNodeValue)\n  ) {\n    return;\n  }\n\n  const transformOptions: TransformOptions = {\n    ...nodeProps,\n    ...(getEditorPlugin(editor, plugin) as any),\n    nodeValue,\n  };\n  const value = transformNodeValue?.(transformOptions) ?? nodeValue;\n  transformOptions.value = value;\n\n  let newProps: GetInjectNodePropsReturnType = {};\n\n  if (element && nodeKey && nodeValue) {\n    newProps.className = `slate-${nodeKey}-${nodeValue}`;\n  }\n  if (classNames?.[nodeValue] || transformClassName) {\n    newProps.className =\n      transformClassName?.(transformOptions) ?? classNames?.[value];\n  }\n  if (styleKey) {\n    newProps.style =\n      transformStyle?.(transformOptions) ??\n      ({\n        [styleKey as string]: value,\n      } as any);\n  }\n  if (transformProps) {\n    newProps =\n      transformProps({ ...transformOptions, props: newProps }) ?? newProps;\n  }\n\n  return newProps;\n};\n","/** Get the slate nodes from the DOM selection */\n/** @deprecated Use getSelectedDomFragment instead */\nexport const getSelectedDomBlocks = () => {\n  const selection = window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) return;\n\n  const range = selection.getRangeAt(0);\n  const fragment = range.cloneContents();\n\n  const domBlocks = fragment.querySelectorAll(\n    '[data-slate-node=\"element\"][data-slate-id]'\n  );\n\n  return Array.from(domBlocks);\n};\n","import { type Descendant, ElementApi, NodeApi } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../editor';\n\nexport const getSelectedDomFragment = (editor: SlateEditor): Descendant[] => {\n  const selection = window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) return [];\n\n  const range = selection.getRangeAt(0);\n  const fragment = range.cloneContents();\n\n  const _domBlocks = fragment.querySelectorAll(\n    '[data-slate-node=\"element\"][data-slate-id]'\n  );\n\n  const domBlocks = Array.from(_domBlocks);\n\n  if (domBlocks.length === 0) return [];\n\n  const nodes: Descendant[] = [];\n\n  domBlocks.forEach((node, index) => {\n    const blockId = (node as HTMLElement).dataset.slateId;\n    const block = editor.api.node({ id: blockId, at: [] });\n\n    // prevent inline elements like link and table cells.\n    if (!block || block[1].length !== 1) return;\n\n    /**\n     * If the selection don't cover the all first or last block, we need\n     * fallback to deserialize the block to get the correct fragment\n     */\n    if (\n      (index === 0 || index === domBlocks.length - 1) &&\n      node.textContent?.trim() !== NodeApi.string(block[0]) &&\n      ElementApi.isElement(block[0]) &&\n      !editor.api.isVoid(block[0])\n    ) {\n      const html = document.createElement('div');\n      html.append(node);\n      const results = editor.api.html.deserialize({ element: html });\n      nodes.push(results[0]);\n    } else {\n      nodes.push(block[0]);\n    }\n  });\n\n  return nodes;\n};\n","/** Get the DOM node from the DOM selection */\nexport const getSelectedDomNode = () => {\n  const selection = window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) return;\n  const range = selection.getRangeAt(0);\n\n  const htmlFragment = range.cloneContents();\n  const div = document.createElement('div');\n  div.append(htmlFragment);\n\n  return div;\n};\n","import { getSelectedDomNode } from './getSelectedDomNode';\n\n/** Check if the DOM selection is outside the editor */\nexport const isSelectOutside = (html?: HTMLElement): boolean => {\n  const domNodes = html ?? getSelectedDomNode();\n\n  if (!domNodes) return false;\n\n  const selectOutside = !!domNodes?.querySelector('[data-slate-editor=\"true\"');\n\n  return selectOutside;\n};\n","import type { NodeEntry, TRange } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../editor';\nimport type { EditableProps } from '../../types/EditableProps';\n\nimport { getEditorPlugin } from '../../plugin';\n\n/**\n * @see {@link Decorate} .\n * Optimization: return undefined if empty list so Editable uses a memo.\n */\nexport const pipeDecorate = (\n  editor: SlateEditor,\n  decorateProp?:\n    | ((ctx: { editor: SlateEditor; entry: NodeEntry }) => TRange[] | undefined)\n    | null\n): EditableProps['decorate'] => {\n  if (editor.meta.pluginCache.decorate.length === 0 && !decorateProp) return;\n\n  return (entry: NodeEntry) => {\n    let ranges: TRange[] = [];\n\n    const addRanges = (newRanges?: TRange[]) => {\n      if (newRanges?.length) ranges = [...ranges, ...newRanges];\n    };\n\n    editor.meta.pluginCache.decorate.forEach((key) => {\n      const plugin = editor.getPlugin({ key });\n      addRanges(\n        plugin.decorate!({\n          ...(getEditorPlugin(editor, plugin) as any),\n          entry,\n        })\n      );\n    });\n\n    if (decorateProp) {\n      addRanges(\n        decorateProp({\n          editor,\n          entry,\n        })\n      );\n    }\n\n    return ranges;\n  };\n};\n","const classAttrRegExp = / class=\"([^\"]*)\"/g;\n\n/**\n * Remove all class names that do not start with one of preserveClassNames\n * (`slate-` by default)\n */\nexport const stripHtmlClassNames = (\n  html: string,\n  { preserveClassNames = ['slate-'] }: { preserveClassNames?: string[] }\n) => {\n  if (preserveClassNames.length === 0) {\n    return html.replaceAll(classAttrRegExp, '');\n  }\n\n  const preserveRegExp = new RegExp(\n    preserveClassNames.map((cn) => `^${cn}`).join('|')\n  );\n\n  return html.replaceAll(\n    classAttrRegExp,\n    (match: string, className: string) => {\n      const classesToKeep = className\n        .split(/\\s+/)\n        .filter((cn) => preserveRegExp.test(cn));\n\n      return classesToKeep.length === 0\n        ? ''\n        : ` class=\"${classesToKeep.join(' ')}\"`;\n    }\n  );\n};\n","// Remove redundant data attributes\nexport const stripSlateDataAttributes = (rawHtml: string): string =>\n  rawHtml\n    .replaceAll(/ data-slate(?:-node|-type|-leaf|-string)=\"[^\"]+\"/g, '')\n    .replaceAll(/ data-testid=\"[^\"]+\"/g, '');\n","import React from 'react';\n\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../editor';\nimport type { SlatePlugin } from '../plugin';\nimport type { RenderLeafProps } from '../types/RenderLeafProps';\n\nimport { SlateLeaf } from './components';\nimport { getNodeDataAttributes } from './utils/getNodeDataAttributes';\nimport { getRenderNodeStaticProps } from './utils/getRenderNodeStaticProps';\n\nexport type SlateRenderLeaf = (\n  props: RenderLeafProps\n) => React.ReactElement<any> | undefined;\n\nexport const pluginRenderLeafStatic = (\n  editor: SlateEditor,\n  plugin: SlatePlugin\n): SlateRenderLeaf =>\n  function render(props) {\n    const { children, leaf } = props;\n\n    if (leaf[plugin.node.type]) {\n      const Component = (plugin.render.leaf ??\n        editor.meta.components?.[plugin.key]) as any;\n      const Leaf = Component ?? SlateLeaf;\n\n      const ctxProps = getRenderNodeStaticProps({\n        attributes: { ...(leaf.attributes as any) },\n        editor,\n        node: leaf,\n        plugin,\n        props: props as any,\n      }) as any;\n\n      const defaultProps = Component ? {} : { as: plugin.render?.as };\n\n      return (\n        <Leaf {...defaultProps} {...ctxProps}>\n          {children}\n        </Leaf>\n      );\n    }\n\n    return children;\n  };\n\n/** @see {@link RenderLeaf} */\nexport const pipeRenderLeafStatic = (\n  editor: SlateEditor,\n  { renderLeaf: renderLeafProp }: { renderLeaf?: SlateRenderLeaf } = {}\n): SlateRenderLeaf => {\n  const renderLeafs: SlateRenderLeaf[] = [];\n  const leafPropsPlugins: SlatePlugin[] = [];\n\n  editor.meta.pluginCache.node.isLeaf.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n\n    if (plugin) {\n      renderLeafs.push(pluginRenderLeafStatic(editor, plugin as any));\n    }\n  });\n\n  editor.meta.pluginCache.node.leafProps.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n    if (plugin) {\n      leafPropsPlugins.push(plugin as any);\n    }\n  });\n\n  return function render({ attributes, ...props }) {\n    renderLeafs.forEach((render) => {\n      const newChildren = render(props as any);\n\n      if (newChildren !== undefined) {\n        props.children = newChildren;\n      }\n    });\n\n    leafPropsPlugins.forEach((plugin) => {\n      if (props.leaf[plugin.node.type]) {\n        const pluginLeafProps =\n          typeof plugin.node.leafProps === 'function'\n            ? plugin.node.leafProps(props as any)\n            : (plugin.node.leafProps ?? {});\n\n        if (pluginLeafProps.className) {\n          pluginLeafProps.className = clsx(\n            (props as any).className,\n            pluginLeafProps.className\n          );\n        }\n\n        attributes = {\n          ...attributes,\n          ...pluginLeafProps,\n        };\n      }\n    });\n\n    if (renderLeafProp) {\n      return renderLeafProp({ attributes, ...props });\n    }\n\n    const ctxProps = getRenderNodeStaticProps({\n      editor,\n      props: { attributes, ...props } as any,\n    }) as any;\n\n    const leaf = ctxProps.leaf;\n    const dataAttributes = getNodeDataAttributes(editor, leaf, {\n      isLeaf: true,\n    });\n\n    return (\n      <SlateLeaf\n        {...ctxProps}\n        attributes={{\n          ...ctxProps.attributes,\n          ...dataAttributes,\n        }}\n      />\n    );\n  };\n};\n","import React from 'react';\n\nimport {\n  type DecoratedRange,\n  type Descendant,\n  type NodeEntry,\n  type TElement,\n  type TText,\n  type Value,\n  ElementApi,\n  isElementDecorationsEqual,\n  isTextDecorationsEqual,\n  RangeApi,\n  TextApi,\n} from '@platejs/slate';\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../../editor';\nimport type { EditableProps } from '../../types/EditableProps';\nimport type { SlateRenderElementProps } from '../types';\n\nimport { pipeRenderElementStatic } from '../pipeRenderElementStatic';\nimport { pipeRenderLeafStatic } from '../pluginRenderLeafStatic';\nimport { pipeRenderTextStatic } from '../pluginRenderTextStatic';\nimport { pipeDecorate } from '../utils/pipeDecorate';\n\nfunction BaseElementStatic({\n  decorate,\n  decorations,\n  editor,\n  element = { children: [], type: '' },\n}: {\n  decorate: EditableProps['decorate'];\n  decorations: DecoratedRange[];\n  editor: SlateEditor;\n  element: TElement;\n  style?: React.CSSProperties;\n}) {\n  const renderElement = pipeRenderElementStatic(editor);\n\n  const attributes: SlateRenderElementProps['attributes'] = {\n    'data-slate-node': 'element',\n    ref: null,\n  };\n\n  let children: React.ReactNode = (\n    <Children decorate={decorate} decorations={decorations} editor={editor}>\n      {element.children}\n    </Children>\n  );\n\n  if (editor.api.isVoid(element)) {\n    attributes['data-slate-void'] = true;\n    children = (\n      <span\n        style={{\n          color: 'transparent',\n          height: '0',\n          outline: 'none',\n          position: 'absolute',\n        }}\n        data-slate-spacer\n      >\n        <Children decorate={decorate} decorations={decorations} editor={editor}>\n          {element.children}\n        </Children>\n      </span>\n    );\n  }\n  if (editor.api.isInline(element)) {\n    attributes['data-slate-inline'] = true;\n  }\n\n  return (\n    <React.Fragment>\n      {renderElement?.({ attributes, children, element })}\n    </React.Fragment>\n  );\n}\n\nexport const ElementStatic = React.memo(BaseElementStatic, (prev, next) => {\n  return (\n    (prev.element === next.element ||\n      (prev.element._memo !== undefined &&\n        prev.element._memo === next.element._memo)) &&\n    isElementDecorationsEqual(prev.decorations, next.decorations)\n  );\n});\n\nfunction BaseLeafStatic({\n  decorations,\n  editor,\n  text: text = { text: '' },\n}: {\n  decorations: DecoratedRange[];\n  editor: SlateEditor;\n  text: TText;\n}) {\n  const renderLeaf = pipeRenderLeafStatic(editor);\n  const renderText = pipeRenderTextStatic(editor);\n\n  const decoratedLeaves = TextApi.decorations(text, decorations);\n\n  const leafElements = decoratedLeaves.map(({ leaf, position }, index) => {\n    const leafElement = renderLeaf({\n      attributes: { 'data-slate-leaf': true },\n      children: (\n        <span data-slate-string={true}>\n          {leaf.text === '' ? '\\uFEFF' : leaf.text}\n        </span>\n      ),\n      leaf: leaf as TText,\n      leafPosition: position,\n      text: leaf as TText,\n    });\n\n    return <React.Fragment key={index}>{leafElement}</React.Fragment>;\n  });\n\n  return renderText({\n    attributes: { 'data-slate-node': 'text' as const, ref: null },\n    children: leafElements,\n    text: text as TText,\n  });\n}\n\nexport const LeafStatic = React.memo(BaseLeafStatic, (prev, next) => {\n  return (\n    // prev.text === next.text &&\n    TextApi.equals(next.text, prev.text) &&\n    isTextDecorationsEqual(next.decorations, prev.decorations)\n  );\n});\n\nconst defaultDecorate: (entry: NodeEntry) => DecoratedRange[] = () => [];\n\nfunction Children({\n  children = [],\n  decorate = defaultDecorate,\n  decorations = [],\n  editor,\n}: {\n  children: Descendant[];\n  decorate: EditableProps['decorate'];\n  decorations: DecoratedRange[];\n  editor: SlateEditor;\n}) {\n  return (\n    <React.Fragment>\n      {children.map((child, i) => {\n        const p = editor.api.findPath(child);\n\n        let ds: DecoratedRange[] = [];\n\n        if (p) {\n          const range = editor.api.range(p)!;\n          ds = decorate([child, p]);\n\n          for (const dec of decorations) {\n            const d = RangeApi.intersection(dec, range);\n\n            if (d) {\n              ds.push(d);\n            }\n          }\n        }\n\n        return ElementApi.isElement(child) ? (\n          <ElementStatic\n            key={i}\n            decorate={decorate}\n            decorations={ds}\n            editor={editor}\n            element={child}\n          />\n        ) : (\n          <LeafStatic key={i} decorations={ds} editor={editor} text={child} />\n        );\n      })}\n    </React.Fragment>\n  );\n}\n\nexport type PlateStaticProps = {\n  /** Editor instance. */\n  editor: SlateEditor;\n  style?: React.CSSProperties;\n  /** Controlled value. Alias to `editor.children`. */\n  value?: Value;\n} & React.HTMLAttributes<HTMLDivElement>;\n\nexport function PlateStatic(props: PlateStaticProps) {\n  const { className, editor, value, ...rest } = props;\n\n  if (value) {\n    editor.children = value;\n  }\n\n  const decorate = pipeDecorate(editor);\n\n  let afterEditable: React.ReactNode = null;\n  let beforeEditable: React.ReactNode = null;\n\n  editor.meta.pluginCache.render.beforeEditable.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n    const BeforeEditable = plugin.render.beforeEditable;\n\n    if (BeforeEditable) {\n      beforeEditable = (\n        <>\n          {beforeEditable}\n          <BeforeEditable />\n        </>\n      );\n    }\n  });\n\n  editor.meta.pluginCache.render.afterEditable.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n    const AfterEditable = plugin.render.afterEditable;\n\n    if (AfterEditable) {\n      afterEditable = (\n        <>\n          {afterEditable}\n          <AfterEditable />\n        </>\n      );\n    }\n  });\n\n  const content = (\n    <div\n      className={clsx('slate-editor', className)}\n      data-slate-editor\n      data-slate-node=\"value\"\n      {...rest}\n    >\n      <Children decorate={decorate} decorations={[]} editor={editor}>\n        {editor.children}\n      </Children>\n    </div>\n  );\n\n  let aboveEditable: React.ReactNode = (\n    <>\n      {beforeEditable}\n      {content}\n      {afterEditable}\n    </>\n  );\n\n  // Use pre-computed arrays for aboveEditable components\n  editor.meta.pluginCache.render.aboveEditable.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n    const AboveEditable = plugin.render.aboveEditable;\n\n    if (AboveEditable) {\n      aboveEditable = <AboveEditable>{aboveEditable}</AboveEditable>;\n    }\n  });\n\n  return aboveEditable;\n}\n","import React from 'react';\n\nimport clsx from 'clsx';\n\nimport type { SlateEditor } from '../editor';\nimport type { SlatePlugin } from '../plugin';\nimport type { RenderTextProps } from '../types/RenderTextProps';\n\nimport { SlateText } from './components';\nimport { getNodeDataAttributes } from './utils/getNodeDataAttributes';\nimport { getRenderNodeStaticProps } from './utils/getRenderNodeStaticProps';\n\nexport type SlateRenderText = (\n  props: RenderTextProps\n) => React.ReactElement<any> | undefined;\n\nexport const pluginRenderTextStatic = (\n  editor: SlateEditor,\n  plugin: SlatePlugin\n): SlateRenderText =>\n  function render(nodeProps) {\n    const { children, text } = nodeProps;\n\n    if (text[plugin.node.type ?? plugin.key]) {\n      const Component = editor.meta.components?.[plugin.key] as any;\n      const Text = Component ?? SlateText;\n\n      // const dataAttributes = getPluginDataAttributes(editor, plugin, text);\n\n      const ctxProps = getRenderNodeStaticProps({\n        attributes: { ...(text.attributes as any) },\n        editor,\n        node: text,\n        plugin,\n        props: nodeProps as any,\n      }) as any;\n\n      const defaultProps = Component ? {} : { as: plugin.render?.as };\n\n      return (\n        <Text {...defaultProps} {...ctxProps}>\n          {children}\n        </Text>\n      );\n    }\n\n    return children;\n  };\n\n/** @see {@link RenderText} */\nexport const pipeRenderTextStatic = (\n  editor: SlateEditor,\n  { renderText: renderTextProp }: { renderText?: SlateRenderText } = {}\n): SlateRenderText => {\n  const renderTexts: SlateRenderText[] = [];\n  const textPropsPlugins: SlatePlugin[] = [];\n\n  editor.meta.pluginCache.node.isText.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n\n    if (plugin) {\n      renderTexts.push(pluginRenderTextStatic(editor, plugin as any));\n    }\n  });\n\n  editor.meta.pluginCache.node.textProps.forEach((key) => {\n    const plugin = editor.getPlugin({ key });\n    if (plugin) {\n      textPropsPlugins.push(plugin as any);\n    }\n  });\n\n  return function render({ attributes, ...props }) {\n    renderTexts.forEach((render) => {\n      const newChildren = render(props as any);\n\n      if (newChildren !== undefined) {\n        props.children = newChildren;\n      }\n    });\n\n    textPropsPlugins.forEach((plugin) => {\n      if (props.text[plugin.node.type ?? plugin.key]) {\n        const pluginTextProps =\n          typeof plugin.node.textProps === 'function'\n            ? plugin.node.textProps(props as any)\n            : (plugin.node.textProps ?? {});\n\n        if (pluginTextProps.className) {\n          pluginTextProps.className = clsx(\n            (props as any).className,\n            pluginTextProps.className\n          );\n        }\n\n        attributes = {\n          ...attributes,\n          ...pluginTextProps,\n        };\n      }\n    });\n\n    if (renderTextProp) {\n      return renderTextProp({ attributes, ...props });\n    }\n\n    const ctxProps = getRenderNodeStaticProps({\n      editor,\n      props: { attributes, ...props } as any,\n    }) as any;\n\n    const text = ctxProps.text;\n    const dataAttributes = getNodeDataAttributes(editor, text, {\n      isText: true,\n    });\n\n    return (\n      <SlateText\n        {...ctxProps}\n        attributes={{\n          ...ctxProps.attributes,\n          ...dataAttributes,\n        }}\n      />\n    );\n  };\n};\n","import React from 'react';\n\nimport { decode } from 'html-entities';\n\nimport type { SlateEditor } from '../editor';\nimport type { PlateStaticProps } from './components/PlateStatic';\n\nimport { PlateStatic } from './components/PlateStatic';\nimport { stripHtmlClassNames } from './utils/stripHtmlClassNames';\nimport { stripSlateDataAttributes } from './utils/stripSlateDataAttributes';\n\nconst getReactDOMServer = async () => {\n  const ReactDOMServer = (await import('react-dom/server')).default;\n\n  return ReactDOMServer;\n};\n\nconst renderComponentToHtml = <P extends {}>(\n  ReactDOMServer: any,\n  Component: React.ComponentType<P>,\n  props: P\n): string => {\n  return decode(\n    ReactDOMServer.renderToStaticMarkup(React.createElement(Component, props))\n  );\n};\n\nexport type SerializeHtmlOptions<\n  T extends PlateStaticProps = PlateStaticProps,\n> = {\n  /** The component used to render the editor content */\n  editorComponent?: React.ComponentType<T>;\n  /** List of className prefixes to preserve from being stripped out */\n  preserveClassNames?: string[];\n  /** Props to pass to the editor component */\n  props?: Partial<T>;\n  /** Enable stripping class names */\n  stripClassNames?: boolean;\n  /** Enable stripping data attributes */\n  stripDataAttributes?: boolean;\n};\n\n/**\n * Serialize the editor content to HTML. By default, uses `PlateStatic` as the\n * editor component, but you can provide a custom component (e.g.\n * `EditorStatic`).\n */\nexport const serializeHtml = async <\n  T extends PlateStaticProps = PlateStaticProps,\n>(\n  editor: SlateEditor,\n  {\n    editorComponent: EditorComponent = PlateStatic,\n    preserveClassNames,\n    props = {},\n    stripClassNames = false,\n    stripDataAttributes = false,\n  }: SerializeHtmlOptions<T> = {}\n): Promise<string> => {\n  const ReactDOMServer = await getReactDOMServer();\n\n  let htmlString = renderComponentToHtml(ReactDOMServer, EditorComponent, {\n    editor,\n    ...props,\n  } as T);\n\n  if (stripClassNames) {\n    htmlString = stripHtmlClassNames(htmlString, {\n      preserveClassNames,\n    });\n  }\n  if (stripDataAttributes) {\n    htmlString = stripSlateDataAttributes(htmlString);\n  }\n\n  return htmlString;\n};\n","export const isSlateVoid = (element: HTMLElement) => {\n  return element.dataset.slateVoid === 'true';\n};\n\nexport const isSlateElement = (element: HTMLElement) => {\n  return element.dataset.slateNode === 'element';\n};\n\nexport const isSlateText = (element: HTMLElement) => {\n  return element.dataset.slateNode === 'text';\n};\n\nexport const isSlateString = (element: HTMLElement) => {\n  return element.dataset.slateString === 'true';\n};\n\nexport const isSlateLeaf = (element: HTMLElement) => {\n  return element.dataset.slateLeaf === 'true';\n};\n\nexport const isSlateEditor = (element: HTMLElement) => {\n  return element.dataset.slateEditor === 'true';\n};\n\nexport const isSlateNode = (element: HTMLElement) => {\n  return (\n    isSlateLeaf(element) ||\n    isSlateElement(element) ||\n    isSlateVoid(element) ||\n    isSlateString(element) ||\n    isSlateText(element)\n  );\n};\n\nexport const isSlatePluginElement = (\n  element: HTMLElement,\n  pluginKey: string\n) => {\n  return (\n    element.dataset.slateNode === 'element' &&\n    element.classList.contains(`slate-${pluginKey}`)\n  );\n};\n\nexport const isSlatePluginNode = (element: HTMLElement, pluginKey: string) => {\n  return element.classList.contains(`slate-${pluginKey}`);\n};\n\nexport const getSlateElements = (element: HTMLElement): HTMLElement[] => {\n  return Array.from(element.querySelectorAll('[data-slate-node=\"element\"]'));\n};\n","/**\n * Convert HTML string exported from Plate into HTML element.\n *\n * @param html - The HTML string to convert exported from Plate.\n * @returns The Editor element without head and body.\n */\nexport const getEditorDOMFromHtmlString = (html: string) => {\n  const node = document.createElement('body');\n  node.innerHTML = html;\n  const editorNode = node.querySelector('[data-slate-editor=\"true\"]');\n\n  return editorNode as HTMLElement;\n};\n","import { type Editor, type Value, createEditor } from '@platejs/slate';\n\nimport type { AnyPluginConfig } from '../../plugin';\nimport type { CorePlugin } from '../../plugins';\n\nimport {\n  type CreateSlateEditorOptions,\n  type WithSlateOptions,\n  withSlate,\n} from '../../editor';\nimport { getStaticPlugins } from '../plugins/getStaticPlugins';\n\ntype CreateStaticEditorOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = CreateSlateEditorOptions<V, P> & {};\n\ntype WithStaticOptions<\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n> = WithSlateOptions<V, P> & {};\n\nconst withStatic = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>(\n  editor: Editor,\n  options: WithStaticOptions<V, P> = {}\n) => {\n  const { plugins = [], ...rest } = options;\n\n  const staticPlugins = getStaticPlugins() as any;\n\n  options.plugins = [...staticPlugins, ...plugins];\n\n  return withSlate<V, P>(editor, options);\n};\n\nexport const createStaticEditor = <\n  V extends Value = Value,\n  P extends AnyPluginConfig = CorePlugin,\n>({\n  editor = createEditor(),\n  ...options\n}: CreateStaticEditorOptions<V, P> = {}) => {\n  return withStatic<V, P>(editor, options);\n};\n","import {\n  type Path,\n  type TText,\n  ElementApi,\n  NodeApi,\n  TextApi,\n} from '@platejs/slate';\n\nimport type { PluginConfig } from '../../plugin/BasePlugin';\nimport type { EdgeNodes } from './types';\n\nimport { createTSlatePlugin } from '../../plugin/createSlatePlugin';\nimport { getPluginByType } from '../../plugin/getSlatePlugin';\nimport { getEdgeNodes } from './queries';\nimport { getMarkBoundaryAffinity } from './queries/getMarkBoundaryAffinity';\nimport { isNodesAffinity } from './queries/isNodeAffinity';\nimport { setAffinitySelection } from './transforms/setAffinitySelection';\n\nexport type ElementAffinity = {\n  affinity: 'backward' | 'forward';\n  at: Path;\n  type: string;\n};\n\nexport type AffinityConfig = PluginConfig<'affinity'>;\n\n// REVIEW: performance\nexport const AffinityPlugin = createTSlatePlugin<AffinityConfig>({\n  key: 'affinity',\n}).overrideEditor(({ editor, tf: { deleteBackward, insertText, move } }) => ({\n  transforms: {\n    /**\n     * On backspace, if the deletion results in the cursor being at a mark\n     * boundary, then the affinity should be forward. If the deletion removes a\n     * character from the left mark, then the affinity should be backward.\n     */\n    deleteBackward: (unit) => {\n      const apply = () => {\n        if (unit === 'character' && editor.api.isCollapsed()) {\n          const [start] = getEdgeNodes(editor) ?? [null];\n\n          const startText =\n            start &&\n            (TextApi.isText(start[0])\n              ? start[0].text\n              : NodeApi.string(start[0]));\n\n          deleteBackward(unit);\n\n          const edgeNodes = getEdgeNodes(editor);\n\n          if (\n            edgeNodes &&\n            isNodesAffinity(editor, edgeNodes, 'directional') &&\n            !hasElement(edgeNodes)\n          ) {\n            const affinity =\n              startText && startText.length > 1 ? 'backward' : 'forward';\n            setAffinitySelection(editor, edgeNodes, affinity);\n          }\n          return true;\n        }\n      };\n\n      if (apply()) return;\n\n      deleteBackward(unit);\n    },\n    insertText(text, options) {\n      /** This will be computed only for text nodes with marks. */\n      const applyOutwardAffinity = () => {\n        if (!editor.selection || editor.api.isExpanded()) {\n          return;\n        }\n\n        const textPath = editor.selection.focus.path;\n        const textNode = NodeApi.get<TText>(editor, textPath);\n\n        if (!textNode) {\n          return;\n        }\n\n        const marks = Object.keys(NodeApi.extractProps(textNode));\n        const outwardMarks = marks.filter(\n          (type) =>\n            getPluginByType(editor, type)?.rules.selection?.affinity ===\n            'outward'\n        );\n\n        if (\n          !outwardMarks.length ||\n          !editor.api.isEnd(editor.selection.focus, textPath)\n        ) {\n          return;\n        }\n\n        const nextPoint = editor.api.start(textPath, { next: true });\n        const marksToRemove: string[] = [];\n\n        // Get next text node once outside the loop\n        let nextTextNode: TText | null = null;\n        if (nextPoint) {\n          const nextTextPath = nextPoint.path;\n          nextTextNode = NodeApi.get<TText>(editor, nextTextPath) || null;\n        }\n\n        // Check each mark individually\n        for (const markKey of outwardMarks) {\n          if (!textNode[markKey]) {\n            continue; // Skip marks not present on current node\n          }\n\n          const isBetweenSameMarks = nextTextNode?.[markKey];\n\n          if (!isBetweenSameMarks) {\n            marksToRemove.push(markKey);\n          }\n        }\n\n        if (marksToRemove.length > 0) {\n          editor.tf.removeMarks(marksToRemove);\n        }\n      };\n\n      applyOutwardAffinity();\n\n      return insertText(text, options);\n    },\n    move: (options) => {\n      const apply = () => {\n        const {\n          distance = 1,\n          reverse = false,\n          unit = 'character',\n        } = options || {};\n\n        if (\n          unit === 'character' &&\n          distance === 1 &&\n          editor.api.isCollapsed()\n        ) {\n          const preEdgeNodes = getEdgeNodes(editor);\n\n          if (preEdgeNodes && isNodesAffinity(editor, preEdgeNodes, 'hard')) {\n            if (\n              preEdgeNodes &&\n              preEdgeNodes[reverse ? 0 : 1] === null &&\n              getMarkBoundaryAffinity(editor, preEdgeNodes) ===\n                (reverse ? 'forward' : 'backward')\n            ) {\n              setAffinitySelection(\n                editor,\n                preEdgeNodes,\n                reverse ? 'backward' : 'forward'\n              );\n\n              return true;\n            }\n\n            move({ ...options, unit: 'offset' });\n            return true;\n          }\n\n          move(options);\n\n          const postEdgeNodes = getEdgeNodes(editor);\n\n          /**\n           * If the move places the cursor at a mark boundary, then the affinity\n           * should be set to the direction the cursor came from.\n           */\n          if (\n            postEdgeNodes &&\n            isNodesAffinity(editor, postEdgeNodes, 'directional') &&\n            !hasElement(postEdgeNodes)\n          ) {\n            setAffinitySelection(\n              editor,\n              postEdgeNodes,\n              reverse ? 'forward' : 'backward'\n            );\n          }\n\n          return true;\n        }\n      };\n\n      if (apply()) return;\n\n      move(options);\n    },\n  },\n}));\n\nconst hasElement = (edgeNodes: EdgeNodes) => {\n  const [before, after] = edgeNodes;\n\n  return (\n    (before && ElementApi.isElement(before[0])) ||\n    (after && ElementApi.isElement(after[0]))\n  );\n};\n","import {\n  type TElement,\n  type TText,\n  ElementApi,\n  NodeApi,\n  PathApi,\n} from '@platejs/slate';\nimport { type NodeEntry, Path } from 'slate';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { EdgeNodes } from '../types';\n\nimport { getPluginByType } from '../../../plugin/getSlatePlugin';\n\n/**\n * When the cursor is at a mark edge, this function returns the inward node and\n * the outward node (if any). If the cursor is at the start of the text, then\n * the node before the text is returned. If the cursor is at the end of the\n * text, then the node after the text is returned. Otherwise, null is returned.\n */\nexport const getEdgeNodes = (editor: SlateEditor): EdgeNodes | null => {\n  if (!editor.api.isCollapsed()) return null;\n\n  const cursor = editor.selection!.anchor;\n\n  const textRange = editor.api.range(cursor.path);\n\n  if (!textRange) return null;\n\n  const edge = editor.api.isStart(cursor, textRange)\n    ? 'start'\n    : editor.api.isEnd(cursor, textRange)\n      ? 'end'\n      : null;\n\n  if (!edge) return null;\n\n  const parent: TElement | null = (NodeApi.parent(editor, cursor.path) ??\n    null) as TElement | null;\n\n  /** Inline elements */\n\n  const isAffinityInlineElement = (() => {\n    if (!parent || !ElementApi.isElement(parent)) return false;\n\n    const parentAffinity = getPluginByType(editor, parent.type)?.rules.selection\n      ?.affinity;\n\n    return parentAffinity === 'hard' || parentAffinity === 'directional';\n  })();\n\n  const nodeEntry: NodeEntry<TElement | TText> = isAffinityInlineElement\n    ? [parent!, PathApi.parent(cursor.path)]\n    : [NodeApi.get(editor, cursor.path)!, cursor.path];\n\n  if (\n    edge === 'start' &&\n    cursor.path.at(-1) === 0 &&\n    !isAffinityInlineElement\n  ) {\n    return [null, nodeEntry];\n  }\n\n  const siblingPath =\n    edge === 'end' ? Path.next(nodeEntry[1]) : Path.previous(nodeEntry[1]);\n  const siblingNode = NodeApi.get<TText>(editor, siblingPath);\n\n  const siblingEntry: NodeEntry<TText> | null = siblingNode\n    ? [siblingNode, siblingPath]\n    : null;\n\n  return edge === 'end' ? [nodeEntry, siblingEntry] : [siblingEntry, nodeEntry];\n};\n","import type { TElement, TText } from '@platejs/slate';\n\nimport { IS_FIREFOX, NodeApi } from '@platejs/slate';\nimport isEqual from 'lodash/isEqual.js';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { EdgeNodes } from '../types';\n\nexport const getMarkBoundaryAffinity = (\n  editor: SlateEditor,\n  markBoundary: EdgeNodes\n): 'backward' | 'forward' | undefined => {\n  const { marks, selection } = editor;\n  if (!selection) return;\n\n  const marksMatchLeaf = (leaf: TElement | TText) => {\n    return (\n      marks &&\n      isEqual(NodeApi.extractProps(leaf), marks) &&\n      Object.keys(marks).length > 1\n    );\n  };\n\n  const [backwardLeafEntry, forwardLeafEntry] = markBoundary;\n\n  if (!backwardLeafEntry || !forwardLeafEntry) {\n    const leafEntry = backwardLeafEntry || forwardLeafEntry;\n    const affinityIsTowardsLeaf = !marks || marksMatchLeaf(leafEntry[0]);\n\n    if (affinityIsTowardsLeaf) {\n      return leafEntry === backwardLeafEntry ? 'backward' : 'forward';\n    }\n    return;\n  }\n\n  const marksDirection: 'backward' | 'forward' | null =\n    marks &&\n    (() => {\n      if (backwardLeafEntry && marksMatchLeaf(backwardLeafEntry[0]))\n        return 'backward';\n      if (forwardLeafEntry && marksMatchLeaf(forwardLeafEntry[0]))\n        return 'forward';\n      return null;\n    })();\n\n  const selectionDirection =\n    selection.anchor.offset === 0 ? 'forward' : 'backward';\n\n  if (selectionDirection === 'backward' && marksDirection === 'forward')\n    return 'forward';\n\n  if (\n    IS_FIREFOX &&\n    selectionDirection === 'forward' &&\n    marksDirection !== 'backward'\n  )\n    return 'forward';\n\n  return 'backward';\n};\n","import { type TElement, type TText, ElementApi, NodeApi } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { EdgeNodes } from '../types';\n\nimport { getPluginByType } from '../../../plugin/getSlatePlugin';\n\nexport const isNodeAffinity = (\n  editor: SlateEditor,\n  node: TElement | TText,\n  affinity: 'directional' | 'hard' | 'outward'\n) => {\n  const marks = Object.keys(NodeApi.extractProps(node));\n  const keys = ElementApi.isElement(node) ? [node.type] : marks;\n  return keys.some(\n    (type) =>\n      getPluginByType(editor, type)?.rules.selection?.affinity === affinity\n  );\n};\n\nexport const isNodesAffinity = (\n  editor: SlateEditor,\n  edgeNodes: EdgeNodes,\n  affinity: 'directional' | 'hard' | 'outward'\n) => {\n  const [backwardLeafEntry, forwardLeafEntry] = edgeNodes;\n\n  return (\n    (backwardLeafEntry &&\n      isNodeAffinity(editor, backwardLeafEntry[0], affinity)) ||\n    (forwardLeafEntry && isNodeAffinity(editor, forwardLeafEntry[0], affinity))\n  );\n};\n","import type { Point } from 'slate';\n\nimport { ElementApi, NodeApi } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { EdgeNodes } from '../types';\n\nexport const setAffinitySelection = (\n  editor: SlateEditor,\n  edgeNodes: EdgeNodes,\n  affinity: 'backward' | 'forward'\n) => {\n  const setMarks = (marks: typeof editor.marks) => {\n    editor.marks = marks;\n    editor.api.onChange();\n  };\n\n  const select = (point: Point) => {\n    editor.tf.setSelection({ anchor: point, focus: point });\n  };\n\n  const [before, after] = edgeNodes;\n\n  if (affinity === 'backward') {\n    if (before === null) {\n      setMarks({});\n      return;\n    }\n\n    const beforeEnd = editor.api.end(before[1]);\n    if (beforeEnd) {\n      select(beforeEnd);\n    }\n\n    if (ElementApi.isElement(before[0])) return;\n    setMarks(null);\n\n    return;\n  }\n\n  if (before === null) {\n    setMarks(null);\n    return;\n  }\n\n  if (after === null) {\n    setMarks({});\n    return;\n  }\n\n  const beforeEnd = editor.api.end(before[1])!;\n  select(beforeEnd);\n\n  if (ElementApi.isElement(after[0])) {\n    return;\n  } else {\n    setMarks(NodeApi.extractProps(after[0]));\n  }\n};\n","import { type Ancestor, NodeApi } from '@platejs/slate';\n\nimport type { PluginConfig } from '../../plugin/BasePlugin';\n\nimport { createTSlatePlugin } from '../../plugin/createSlatePlugin';\nimport { withChunking } from './withChunking';\n\nexport type ChunkingConfig = PluginConfig<\n  'chunking',\n  {\n    /**\n     * The number of blocks per chunk.\n     *\n     * @default 1000\n     */\n    chunkSize?: number;\n    /**\n     * Whether to render each chunk as a DOM element with `content-visibility:\n     * auto`, which optimizes DOM painting. When set to `false`, no DOM element\n     * will be rendered for each chunk.\n     *\n     * @default true\n     */\n    contentVisibilityAuto?: boolean;\n    /**\n     * Determine which ancestors should have chunking applied to their children.\n     * Only blocks containing other blocks can have chunking applied.\n     *\n     * @default NodeApi.isEditor\n     */\n    query?: (ancestor: Ancestor) => boolean;\n  }\n>;\n\nexport const ChunkingPlugin = createTSlatePlugin<ChunkingConfig>({\n  key: 'chunking',\n  options: {\n    chunkSize: 1000,\n    contentVisibilityAuto: true,\n    query: NodeApi.isEditor,\n  },\n}).overrideEditor(withChunking);\n","import type { Ancestor } from '@platejs/slate';\n\nimport type { OverrideEditor } from '../../plugin/SlatePlugin';\nimport type { ChunkingConfig } from './ChunkingPlugin';\n\nexport const withChunking: OverrideEditor<ChunkingConfig> = ({\n  editor,\n  getOptions,\n}) => {\n  const { chunkSize, query } = getOptions();\n  editor.getChunkSize = (ancestor: Ancestor) =>\n    query!(ancestor) ? chunkSize! : null;\n  return {};\n};\n","import type { DebugConfig } from '../getCorePlugins';\n\nimport { createTSlatePlugin } from '../../plugin';\n\nexport type DebugErrorType =\n  | (string & {})\n  | 'DEFAULT'\n  | 'OPTION_UNDEFINED'\n  | 'OVERRIDE_MISSING'\n  | 'PLUGIN_DEPENDENCY_MISSING'\n  | 'PLUGIN_MISSING'\n  | 'USE_CREATE_PLUGIN'\n  | 'USE_ELEMENT_CONTEXT';\n\nexport type LogLevel = 'error' | 'info' | 'log' | 'warn';\n\nexport class PlateError extends Error {\n  constructor(\n    message: string,\n    public type: DebugErrorType = 'DEFAULT'\n  ) {\n    super(`[${type}] ${message}`);\n    this.name = 'PlateError';\n  }\n}\n\nexport const DebugPlugin = createTSlatePlugin<DebugConfig>({\n  key: 'debug',\n  options: {\n    isProduction: process.env.NODE_ENV === 'production',\n    logger: {\n      error: (message, type, details) =>\n        console.error(`${type ? `[${type}] ` : ''}${message}`, details),\n      info: (message, type, details) =>\n        console.info(`${type ? `[${type}] ` : ''}${message}`, details),\n      log: (message, type, details) =>\n        console.log(`${type ? `[${type}] ` : ''}${message}`, details),\n      warn: (message, type, details) =>\n        console.warn(`${type ? `[${type}] ` : ''}${message}`, details),\n    },\n    logLevel:\n      process.env.NODE_ENV === 'production' ? 'error' : ('log' as LogLevel),\n    throwErrors: true,\n  },\n}).extendEditorApi<DebugConfig['api']>(({ getOptions }) => {\n  const logLevels: LogLevel[] = ['error', 'warn', 'info', 'log'];\n\n  const log = (\n    level: LogLevel,\n    message: any,\n    type?: DebugErrorType,\n    details?: any\n  ) => {\n    if (process.env.NODE_ENV === 'production') return;\n\n    const options = getOptions();\n\n    if (options.isProduction && level === 'log') return;\n    if (logLevels.indexOf(level) <= logLevels.indexOf(options.logLevel!)) {\n      if (level === 'error' && options.throwErrors) {\n        throw new PlateError(message, type);\n      } else {\n        options.logger[level]?.(message, type, details);\n      }\n    }\n  };\n\n  return {\n    debug: {\n      error: (message, type, details) => log('error', message, type, details),\n      info: (message, type, details) => log('info', message, type, details),\n      log: (message, type, details) => log('log', message, type, details),\n      warn: (message, type, details) => log('warn', message, type, details),\n    },\n  };\n});\n","import type { Operation, ScrollIntoViewOptions, TRange } from '@platejs/slate';\n\nimport { bindFirst } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../';\n\nimport { type PluginConfig, createTSlatePlugin } from '../../plugin';\nimport { withScrolling } from './withScrolling';\n\nexport const AUTO_SCROLL = new WeakMap<SlateEditor, boolean>();\n\nexport type AutoScrollOperationsMap = Partial<\n  Record<Operation['type'], boolean>\n>;\n\nexport type DomConfig = PluginConfig<\n  'dom',\n  {\n    /** Choose the first or last matching operation as the scroll target */\n    scrollMode?: ScrollMode;\n    /**\n     * Operations map; false to disable an operation, true or undefined to\n     * enable\n     */\n    scrollOperations?: AutoScrollOperationsMap;\n    /** Options passed to scrollIntoView */\n    scrollOptions?: ScrollIntoViewOptions;\n  }\n>;\n\n/** Mode for picking target op when multiple enabled */\nexport type ScrollMode = 'first' | 'last';\n\n/**\n * Placeholder plugin for DOM interaction, that could be replaced with\n * ReactPlugin.\n */\nexport const DOMPlugin = createTSlatePlugin<DomConfig>({\n  key: 'dom',\n  options: {\n    scrollMode: 'last',\n    scrollOperations: {\n      insert_node: true,\n      insert_text: true,\n    },\n    scrollOptions: {\n      scrollMode: 'if-needed',\n    },\n  },\n})\n  .extendEditorApi(({ editor }) => ({\n    isScrolling: () => {\n      return AUTO_SCROLL.get(editor) ?? false;\n    },\n  }))\n  .extendEditorTransforms(({ editor }) => ({\n    withScrolling: bindFirst(withScrolling, editor),\n  }))\n  .overrideEditor(({ api, editor, getOption, tf: { apply } }) => ({\n    transforms: {\n      apply(operation) {\n        if (api.isScrolling()) {\n          apply(operation);\n\n          // Check if this op type is enabled (default true)\n          const scrollOperations = getOption('scrollOperations')!;\n\n          if (!scrollOperations[operation.type]) return;\n\n          // Gather enabled ops in this batch\n          const matched = editor.operations.filter(\n            (op) => !!scrollOperations[op.type]\n          );\n\n          if (matched.length === 0) return;\n\n          const mode = getOption('scrollMode')!;\n\n          // Pick target\n          const targetOp = mode === 'first' ? matched[0] : matched.at(-1);\n\n          if (!targetOp) return;\n\n          const { offset, path } = (targetOp as any).path\n            ? (targetOp as any as { path: number[]; offset?: number })\n            : {};\n\n          if (!path) return;\n\n          const scrollOptions = getOption('scrollOptions')!;\n\n          const scrollTarget = {\n            offset: offset ?? 0,\n            path,\n          };\n\n          api.scrollIntoView(scrollTarget, scrollOptions);\n\n          return;\n        }\n\n        return apply(operation);\n      },\n    },\n  }))\n  .overrideEditor(({ editor, tf: { apply } }) => ({\n    transforms: {\n      apply(operation) {\n        if (operation.type === 'set_selection') {\n          const { properties } = operation;\n          editor.dom.prevSelection = properties as TRange | null;\n          apply(operation);\n          editor.dom.currentKeyboardEvent = null;\n          return;\n        }\n\n        apply(operation);\n      },\n    },\n  }));\n","import type { ScrollIntoViewOptions } from '@platejs/slate';\n\nimport isUndefined from 'lodash/isUndefined.js';\nimport omitBy from 'lodash/omitBy.js';\n\nimport type { SlateEditor } from '../../editor';\nimport type { AutoScrollOperationsMap, ScrollMode } from './DOMPlugin';\n\nimport { AUTO_SCROLL, DOMPlugin } from './DOMPlugin';\n\nexport interface WithAutoScrollOptions {\n  mode?: ScrollMode;\n  operations?: AutoScrollOperationsMap;\n  scrollOptions?: ScrollIntoViewOptions;\n}\n\nexport const withScrolling = (\n  editor: SlateEditor,\n  fn: () => void,\n  options?: WithAutoScrollOptions\n) => {\n  const prevOptions = editor.getOptions(DOMPlugin);\n  const prevAutoScroll = AUTO_SCROLL.get(editor) ?? false;\n\n  if (options) {\n    const ops = {\n      ...prevOptions,\n      ...omitBy(options, isUndefined),\n    };\n\n    editor.setOptions(DOMPlugin, ops);\n  }\n  AUTO_SCROLL.set(editor, true);\n  fn();\n  // reset\n  AUTO_SCROLL.set(editor, prevAutoScroll);\n  editor.setOptions(DOMPlugin, prevOptions);\n};\n","import { bindFirst } from '@udecode/utils';\n\nimport { createSlatePlugin } from '../../plugin';\nimport { deserializeHtml, parseHtmlDocument } from './utils';\n\n/**\n * Enables support for deserializing inserted content from HTML format to Slate\n * format and serializing Slate content to HTML format.\n */\nexport const HtmlPlugin = createSlatePlugin({\n  key: 'html',\n})\n  .extendApi(({ editor }) => ({\n    deserialize: bindFirst(deserializeHtml, editor),\n  }))\n  .extend({\n    parser: {\n      format: 'text/html',\n      deserialize: ({ api, data }) => {\n        const document = parseHtmlDocument(data);\n\n        return api.html.deserialize({\n          element: document.body,\n        });\n      },\n    },\n  });\n","export const CARRIAGE_RETURN = '\\u000D';\n\nexport const LINE_FEED = '\\u000A';\n\nexport const NO_BREAK_SPACE = '\\u00A0';\n\nexport const SPACE = '\\u0020';\n\nexport const TAB = '\\u0009';\n\nexport const ZERO_WIDTH_SPACE = '\\u200B';\n","export const isHtmlElement = (node: Node): node is Element =>\n  node.nodeType === Node.ELEMENT_NODE;\n","type Callback = (node: Node) => boolean;\n\n/**\n * Depth-first pre-order tree traverse the given HTML node and calls the given\n * callback for each node. see:\n * https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)\n *\n * @param callback Returns a boolean indicating whether traversal should be\n *   continued\n */\nexport const traverseHtmlNode = (node: Node, callback: Callback): void => {\n  const keepTraversing = callback(node);\n\n  if (!keepTraversing) {\n    return;\n  }\n\n  let child = node.firstChild;\n\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n\n    traverseHtmlNode(currentChild, callback);\n\n    if (\n      // An unwrap was made. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      previousChild !== child.previousSibling &&\n      child.parentNode\n    ) {\n      child = previousChild ? previousChild.nextSibling : node.firstChild;\n    } else if (\n      // A list was created. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      !child.previousSibling &&\n      !child.nextSibling &&\n      !child.parentNode\n    ) {\n      if (previousChild) {\n        child = previousChild.nextSibling\n          ? previousChild.nextSibling.nextSibling\n          : null;\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\n","import { isHtmlElement } from './isHtmlElement';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Element) => boolean;\n\n/**\n * Traverse the HTML elements of the given HTML node.\n *\n * @param rootNode The root HTML node to traverse.\n * @param callback The callback to call for each HTML element.\n */\nexport const traverseHtmlElements = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { LINE_FEED } from '../constants';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/** Replace BR elements with line feeds. */\nexport const cleanHtmlBrElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n\n    const replacementTextNode = document.createTextNode(LINE_FEED);\n\n    if (element.parentElement) {\n      element.parentElement.replaceChild(replacementTextNode, element);\n    }\n\n    return false;\n  });\n};\n","/** Replace \\r\\n and \\r with \\n */\nexport const cleanHtmlCrLf = (html: string): string => {\n  return html.replaceAll(/\\r\\n|\\r/g, '\\n');\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\nconst ALLOWED_EMPTY_ELEMENTS = new Set(['BR', 'IMG', 'TD', 'TH']);\n\nconst isEmpty = (element: Element): boolean => {\n  return (\n    !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim()\n  );\n};\n\nconst removeIfEmpty = (element: Element): void => {\n  if (isEmpty(element)) {\n    const { parentElement } = element;\n\n    element.remove();\n\n    if (parentElement) {\n      removeIfEmpty(parentElement);\n    }\n  }\n};\n\n/** Remove empty elements from rootNode. Allowed empty elements: BR, IMG. */\nexport const cleanHtmlEmptyElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    removeIfEmpty(element);\n\n    return true;\n  });\n};\n","/**\n * Replace `element` tag name by `tagName`. Attributes, innerHTML and parent\n * relationship is kept.\n */\nexport const replaceTagName = (element: Element, tagName: string): Element => {\n  const newElement = document.createElement(tagName);\n\n  newElement.innerHTML = element.innerHTML;\n\n  for (const { name } of element.attributes) {\n    const value = element.getAttribute(name);\n\n    if (value) {\n      newElement.setAttribute(name, value);\n    }\n  }\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(newElement, element);\n  }\n\n  return newElement;\n};\n","import { replaceTagName } from './replaceTagName';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Replace FONT elements with SPAN elements if there is textContent (remove\n * otherwise).\n */\nexport const cleanHtmlFontElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName === 'FONT') {\n      if (element.textContent) {\n        replaceTagName(element, 'span');\n      } else {\n        element.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","/** If href starts with '#'. */\nexport const isHtmlFragmentHref = (href: string): boolean =>\n  href.startsWith('#');\n","/** Unwrap the given HTML element. */\nexport const unwrapHtmlElement = (element: Element): void => {\n  element.outerHTML = element.innerHTML;\n};\n","import { isHtmlFragmentHref } from './isHtmlFragmentHref';\nimport { traverseHtmlElements } from './traverseHtmlElements';\nimport { unwrapHtmlElement } from './unwrapHtmlElement';\n\n/** Remove fragment hrefs and spans without inner text. */\nexport const cleanHtmlLinkElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'A') {\n      return true;\n    }\n\n    const href = element.getAttribute('href');\n\n    if (!href || isHtmlFragmentHref(href)) {\n      unwrapHtmlElement(element);\n    }\n    if (href && element.querySelector('img')) {\n      for (const span of element.querySelectorAll('span')) {\n        if (!span.textContent) {\n          unwrapHtmlElement(span);\n        }\n      }\n    }\n\n    return true;\n  });\n};\n","export const isHtmlText = (node: Node): node is Text =>\n  node.nodeType === Node.TEXT_NODE;\n","import { isHtmlText } from './isHtmlText';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Text) => boolean;\n\nexport const traverseHtmlTexts = (rootNode: Node, callback: Callback): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlText(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import {\n  CARRIAGE_RETURN,\n  LINE_FEED,\n  NO_BREAK_SPACE,\n  SPACE,\n} from '../constants';\nimport { traverseHtmlTexts } from './traverseHtmlTexts';\n\nexport const cleanHtmlTextNodes = (rootNode: Node): void => {\n  traverseHtmlTexts(rootNode, (textNode) => {\n    if (\n      /^\\n\\s*$/.test(textNode.data) &&\n      (textNode.previousElementSibling || textNode.nextElementSibling)\n    ) {\n      textNode.remove();\n\n      return true;\n    }\n\n    textNode.data = textNode.data.replaceAll(/\\n\\s*/g, '\\n');\n\n    if (\n      textNode.data.includes(CARRIAGE_RETURN) ||\n      textNode.data.includes(LINE_FEED) ||\n      textNode.data.includes(NO_BREAK_SPACE)\n    ) {\n      const hasSpace = textNode.data.includes(SPACE);\n      const hasNonWhitespace = /\\S/.test(textNode.data);\n      const hasLineFeed = textNode.data.includes(LINE_FEED);\n\n      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {\n        if (textNode.data === NO_BREAK_SPACE) {\n          textNode.data = SPACE;\n\n          return true;\n        }\n\n        textNode.remove();\n\n        return true;\n      }\n      if (\n        textNode.previousSibling &&\n        textNode.previousSibling.nodeName === 'BR' &&\n        textNode.parentElement\n      ) {\n        textNode.previousSibling.remove();\n\n        const matches = /^[\\n\\r]+/.exec(textNode.data);\n        const offset = matches ? matches[0].length : 0;\n\n        textNode.data = textNode.data\n          .slice(Math.max(0, offset))\n          .replaceAll(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replaceAll(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n        textNode.data = `\\n${textNode.data}`;\n      } else {\n        textNode.data = textNode.data\n          .replaceAll(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replaceAll(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n      }\n    }\n\n    return true;\n  });\n};\n","/**\n * # Methodology\n *\n * ## Step 1. Get the list of all standard tag names\n *\n * Go to https://developer.mozilla.org/en-US/docs/Web/HTML/Element and run the\n * following in the console to generate a JSON array of tag names:\n *\n * ```js\n * JSON.stringify(\n *   Array.from(document.querySelectorAll('article table td:first-child'))\n *     .map((td) => {\n *       const body = document.createElement('body');\n *       body.innerHTML = td.textContent;\n *       return body.firstChild?.tagName;\n *     })\n *     .filter((tagName) => tagName)\n * );\n * ```\n *\n * Output (as of 2023-11-06):\n *\n * ```json\n * '[\"BASE\",\"LINK\",\"META\",\"STYLE\",\"TITLE\",\"ADDRESS\",\"ARTICLE\",\"ASIDE\",\"FOOTER\",\"HEADER\",\"H1\",\"HGROUP\",\"MAIN\",\"NAV\",\"SECTION\",\"SEARCH\",\"BLOCKQUOTE\",\"DD\",\"DIV\",\"DL\",\"DT\",\"FIGCAPTION\",\"FIGURE\",\"HR\",\"LI\",\"MENU\",\"OL\",\"P\",\"PRE\",\"UL\",\"A\",\"ABBR\",\"B\",\"BDI\",\"BDO\",\"BR\",\"CITE\",\"CODE\",\"DATA\",\"DFN\",\"EM\",\"I\",\"KBD\",\"MARK\",\"Q\",\"RP\",\"RT\",\"RUBY\",\"S\",\"SAMP\",\"SMALL\",\"SPAN\",\"STRONG\",\"SUB\",\"SUP\",\"TIME\",\"U\",\"VAR\",\"WBR\",\"AREA\",\"AUDIO\",\"IMG\",\"MAP\",\"TRACK\",\"VIDEO\",\"EMBED\",\"IFRAME\",\"OBJECT\",\"PICTURE\",\"PORTAL\",\"SOURCE\",\"svg\",\"math\",\"CANVAS\",\"NOSCRIPT\",\"SCRIPT\",\"DEL\",\"INS\",\"TABLE\",\"BUTTON\",\"DATALIST\",\"FIELDSET\",\"FORM\",\"INPUT\",\"LABEL\",\"LEGEND\",\"METER\",\"OPTGROUP\",\"OPTION\",\"OUTPUT\",\"PROGRESS\",\"SELECT\",\"TEXTAREA\",\"DETAILS\",\"DIALOG\",\"SUMMARY\",\"SLOT\",\"TEMPLATE\",\"ACRONYM\",\"BIG\",\"CENTER\",\"CONTENT\",\"DIR\",\"FONT\",\"IMG\",\"MARQUEE\",\"MENUITEM\",\"NOBR\",\"NOEMBED\",\"NOFRAMES\",\"PARAM\",\"PLAINTEXT\",\"RB\",\"RTC\",\"SHADOW\",\"STRIKE\",\"TT\",\"XMP\"]'\n * ```\n *\n * ## Step 2. For each tag name, determine the default browser style\n *\n * Open an empty HTML file in the browser and run the following in the console:\n *\n * ```js\n * const tagNames = JSON.parse(<JSON string from step 1>);\n *\n * JSON.stringify(\n *   tagNames.filter((tagName) => {\n *     const element = document.createElement(tagName);\n *     document.body.appendChild(element);\n *     const display = window.getComputedStyle(element).display;\n *     element.remove();\n *     return display.startsWith('inline');\n *   })\n * );\n * ```\n *\n * Place the result in the array below (accurate as of 2023-11-06).\n */\n\nexport const inlineTagNames = new Set([\n  'A',\n  'ABBR',\n  'ACRONYM',\n  'B',\n  'BDI',\n  'BDO',\n  'BIG',\n  'BR',\n  'BUTTON',\n  'CANVAS',\n  'CITE',\n  'CODE',\n  'CONTENT',\n  'DATA',\n  'DEL',\n  'DFN',\n  'EM',\n  'EMBED',\n  'FONT',\n  'I',\n  'IFRAME',\n  'IMG',\n  'IMG',\n  'INPUT',\n  'INS',\n  'KBD',\n  'LABEL',\n  'MAP',\n  'MARK',\n  'MARQUEE',\n  'math',\n  'MENUITEM',\n  'METER',\n  'NOBR',\n  'OBJECT',\n  'OUTPUT',\n  'PICTURE',\n  'PORTAL',\n  'PROGRESS',\n  'Q',\n  'S',\n  'SAMP',\n  'SELECT',\n  'SHADOW',\n  'SMALL',\n  'SOURCE',\n  'SPAN',\n  'STRIKE',\n  'STRONG',\n  'SUB',\n  'SUP',\n  'svg',\n  'TEXTAREA',\n  'TIME',\n  'TRACK',\n  'TT',\n  'U',\n  'VAR',\n  'VIDEO',\n  'WBR',\n]);\n","import { inlineTagNames } from './inlineTagNames';\nimport { isHtmlElement } from './isHtmlElement';\n\nexport const isHtmlInlineElement = (node: Node): boolean => {\n  if (!isHtmlElement(node)) return false;\n\n  const element = node as HTMLElement;\n\n  const tagNameIsInline = inlineTagNames.has(element.tagName);\n\n  /**\n   * Valid display values include 'inline flow'. We only care about the first\n   * part.\n   */\n  const displayProperty = element.style.display.split(' ')[0];\n\n  if (displayProperty === '') {\n    return tagNameIsInline;\n  }\n  if (displayProperty.startsWith('inline')) {\n    return true;\n  }\n  if (displayProperty === 'inherit' && element.parentElement) {\n    return isHtmlInlineElement(element.parentElement);\n  }\n  /**\n   * Handle all special values manually, so that any unhandled values can be\n   * assumed to be block.\n   *\n   * Note: Ideally, content inside `display: none` elements should not be\n   * parsed. However, if such elements are parsed, it's best for their inline or\n   * block status to be left unchanged.\n   */\n  if (\n    ['contents', 'initial', 'none', 'revert', 'revert-layer', 'unset'].includes(\n      displayProperty\n    )\n  ) {\n    return tagNameIsInline;\n  }\n\n  return false;\n};\n","import { isHtmlElement } from './isHtmlElement';\nimport { isHtmlInlineElement } from './isHtmlInlineElement';\n\nexport const isHtmlBlockElement = (node: Node): boolean => {\n  if (!isHtmlElement(node)) return false;\n\n  const element = node as HTMLElement;\n\n  return !isHtmlInlineElement(element);\n};\n","export const isHtmlTable = (element: Element) => element.nodeName === 'TABLE';\n","import { isHtmlBlockElement } from './isHtmlBlockElement';\nimport { isHtmlTable } from './isHtmlTable';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Set HTML blocks mark styles to a new child span element if any. This allows\n * Plate to use block marks.\n */\nexport const copyBlockMarksToSpanChild = (rootNode: Node) => {\n  traverseHtmlElements(rootNode, (element) => {\n    const el = element as HTMLElement;\n\n    const styleAttribute = element.getAttribute('style');\n\n    if (!styleAttribute) return true;\n    if (isHtmlBlockElement(el) && !isHtmlTable(el)) {\n      const {\n        style: {\n          backgroundColor,\n          color,\n          fontFamily,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          textDecoration,\n        },\n      } = el;\n\n      if (\n        backgroundColor ||\n        color ||\n        fontFamily ||\n        fontSize ||\n        fontStyle ||\n        fontWeight ||\n        textDecoration\n      ) {\n        const span = document.createElement('span');\n\n        if (!['inherit', 'initial'].includes(color)) {\n          span.style.color = color;\n        }\n\n        span.style.fontFamily = fontFamily;\n        span.style.fontSize = fontSize;\n\n        if (!['inherit', 'initial', 'normal'].includes(color)) {\n          span.style.fontStyle = fontStyle;\n        }\n        if (![400, 'normal'].includes(fontWeight)) {\n          span.style.fontWeight = fontWeight;\n        }\n\n        span.style.textDecoration = textDecoration;\n\n        span.innerHTML = el.innerHTML;\n        element.innerHTML = span.outerHTML;\n      }\n    }\n\n    return true;\n  });\n};\n","import {\n  type Descendant,\n  type Editor,\n  ElementApi,\n  TextApi,\n} from '@platejs/slate';\n\nimport type { SlateEditor } from '../editor';\nimport type { WithRequiredKey } from '../plugin';\n\nimport { BaseParagraphPlugin } from '../plugins';\n\nconst isInlineNode = (editor: Editor) => (node: Descendant) =>\n  TextApi.isText(node) ||\n  (ElementApi.isElement(node) && editor.api.isInline(node));\n\nconst makeBlockLazy = (type: string) => (): Descendant => ({\n  children: [],\n  type,\n});\n\nconst hasDifferentChildNodes = (\n  descendants: Descendant[],\n  isInline: (node: Descendant) => boolean\n): boolean => {\n  return descendants.some((descendant, index, arr) => {\n    const prevDescendant = arr[index - 1];\n\n    if (index !== 0) {\n      return isInline(descendant) !== isInline(prevDescendant);\n    }\n\n    return false;\n  });\n};\n\n/**\n * Handles 3rd constraint: \"Block nodes can only contain other blocks, or inline\n * and text nodes.\"\n */\nconst normalizeDifferentNodeTypes = (\n  descendants: Descendant[],\n  isInline: (node: Descendant) => boolean,\n  makeDefaultBlock: () => Descendant\n): Descendant[] => {\n  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);\n\n  const { fragment } = descendants.reduce(\n    (memo, node) => {\n      if (hasDifferentNodes && isInline(node)) {\n        let block = memo.precedingBlock;\n\n        if (!block) {\n          block = makeDefaultBlock();\n          memo.precedingBlock = block;\n          memo.fragment.push(block);\n        }\n\n        (block.children as Descendant[]).push(node);\n      } else {\n        memo.fragment.push(node);\n        memo.precedingBlock = null;\n      }\n\n      return memo;\n    },\n    {\n      fragment: [] as Descendant[],\n      precedingBlock: null as Descendant | null,\n    }\n  );\n\n  return fragment;\n};\n\n/**\n * Handles 1st constraint: \"All Element nodes must contain at least one Text\n * descendant.\"\n */\nconst normalizeEmptyChildren = (descendants: Descendant[]): Descendant[] => {\n  if (descendants.length === 0) {\n    return [{ text: '' } as Descendant];\n  }\n\n  return descendants;\n};\n\nconst normalize = (\n  descendants: Descendant[],\n  isInline: (node: Descendant) => boolean,\n  makeDefaultBlock: () => Descendant\n): Descendant[] => {\n  descendants = normalizeEmptyChildren(descendants);\n  descendants = normalizeDifferentNodeTypes(\n    descendants,\n    isInline,\n    makeDefaultBlock\n  );\n\n  descendants = descendants.map((node) => {\n    if (ElementApi.isElement(node)) {\n      return {\n        ...node,\n        children: normalize(\n          node.children as Descendant[],\n          isInline,\n          makeDefaultBlock\n        ),\n      };\n    }\n\n    return node;\n  });\n\n  return descendants;\n};\n\n/** Normalize the descendants to a valid document fragment. */\nexport const normalizeDescendantsToDocumentFragment = (\n  editor: SlateEditor,\n  {\n    defaultElementPlugin = BaseParagraphPlugin,\n    descendants,\n  }: { descendants: Descendant[]; defaultElementPlugin?: WithRequiredKey }\n): Descendant[] => {\n  const isInline = isInlineNode(editor);\n  const defaultType = editor.getType(defaultElementPlugin.key);\n  const makeDefaultBlock = makeBlockLazy(defaultType);\n\n  return normalize(descendants, isInline, makeDefaultBlock as any);\n};\n","import type { TrimEndRule, TrimStartRule } from './types';\n\nexport const collapseString = (\n  text: string,\n  {\n    shouldCollapseWhiteSpace = true,\n    trimEnd = 'collapse',\n    trimStart = 'collapse',\n    whiteSpaceIncludesNewlines = true,\n  }: {\n    shouldCollapseWhiteSpace?: boolean;\n    trimEnd?: TrimEndRule;\n    trimStart?: TrimStartRule;\n    whiteSpaceIncludesNewlines?: boolean;\n  } = {}\n) => {\n  if (trimStart === 'all') {\n    text = text.replace(/^\\s+/, '');\n  }\n  if (trimEnd === 'single-newline') {\n    // Strip at most one newline from the end\n    text = text.replace(/\\n$/, '');\n  }\n  if (shouldCollapseWhiteSpace) {\n    if (whiteSpaceIncludesNewlines) {\n      text = text.replaceAll(/\\s+/g, ' ');\n    } else {\n      // Collapse horizontal whitespace\n      text = text.replaceAll(/[^\\S\\n\\r]+/g, ' ');\n\n      /**\n       * Trim horizontal whitespace from the start and end of lines (behavior of\n       * pre-line).\n       */\n      text = text.replaceAll(/^[^\\S\\n\\r]+/gm, '');\n      text = text.replaceAll(/[^\\S\\n\\r]+$/gm, '');\n    }\n  }\n\n  return text;\n};\n","import { isHtmlBlockElement } from '../isHtmlBlockElement';\n\nexport const isLastNonEmptyTextOfInlineFormattingContext = (\n  initialText: Text\n): boolean => {\n  let currentNode: Node | null = initialText;\n\n  while (true) {\n    if (currentNode.nextSibling) {\n      currentNode = currentNode.nextSibling;\n    } else {\n      // If there is no next sibling, ascend to the parent node\n      currentNode = currentNode.parentElement;\n\n      // If the parent node is a block, we've reached the end\n      if (currentNode && isHtmlBlockElement(currentNode)) {\n        return true;\n      }\n\n      // Otherwise, continue to the next sibling of the parent node\n      currentNode = currentNode?.nextSibling || null;\n    }\n    // If there's no next node, we've reached the end\n    if (!currentNode) {\n      return true;\n    }\n    // If the next node is a block, we've reached the end\n    if (isHtmlBlockElement(currentNode)) {\n      return true;\n    }\n    // If the next node is a non-empty text node, we're not at the end\n    if ((currentNode.textContent || '').length > 0) {\n      return false;\n    }\n\n    // Otherwise, continue to the next node\n  }\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nexport const upsertInlineFormattingContext = (\n  state: CollapseWhiteSpaceState\n) => {\n  if (state.inlineFormattingContext) {\n    state.inlineFormattingContext.atStart = false;\n  } else {\n    state.inlineFormattingContext = {\n      atStart: true,\n      lastHasTrailingWhiteSpace: false,\n    };\n  }\n};\n\nexport const endInlineFormattingContext = (state: CollapseWhiteSpaceState) => {\n  state.inlineFormattingContext = null;\n};\n","import type {\n  CollapseWhiteSpaceState,\n  TrimEndRule,\n  TrimStartRule,\n} from './types';\n\nimport { collapseString } from './collapseString';\nimport { isLastNonEmptyTextOfInlineFormattingContext } from './isLastNonEmptyTextOfInlineFormattingContext';\nimport { upsertInlineFormattingContext } from './stateTransforms';\n\nexport const collapseWhiteSpaceText = (\n  text: Text,\n  state: CollapseWhiteSpaceState\n) => {\n  const textContent = text.textContent || '';\n  const isWhiteSpaceOnly = textContent.trim() === '';\n\n  /**\n   * Do not start an inline formatting context with a text node containing only\n   * white space.\n   */\n  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {\n    upsertInlineFormattingContext(state);\n  }\n\n  const { whiteSpaceRule } = state;\n\n  /**\n   * Note: Due to the way HTML strings are parsed in htmlStringToDOMNode, up to\n   * one newline is already trimmed from the start of text nodes inside <pre>\n   * elements. If we do so again here, we may remove too many newlines. This\n   * only applies to actual <pre> elements, not elements with the white-space\n   * CSS property.\n   */\n  const trimStart: TrimStartRule = (() => {\n    if (whiteSpaceRule !== 'normal') return 'collapse';\n    if (\n      !state.inlineFormattingContext ||\n      state.inlineFormattingContext.atStart ||\n      state.inlineFormattingContext.lastHasTrailingWhiteSpace\n    )\n      return 'all';\n\n    return 'collapse';\n  })();\n\n  const trimEnd: TrimEndRule = (() => {\n    if (whiteSpaceRule === 'normal') return 'collapse';\n    if (isLastNonEmptyTextOfInlineFormattingContext(text))\n      return 'single-newline';\n\n    return 'collapse';\n  })();\n\n  const shouldCollapseWhiteSpace: boolean = {\n    normal: true,\n    pre: false,\n    'pre-line': true,\n  }[whiteSpaceRule];\n\n  const whiteSpaceIncludesNewlines = whiteSpaceRule !== 'pre-line';\n\n  const collapsedTextContent = collapseString(textContent || '', {\n    shouldCollapseWhiteSpace,\n    trimEnd,\n    trimStart,\n    whiteSpaceIncludesNewlines,\n  });\n\n  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {\n    state.inlineFormattingContext.lastHasTrailingWhiteSpace =\n      collapsedTextContent.endsWith(' ');\n  }\n\n  text.textContent = collapsedTextContent;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { isHtmlElement } from '../isHtmlElement';\nimport { isHtmlText } from '../isHtmlText';\nimport { collapseWhiteSpaceChildren } from './collapseWhiteSpaceChildren';\nimport { collapseWhiteSpaceElement } from './collapseWhiteSpaceElement';\nimport { collapseWhiteSpaceText } from './collapseWhiteSpaceText';\n\nexport const collapseWhiteSpaceNode = (\n  node: Node,\n  state: CollapseWhiteSpaceState\n) => {\n  if (isHtmlElement(node)) {\n    collapseWhiteSpaceElement(node as HTMLElement, state);\n\n    return;\n  }\n  if (isHtmlText(node)) {\n    collapseWhiteSpaceText(node as Text, state);\n\n    return;\n  }\n\n  collapseWhiteSpaceChildren(node, state);\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { collapseWhiteSpaceNode } from './collapseWhiteSpaceNode';\n\nexport const collapseWhiteSpaceChildren = (\n  node: Node,\n  state: CollapseWhiteSpaceState\n) => {\n  const childNodes = Array.from(node.childNodes);\n\n  for (const childNode of childNodes) {\n    collapseWhiteSpaceNode(childNode, state);\n  }\n};\n","import type { WhiteSpaceRule } from './types';\n\nexport const inferWhiteSpaceRule = (\n  element: HTMLElement\n): WhiteSpaceRule | null => {\n  const whiteSpaceProperty = element.style.whiteSpace;\n\n  switch (whiteSpaceProperty) {\n    case 'break-spaces':\n    case 'pre':\n    case 'pre-wrap': {\n      return 'pre';\n    }\n    case 'normal':\n    case 'nowrap': {\n      return 'normal';\n    }\n    case 'pre-line': {\n      return 'pre-line';\n    }\n  }\n\n  if (element.tagName === 'PRE') {\n    return 'pre';\n  }\n  if (whiteSpaceProperty === 'initial') {\n    return 'normal';\n  }\n\n  return null;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { isHtmlInlineElement } from '../isHtmlInlineElement';\nimport { collapseWhiteSpaceChildren } from './collapseWhiteSpaceChildren';\nimport { inferWhiteSpaceRule } from './inferWhiteSpaceRule';\nimport { endInlineFormattingContext } from './stateTransforms';\n\n/**\n * Note: We do not want to start an inline formatting context until we encounter\n * a text node.\n */\nexport const collapseWhiteSpaceElement = (\n  element: HTMLElement,\n  state: CollapseWhiteSpaceState\n) => {\n  const isInlineElement = isHtmlInlineElement(element);\n  const previousWhiteSpaceRule = state.whiteSpaceRule;\n  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);\n\n  if (inferredWhiteSpaceRule) {\n    state.whiteSpaceRule = inferredWhiteSpaceRule;\n  }\n  // End any existing inline formatting context\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n\n  collapseWhiteSpaceChildren(element, state);\n\n  // Do not let inline formatting context break out of block elements\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n\n  // Restore previous whiteSpaceRule\n  state.whiteSpaceRule = previousWhiteSpaceRule;\n};\n","import type { CollapseWhiteSpaceState } from './types';\n\nimport { collapseWhiteSpaceElement } from './collapseWhiteSpaceElement';\n\n// Entrypoint\nexport const collapseWhiteSpace = (element: HTMLElement) => {\n  const clonedElement = element.cloneNode(true) as HTMLElement;\n\n  // Mutable state object\n  const state: CollapseWhiteSpaceState = {\n    inlineFormattingContext: null,\n    whiteSpaceRule: 'normal',\n  };\n\n  collapseWhiteSpaceElement(clonedElement, state);\n\n  return clonedElement;\n};\n","import type { Descendant } from '@platejs/slate';\n\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\n\njsx;\n\n/** Deserialize HTML body element to Fragment. */\nexport const htmlBodyToFragment = (\n  editor: SlateEditor,\n  element: HTMLElement\n): Descendant[] | undefined => {\n  if (element.nodeName === 'BODY') {\n    return jsx(\n      'fragment',\n      {},\n      deserializeHtmlNodeChildren(editor, element)\n    ) as Descendant[];\n  }\n};\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlChildren } from '../types';\n\nimport { isSlateNode } from '../../../static';\nimport { deserializeHtmlNode } from './deserializeHtmlNode';\n\nexport const deserializeHtmlNodeChildren = (\n  editor: SlateEditor,\n  node: ChildNode | HTMLElement,\n  isSlateParent = false\n): DeserializeHtmlChildren[] => {\n  return Array.from(node.childNodes).flatMap((child) => {\n    if (\n      child.nodeType === 1 &&\n      !isSlateNode(child as HTMLElement) &&\n      isSlateParent\n    ) {\n      return deserializeHtmlNodeChildren(\n        editor,\n        child as HTMLElement,\n        isSlateParent\n      );\n    }\n\n    return deserializeHtmlNode(editor)(child);\n  }) as DeserializeHtmlChildren[];\n};\n","/** Deserialize HTML to break line. */\nexport const htmlBrToNewLine = (node: ChildNode | HTMLElement) => {\n  if (node.nodeName === 'BR') {\n    return '\\n';\n  }\n};\n","import type { Descendant } from '@platejs/slate';\n\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { isSlateVoid } from '../../../static';\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\nimport { pipeDeserializeHtmlElement } from './pipeDeserializeHtmlElement';\n\n/** Deserialize HTML to Element. */\nexport const htmlElementToElement = (\n  editor: SlateEditor,\n  element: HTMLElement,\n  isSlate = false\n) => {\n  const deserialized = pipeDeserializeHtmlElement(editor, element);\n\n  if (deserialized) {\n    const { node, withoutChildren } = deserialized;\n\n    let descendants =\n      node.children ??\n      (deserializeHtmlNodeChildren(editor, element, isSlate) as Descendant[]);\n\n    if (descendants.length === 0 || withoutChildren || isSlateVoid(element)) {\n      descendants = [{ text: '' }];\n    }\n\n    return jsx('element', node, descendants) as Descendant;\n  }\n};\n","import { type AnyObject, type Nullable, isDefined } from '@udecode/utils';\nimport castArray from 'lodash/castArray.js';\n\nimport type { SlateEditor } from '../../../editor';\nimport type {\n  AnyEditorPlugin,\n  HtmlDeserializer,\n} from '../../../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../../../plugin';\nimport { isSlateNode } from '../../../static';\nimport { getInjectedPlugins } from '../../../utils/getInjectedPlugins';\nimport { getDataNodeProps } from './getDataNodeProps';\n\n/**\n * Get a deserializer and add default rules for deserializing plate static\n * elements\n */\nconst getDeserializedWithStaticRules = (plugin: AnyEditorPlugin) => {\n  let deserializer = plugin.parsers?.html?.deserializer;\n\n  const rules = deserializer?.rules ?? [];\n\n  // Check if rules already contain slate-xxx className\n  const hasSlateRule = rules.some((rule) =>\n    rule.validClassName?.includes(`slate-${plugin.key}`)\n  );\n\n  const staticRules = hasSlateRule\n    ? rules\n    : [\n        {\n          validClassName: `slate-${plugin.key}`,\n          validNodeName: '*',\n        },\n        ...rules,\n      ];\n\n  if (!deserializer) deserializer = { rules: staticRules };\n\n  deserializer.rules = staticRules;\n\n  return deserializer;\n};\n\n/** Get a deserializer by type, node names, class names and styles. */\nexport const pluginDeserializeHtml = (\n  editor: SlateEditor,\n  plugin: AnyEditorPlugin,\n  {\n    deserializeLeaf,\n    element: el,\n  }: { element: HTMLElement; deserializeLeaf?: boolean }\n): (Nullable<HtmlDeserializer> & { node: AnyObject }) | undefined => {\n  const {\n    node: { isElement: isElementRoot, isLeaf: isLeafRoot },\n  } = plugin;\n\n  const deserializer = getDeserializedWithStaticRules(plugin);\n\n  if (!deserializer) return;\n\n  const {\n    attributeNames,\n    isElement: isElementRule,\n    isLeaf: isLeafRule,\n    query,\n    rules,\n  } = deserializer;\n  let { parse } = deserializer;\n\n  const isElement = isElementRule || isElementRoot;\n  const isLeaf = isLeafRule || isLeafRoot;\n\n  if (!deserializeLeaf && !isElement) {\n    return;\n  }\n  if (deserializeLeaf && !isLeaf) {\n    return;\n  }\n  if (rules) {\n    const isValid = rules.some(\n      ({ validAttribute, validClassName, validNodeName = '*', validStyle }) => {\n        if (validNodeName) {\n          const validNodeNames = castArray<string>(validNodeName);\n\n          // Ignore if el nodeName is not included in rule validNodeNames (except *).\n          if (\n            validNodeNames.length > 0 &&\n            !validNodeNames.includes(el.nodeName) &&\n            validNodeName !== '*'\n          )\n            return false;\n        }\n        // Ignore if the rule className is not in el class list.\n        if (validClassName && !el.classList.contains(validClassName))\n          return false;\n        if (validStyle) {\n          for (const [key, value] of Object.entries(validStyle)) {\n            const values = castArray<string>(value);\n\n            // Ignore if el style value is not included in rule style values (except *)\n            if (!values.includes((el.style as any)[key]) && value !== '*')\n              return;\n            // Ignore if el style value is falsy (for value *)\n            if (value === '*' && !(el.style as any)[key]) return;\n\n            const defaultNodeValue = plugin.inject.nodeProps?.defaultNodeValue;\n\n            // Ignore if the style value = plugin.inject.nodeProps.defaultNodeValue\n            if (\n              defaultNodeValue &&\n              defaultNodeValue === (el.style as any)[key]\n            ) {\n              return false;\n            }\n          }\n        }\n        if (validAttribute) {\n          if (typeof validAttribute === 'string') {\n            if (!el.getAttributeNames().includes(validAttribute)) return false;\n          } else {\n            for (const [attributeName, attributeValue] of Object.entries(\n              validAttribute\n            )) {\n              const attributeValues = castArray<string>(attributeValue);\n              const elAttribute = el.getAttribute(attributeName);\n\n              if (\n                !isDefined(elAttribute) ||\n                !attributeValues.includes(elAttribute)\n              )\n                return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    );\n\n    if (!isValid) return;\n  }\n  if (\n    query &&\n    !query({ ...(getEditorPlugin(editor, plugin) as any), element: el })\n  ) {\n    return;\n  }\n  if (!parse)\n    if (isElement) {\n      parse = ({ type }) => ({ type: type });\n    } else if (isLeaf) {\n      parse = ({ type }) => ({ [type!]: true });\n    } else {\n      return;\n    }\n\n  const parsedNode = (() => {\n    if (isSlateNode(el)) {\n      return {};\n    }\n\n    return (\n      parse({\n        ...(getEditorPlugin(editor, plugin) as any),\n        element: el,\n        node: {},\n      }) ?? {}\n    );\n  })();\n\n  const dataNodeProps = getDataNodeProps({\n    editor,\n    element: el,\n    plugin,\n  });\n\n  let node = {\n    ...parsedNode,\n    ...dataNodeProps,\n  };\n\n  if (Object.keys(node).length === 0) return;\n\n  const injectedPlugins = getInjectedPlugins(editor, plugin);\n\n  injectedPlugins.forEach((injectedPlugin) => {\n    const res = injectedPlugin.parsers?.html?.deserializer?.parse?.({\n      ...(getEditorPlugin(editor, plugin) as any),\n      element: el,\n      node,\n    });\n\n    if (res && !isSlateNode(el)) {\n      node = {\n        ...node,\n        ...res,\n      };\n    }\n  });\n\n  if (attributeNames) {\n    const elementAttributes = {};\n\n    const elementAttributeNames = el.getAttributeNames();\n\n    for (const elementAttributeName of elementAttributeNames) {\n      if (attributeNames.includes(elementAttributeName)) {\n        (elementAttributes as any)[elementAttributeName] =\n          el.getAttribute(elementAttributeName);\n      }\n    }\n\n    if (Object.keys(elementAttributes).length > 0) {\n      node.attributes = elementAttributes;\n    }\n  }\n\n  return { ...deserializer, node };\n};\n","import type { SlateEditor } from '../../../editor';\n\nimport { type AnyEditorPlugin, getEditorPlugin } from '../../../plugin';\nimport { isSlateLeaf, isSlatePluginNode } from '../../../static';\n\nconst getDefaultNodeProps = ({\n  element,\n  type,\n}: {\n  element: HTMLElement;\n  type: string;\n}) => {\n  if (!isSlatePluginNode(element, type) && !isSlateLeaf(element)) return;\n\n  const dataAttributes: Record<string, any> = {};\n\n  // Get all data-slate-* attributes from dataset\n  Object.entries(element.dataset).forEach(([key, value]) => {\n    if (\n      key.startsWith('slate') &&\n      value &&\n      // Ignore slate default attributes\n      !['slateInline', 'slateLeaf', 'slateNode', 'slateVoid'].includes(key)\n    ) {\n      // Remove 'slate' prefix and convert to camelCase\n      const attributeKey = key.slice(5).charAt(0).toLowerCase() + key.slice(6);\n\n      // Parse value if it's a boolean or number string\n\n      if (value === undefined) return;\n\n      let parsedValue: any = value;\n\n      if (value === 'true') parsedValue = true;\n      else if (value === 'false') parsedValue = false;\n      else if (!Number.isNaN(Number(value))) parsedValue = Number(value);\n\n      dataAttributes[attributeKey] = parsedValue;\n    }\n  });\n\n  if (Object.keys(dataAttributes).length > 0) {\n    return dataAttributes;\n  }\n};\n\nexport const getDataNodeProps = ({\n  editor,\n  element,\n  plugin,\n}: {\n  editor: SlateEditor;\n  element: HTMLElement;\n  plugin: AnyEditorPlugin;\n}) => {\n  const toNodeProps = plugin.parsers.html?.deserializer?.toNodeProps;\n\n  const disableDefaultNodeProps =\n    plugin.parsers.html?.deserializer?.disableDefaultNodeProps ?? false;\n\n  const defaultNodeProps = disableDefaultNodeProps\n    ? {}\n    : getDefaultNodeProps({\n        ...(getEditorPlugin(editor, plugin) as any),\n        element,\n      });\n\n  if (!toNodeProps) return defaultNodeProps;\n\n  const customNodeProps =\n    toNodeProps({\n      ...(getEditorPlugin(editor, plugin) as any),\n      element,\n    }) ?? {};\n\n  return {\n    ...defaultNodeProps,\n    ...customNodeProps,\n  };\n};\n","import type { AnyObject, Nullable } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { HtmlDeserializer } from '../../../plugin/SlatePlugin';\n\nimport { pluginDeserializeHtml } from './pluginDeserializeHtml';\n\nexport const pipeDeserializeHtmlElement = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  let result: (Nullable<HtmlDeserializer> & { node: AnyObject }) | undefined;\n\n  [...editor.meta.pluginList].reverse().some((plugin) => {\n    result = pluginDeserializeHtml(editor, plugin, { element });\n\n    return !!result;\n  });\n\n  return result;\n};\n","import { type Descendant, ElementApi, TextApi } from '@platejs/slate';\nimport { jsx } from 'slate-hyperscript';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { mergeDeepToNodes } from '../../../utils';\nimport { deserializeHtmlNodeChildren } from './deserializeHtmlNodeChildren';\nimport { pipeDeserializeHtmlLeaf } from './pipeDeserializeHtmlLeaf';\n\n/**\n * Deserialize HTML to Descendant[] with marks on Text. Build the leaf from the\n * leaf deserializers of each plugin.\n */\nexport const htmlElementToLeaf = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  const node = pipeDeserializeHtmlLeaf(editor, element);\n\n  return deserializeHtmlNodeChildren(editor, element).reduce(\n    (arr: Descendant[], child) => {\n      if (!child) return arr;\n      if (ElementApi.isElement(child)) {\n        if (Object.keys(node).length > 0) {\n          mergeDeepToNodes({\n            node: child,\n            query: {\n              filter: ([n]) => TextApi.isText(n),\n            },\n            source: node,\n          });\n        }\n\n        arr.push(child);\n      } else {\n        const attributes = { ...node };\n\n        // attributes should not override child attributes\n        if (TextApi.isText(child) && child.text) {\n          Object.keys(attributes).forEach((key) => {\n            if (attributes[key] && child[key]) {\n              attributes[key] = child[key];\n            }\n          });\n        }\n\n        arr.push(jsx('text', attributes, child) as any);\n      }\n\n      return arr;\n    },\n    []\n  ) as Descendant[];\n};\n","import type { AnyObject } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { pluginDeserializeHtml } from './pluginDeserializeHtml';\n\nexport const pipeDeserializeHtmlLeaf = (\n  editor: SlateEditor,\n  element: HTMLElement\n) => {\n  let node: AnyObject = {};\n\n  [...editor.meta.pluginList].reverse().forEach((plugin) => {\n    const deserialized = pluginDeserializeHtml(editor, plugin, {\n      deserializeLeaf: true,\n      element,\n    });\n\n    if (!deserialized) return;\n\n    node = { ...node, ...deserialized.node };\n  });\n\n  return node;\n};\n","/** Deserialize HTML text node to text. */\nimport { isHtmlText } from './isHtmlText';\n\nexport const htmlTextNodeToString = (node: ChildNode | HTMLElement) => {\n  if (isHtmlText(node)) {\n    if (node.parentElement?.dataset.platePreventDeserialization) return '';\n\n    return node.textContent || '';\n  }\n};\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlNodeReturnType } from '../types';\n\nimport { isSlateNode } from '../../../static';\nimport { htmlBodyToFragment } from './htmlBodyToFragment';\nimport { htmlBrToNewLine } from './htmlBrToNewLine';\nimport { htmlElementToElement } from './htmlElementToElement';\nimport { htmlElementToLeaf } from './htmlElementToLeaf';\nimport { htmlTextNodeToString } from './htmlTextNodeToString';\nimport { inlineTagNames } from './inlineTagNames';\nimport { isHtmlElement } from './isHtmlElement';\n\n/** Check if an element is a block-level element. */\nconst isBlockElement = (element: Element | null): boolean => {\n  if (!element) return false;\n\n  return !inlineTagNames.has(element.tagName);\n};\n\n/** Check if a BR tag should be converted to an empty paragraph. */\nconst shouldBrBecomeEmptyParagraph = (node: Element): boolean => {\n  if (node.nodeName !== 'BR') return false;\n\n  // Skip Apple-interchange-newline BR tags\n  if ((node as HTMLBRElement).className === 'Apple-interchange-newline') {\n    return false;\n  }\n\n  const parent = node.parentElement;\n  if (!parent) return false;\n\n  // Check immediate parent for text-containing elements\n  // BR tags inside P or SPAN should remain as line breaks\n  if (parent.tagName === 'P' || parent.tagName === 'SPAN') {\n    return false;\n  }\n\n  // Check if BR has adjacent text content at the same DOM level\n  const hasAdjacentText = () => {\n    // Check previous siblings for direct text nodes only\n    let sibling: Node | null = node.previousSibling;\n    while (sibling) {\n      if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent?.trim()) {\n        return true;\n      }\n      // Don't check element content, only direct text nodes\n      sibling = sibling.previousSibling;\n    }\n\n    // Check next siblings for direct text nodes only\n    sibling = node.nextSibling;\n    while (sibling) {\n      if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent?.trim()) {\n        return true;\n      }\n      // Don't check element content, only direct text nodes\n      sibling = sibling.nextSibling;\n    }\n\n    return false;\n  };\n\n  // If BR has adjacent text, it should be a line break\n  if (hasAdjacentText()) {\n    return false;\n  }\n\n  // For Google Docs: standalone BR tags inside structural elements (B, TD, DIV, etc.)\n  // should become empty paragraphs\n  return true;\n};\n\n/** Deserialize HTML element or child node. */\nexport const deserializeHtmlNode =\n  (editor: SlateEditor) =>\n  (node: ChildNode | HTMLElement): DeserializeHtmlNodeReturnType => {\n    const textNode = htmlTextNodeToString(node);\n\n    if (textNode) return textNode;\n    if (!isHtmlElement(node)) return null;\n\n    // Convert BR tags to empty paragraphs when appropriate (e.g., from Google Docs)\n    if (shouldBrBecomeEmptyParagraph(node)) {\n      return {\n        children: [{ text: '' }],\n        type: editor.getType('p'),\n      };\n    }\n\n    // Skip Apple-interchange-newline BR tags (already handled in shouldBrBecomeEmptyParagraph)\n    if (\n      node.nodeName === 'BR' &&\n      (node as HTMLBRElement).className === 'Apple-interchange-newline'\n    ) {\n      return null;\n    }\n\n    // break line\n    const breakLine = htmlBrToNewLine(node);\n\n    if (breakLine) return breakLine;\n\n    // body\n    const fragment = htmlBodyToFragment(editor, node as HTMLElement);\n\n    if (fragment) return fragment;\n\n    // element\n    const element = htmlElementToElement(\n      editor,\n      node as HTMLElement,\n      isSlateNode(node as HTMLElement)\n    );\n\n    if (element) return element;\n\n    // leaf\n    return htmlElementToLeaf(editor, node as HTMLElement);\n  };\n","import type { SlateEditor } from '../../../editor';\nimport type { DeserializeHtmlNodeReturnType } from '../types';\n\nimport { deserializeHtmlNode } from './deserializeHtmlNode';\n\n/** Deserialize HTML element to fragment. */\nexport const deserializeHtmlElement = (\n  editor: SlateEditor,\n  element: HTMLElement\n): DeserializeHtmlNodeReturnType => {\n  return deserializeHtmlNode(editor)(element);\n};\n","/** Convert HTML string into HTML element. */\nexport const htmlStringToDOMNode = (rawHtml: string) => {\n  const node = document.createElement('body');\n  node.innerHTML = rawHtml;\n\n  return node;\n};\n","import type { Descendant } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../../editor';\nimport type { WithRequiredKey } from '../../../plugin';\n\nimport { normalizeDescendantsToDocumentFragment } from '../../../utils/normalizeDescendantsToDocumentFragment';\nimport { collapseWhiteSpace } from './collapse-white-space';\nimport { deserializeHtmlElement } from './deserializeHtmlElement';\nimport { htmlStringToDOMNode } from './htmlStringToDOMNode';\n\n/** Deserialize HTML element to a valid document fragment. */\nexport const deserializeHtml = (\n  editor: SlateEditor,\n  {\n    collapseWhiteSpace: shouldCollapseWhiteSpace = true,\n    defaultElementPlugin,\n    element,\n  }: {\n    element: HTMLElement | string;\n    collapseWhiteSpace?: boolean;\n    defaultElementPlugin?: WithRequiredKey;\n  }\n): Descendant[] => {\n  // for serializer\n  if (typeof element === 'string') {\n    element = htmlStringToDOMNode(element);\n  }\n\n  if (shouldCollapseWhiteSpace) {\n    element = collapseWhiteSpace(element);\n  }\n\n  const fragment = deserializeHtmlElement(editor, element) as Descendant[];\n\n  return normalizeDescendantsToDocumentFragment(editor, {\n    defaultElementPlugin,\n    descendants: fragment,\n  });\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Find the first HTML element that matches the given selector.\n *\n * @param rootNode\n * @param predicate\n */\nexport const findHtmlElement = (\n  rootNode: Node,\n  predicate: (node: HTMLElement) => boolean\n) => {\n  let res: Node | null = null;\n\n  traverseHtmlElements(rootNode, (node) => {\n    if (predicate(node as HTMLElement)) {\n      res = node;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  return res;\n};\n\nexport const someHtmlElement = (\n  rootNode: Node,\n  predicate: (node: HTMLElement) => boolean\n) => {\n  return !!findHtmlElement(rootNode, predicate);\n};\n","const acceptNode = () => NodeFilter.FILTER_ACCEPT;\n\nexport const getHtmlComments = (node: Node): string[] => {\n  const comments: string[] = [];\n  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode,\n  });\n  let currentNode = iterator.nextNode();\n\n  while (currentNode) {\n    if (currentNode.nodeValue) {\n      comments.push(currentNode.nodeValue);\n    }\n\n    currentNode = iterator.nextNode();\n  }\n\n  return comments;\n};\n","export const isHtmlComment = (node: Node): node is Comment =>\n  node.nodeType === Node.COMMENT_NODE;\n","export const isOlSymbol = (symbol: string): boolean => {\n  return /[\\da-np-z]\\S/.test(symbol.toLowerCase());\n};\n","export const parseHtmlDocument = (html: string) => {\n  return new DOMParser().parseFromString(html, 'text/html');\n};\n","import { parseHtmlDocument } from './parseHtmlDocument';\n\nexport const parseHtmlElement = (html: string) => {\n  const { body } = parseHtmlDocument(html);\n\n  return body.firstElementChild as HTMLElement;\n};\n","import { ZERO_WIDTH_SPACE } from '../constants';\n\n/** Trim the html and remove zero width spaces, then wrap it with a body element. */\nexport const postCleanHtml = (html: string): string => {\n  const cleanHtml = html\n    .trim()\n    .replaceAll(new RegExp(ZERO_WIDTH_SPACE, 'g'), '');\n\n  return `<body>${cleanHtml}</body>`;\n};\n","/** Remove string before <html */\nconst removeBeforeHtml = (html: string): string => {\n  const index = html.indexOf('<html');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.slice(Math.max(0, index));\n};\n\n/** Remove string after </html> */\nconst removeAfterHtml = (html: string): string => {\n  const index = html.lastIndexOf('</html>');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.slice(0, Math.max(0, index + '</html>'.length));\n};\n\n/** Remove string before <html and after </html> */\nexport const removeHtmlSurroundings = (html: string): string => {\n  return removeBeforeHtml(removeAfterHtml(html));\n};\n","import { cleanHtmlCrLf } from './cleanHtmlCrLf';\nimport { removeHtmlSurroundings } from './removeHtmlSurroundings';\n\nconst cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];\n\n/** Remove HTML surroundings and clean HTML from CR/LF */\nexport const preCleanHtml = (html: string): string => {\n  return cleaners.reduce((result, clean) => clean(result), html);\n};\n","import { isHtmlComment } from './isHtmlComment';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Comment) => boolean;\n\n/** Traverse HTML comments. */\nexport const traverseHtmlComments = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlComment(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { isHtmlComment } from './isHtmlComment';\nimport { traverseHtmlComments } from './traverseHtmlComments';\n\n/** Removes HTML nodes between HTML comments. */\nexport const removeHtmlNodesBetweenComments = (\n  rootNode: Node,\n  start: string,\n  end: string\n): void => {\n  const isClosingComment = (node: Node) =>\n    isHtmlComment(node) && node.data === end;\n\n  traverseHtmlComments(rootNode, (comment) => {\n    if (comment.data === start) {\n      let node = comment.nextSibling;\n\n      comment.remove();\n\n      while (node && !isClosingComment(node)) {\n        const { nextSibling } = node;\n        node.remove();\n        node = nextSibling;\n      }\n\n      if (node && isClosingComment(node)) {\n        node.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","import type { LengthConfig } from '../getCorePlugins';\n\nimport { createTSlatePlugin } from '../../plugin';\n\nexport const LengthPlugin = createTSlatePlugin<LengthConfig>({\n  key: 'length',\n}).overrideEditor(({ editor, getOptions, tf: { apply } }) => ({\n  transforms: {\n    apply(operation) {\n      editor.tf.withoutNormalizing(() => {\n        apply(operation);\n\n        const options = getOptions();\n\n        if (options.maxLength) {\n          const length = editor.api.string([]).length;\n\n          // Make sure to remove overflow of text beyond character limit\n          if (length > options.maxLength) {\n            const overflowLength = length - options.maxLength;\n\n            editor.tf.delete({\n              distance: overflowLength,\n              reverse: true,\n              unit: 'character',\n            });\n          }\n        }\n      });\n    },\n  },\n}));\n","import {\n  type Descendant,\n  type QueryNodeOptions,\n  type Value,\n  ElementApi,\n  queryNode,\n} from '@platejs/slate';\nimport { nanoid } from 'nanoid';\n\nimport type { PluginConfig } from '../../plugin/BasePlugin';\n\nimport { createTSlatePlugin } from '../../plugin/createSlatePlugin';\nimport { withNodeId } from './withNodeId';\n\nexport type NodeIdOptions = {\n  /**\n   * By default, when a node inserted using editor.tf.insertNode(s) has an id,\n   * it will be used instead of the id generator, except if it already exists in\n   * the document. Set this option to true to disable this behavior.\n   */\n  disableInsertOverrides?: boolean;\n  /**\n   * Filter inline `Element` nodes.\n   *\n   * @default true\n   */\n  filterInline?: boolean;\n  /**\n   * Filter `Text` nodes.\n   *\n   * @default true\n   */\n  filterText?: boolean;\n  /**\n   * Node key to store the id.\n   *\n   * @default 'id'\n   */\n  idKey?: string;\n  /**\n   * Normalize initial value. If false, normalize only the first and last node\n   * are missing id. To disable this behavior, use `NodeIdPlugin.configure({\n   * normalizeInitialValue: null })`.\n   *\n   * @default false\n   */\n  normalizeInitialValue?: boolean;\n  /**\n   * Reuse ids on undo/redo and copy/pasting if not existing in the document.\n   * This is disabled by default to avoid duplicate ids across documents.\n   *\n   * @default false\n   */\n  reuseId?: boolean;\n  /**\n   * A function that generates and returns a unique ID.\n   *\n   * @default () => nanoid(10)\n   */\n  idCreator?: () => any;\n} & QueryNodeOptions;\n\nexport type NormalizeNodeIdOptions = Pick<\n  NodeIdOptions,\n  | 'allow'\n  | 'exclude'\n  | 'filter'\n  | 'filterInline'\n  | 'filterText'\n  | 'idCreator'\n  | 'idKey'\n>;\n\n/**\n * Normalize node IDs in a value without using editor operations. This is a pure\n * function that returns a new normalized value.\n */\nexport const normalizeNodeId = <V extends Value>(\n  value: V,\n  options: NormalizeNodeIdOptions = {}\n): V => {\n  const {\n    allow,\n    exclude,\n    filter = () => true,\n    filterInline = true,\n    filterText = true,\n    idCreator = () => nanoid(10),\n    idKey = 'id',\n  } = options;\n\n  const normalizeNode = (node: Descendant, path: number[]): Descendant => {\n    // Clone the node to avoid mutating the original\n    const clonedNode = { ...node };\n\n    // Check if we should add ID to this node\n    if (\n      !clonedNode[idKey] &&\n      queryNode([clonedNode, path], {\n        allow,\n        exclude,\n        filter: (entry) => {\n          const [node] = entry;\n\n          if (filterText && !ElementApi.isElement(node)) {\n            return false;\n          }\n          if (\n            filterInline &&\n            ElementApi.isElement(node) &&\n            // For static normalization, we can't use editor.api.isBlock\n            // so we'll assume all elements with children are blocks unless inline is explicitly set\n            (node as any).inline === true\n          ) {\n            return false;\n          }\n\n          return filter(entry);\n        },\n      })\n    ) {\n      clonedNode[idKey] = idCreator();\n    }\n\n    // Recursively normalize children if it's an element\n    if (ElementApi.isElement(clonedNode)) {\n      clonedNode.children = clonedNode.children.map((child, index) =>\n        normalizeNode(child as Descendant, [...path, index])\n      );\n    }\n\n    return clonedNode;\n  };\n\n  // Normalize all top-level nodes\n  return value.map((node, index) => normalizeNode(node, [index])) as V;\n};\n\nexport type NodeIdConfig = PluginConfig<\n  'nodeId',\n  NodeIdOptions,\n  {},\n  {\n    nodeId: {\n      normalize: () => void;\n    };\n  }\n>;\n\n/** @see {@link withNodeId} */\nexport const NodeIdPlugin = createTSlatePlugin<NodeIdConfig>({\n  key: 'nodeId',\n  options: {\n    filterInline: true,\n    filterText: true,\n    idKey: 'id',\n    normalizeInitialValue: false,\n    filter: () => true,\n    idCreator: () => nanoid(10),\n  },\n})\n  .extendTransforms(({ editor, getOptions }) => ({\n    normalize() {\n      const { allow, exclude, filter, filterInline, filterText, idKey } =\n        getOptions();\n\n      const addNodeId = (entry: [Descendant, number[]]) => {\n        const [node, path] = entry;\n\n        if (\n          !node[idKey!] &&\n          queryNode([node, path], {\n            allow,\n            exclude,\n            filter: (entry) => {\n              const [node] = entry;\n\n              if (filterText && !ElementApi.isElement(node)) {\n                return false;\n              }\n              if (\n                filterInline &&\n                ElementApi.isElement(node) &&\n                !editor.api.isBlock(node)\n              ) {\n                return false;\n              }\n\n              return filter!(entry);\n            },\n          })\n        ) {\n          // Verify node exists at path before attempting to modify\n          const existingNode = editor.api.node(path);\n          if (!existingNode) {\n            return;\n          }\n\n          editor.tf.withoutSaving(() => {\n            editor.tf.setNodes(\n              { [idKey!]: getOptions().idCreator!() },\n              { at: path }\n            );\n          });\n        }\n\n        // Only traverse children if this is an Element node\n        if (ElementApi.isElement(node)) {\n          node.children.forEach((child: any, index: number) => {\n            addNodeId([child, [...path, index]]);\n          });\n        }\n      };\n\n      // Process top-level nodes in place\n      editor.children.forEach((node, index) => {\n        addNodeId([node, [index]]);\n      });\n    },\n  }))\n  .extend({\n    normalizeInitialValue: ({ editor, getOptions, tf }) => {\n      const { normalizeInitialValue } = getOptions();\n\n      // Perf: check if normalization is needed by looking at the first node and last node\n      if (!normalizeInitialValue) {\n        const firstNode = editor.children[0];\n        const lastNode = editor.children.at(-1);\n\n        if (firstNode?.id && lastNode?.id) {\n          return;\n        }\n      }\n\n      tf.nodeId.normalize();\n    },\n  })\n  .overrideEditor(withNodeId);\n","import {\n  type Descendant,\n  type NodeEntry,\n  type NodeProps,\n  type TNode,\n  queryNode,\n} from '@platejs/slate';\nimport { isDefined } from '@udecode/utils';\nimport castArray from 'lodash/castArray.js';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport type { OverrideEditor } from '../../plugin';\nimport type { NodeIdConfig } from './NodeIdPlugin';\n\nimport { applyDeepToNodes, defaultsDeepToNodes } from '../../utils';\n\n/** Enables support for inserting nodes with an id key. */\nexport const withNodeId: OverrideEditor<NodeIdConfig> = ({\n  editor,\n  getOptions,\n  tf: { apply, insertNode, insertNodes },\n}) => {\n  const idPropsCreator = () => ({\n    [getOptions().idKey ?? '']: getOptions().idCreator!(),\n  });\n\n  const filterNode = (nodeEntry: NodeEntry) => {\n    const { filter, filterText } = getOptions();\n\n    return (\n      filter!(nodeEntry) && (!filterText || nodeEntry[0]?.type !== undefined)\n    );\n  };\n\n  const removeIdFromNodeIfDuplicate = <N extends Descendant>(node: N) => {\n    const { idKey = '', reuseId } = getOptions();\n\n    if (\n      !reuseId &&\n      editor.api.some({ at: [], match: { [idKey]: node[idKey] } })\n    ) {\n      delete node[idKey];\n    }\n  };\n\n  const overrideIdIfSet = (node: TNode) => {\n    const { idKey = '' } = getOptions();\n\n    if (isDefined(node._id)) {\n      const id = node._id;\n      delete node._id;\n\n      if (!editor.api.some({ at: [], match: { [idKey]: id } })) {\n        node[idKey] = id;\n      }\n    }\n  };\n\n  return {\n    transforms: {\n      apply(operation) {\n        const {\n          allow,\n          disableInsertOverrides,\n          exclude,\n          idCreator,\n          idKey = '',\n          reuseId,\n        } = getOptions();\n\n        const query = {\n          allow,\n          exclude,\n          filter: filterNode,\n        };\n\n        if (operation.type === 'insert_node') {\n          // clone to be able to write (read-only)\n          const node = cloneDeep(operation.node);\n\n          // Delete ids from node that are already being used\n          applyDeepToNodes({\n            apply: removeIdFromNodeIfDuplicate,\n            node,\n            query,\n            source: {},\n          });\n\n          defaultsDeepToNodes({\n            node,\n            path: operation.path,\n            query,\n            source: idPropsCreator,\n          });\n\n          if (!disableInsertOverrides) {\n            applyDeepToNodes({\n              apply: overrideIdIfSet,\n              node,\n              query,\n              source: {},\n            });\n          }\n\n          return apply({\n            ...operation,\n            node,\n          });\n        }\n        if (operation.type === 'split_node') {\n          const node = operation.properties as NodeProps<TNode>;\n          let id = (operation.properties as any)[idKey];\n\n          // only for elements (node with a type) or all nodes if `filterText=false`\n\n          if (queryNode([node as any, operation.path], query)) {\n            /**\n             * Create a new id if:\n             *\n             * - The id in the new node is already being used in the editor or,\n             * - The node has no id\n             */\n            if (\n              !reuseId ||\n              id === undefined ||\n              editor.api.some({\n                at: [],\n                match: { [idKey]: id },\n              })\n            ) {\n              id = idCreator!();\n            }\n\n            return apply({\n              ...operation,\n              properties: {\n                ...operation.properties,\n                [idKey]: id,\n              },\n            });\n          }\n          // if the node is allowed, we don't want to use the same id\n          if (id) {\n            delete (operation.properties as any)[idKey];\n          }\n        }\n\n        return apply(operation);\n      },\n\n      insertNode(node) {\n        const { disableInsertOverrides, idKey = '' } = getOptions();\n\n        if (!disableInsertOverrides && node[idKey]) {\n          if (!Object.isExtensible(node)) {\n            node = cloneDeep(node);\n          }\n\n          node._id = node[idKey];\n        }\n\n        insertNode(node);\n      },\n\n      insertNodes(_nodes, options) {\n        const nodes = castArray<Descendant>(_nodes as any).filter(\n          (node) => !!node\n        );\n\n        if (nodes.length === 0) return;\n\n        const { disableInsertOverrides, idKey = '' } = getOptions();\n\n        insertNodes(\n          nodes.map((node) => {\n            if (!disableInsertOverrides && node[idKey]) {\n              if (!Object.isExtensible(node)) {\n                node = cloneDeep(node);\n              }\n\n              node._id = node[idKey];\n            }\n\n            return node;\n          }),\n          options\n        );\n      },\n    },\n  };\n};\n","import {\n  type Descendant,\n  type NodeOperation,\n  type TextOperation,\n  type TText,\n  NodeApi,\n  OperationApi,\n  PathApi,\n} from '@platejs/slate';\nimport { type OmitFirst, bindFirst } from '@udecode/utils';\n\nimport type { SlateEditor } from '../../editor';\nimport type { PluginConfig } from '../../plugin';\n\nimport { createTSlatePlugin } from '../../plugin';\nimport { pipeOnNodeChange } from '../../utils/pipeOnNodeChange';\nimport { pipeOnTextChange } from '../../utils/pipeOnTextChange';\nimport { init } from './transforms/init';\nimport { insertExitBreak } from './transforms/insertExitBreak';\nimport { resetBlock } from './transforms/resetBlock';\nimport { setValue } from './transforms/setValue';\n\nexport type SlateExtensionConfig = PluginConfig<\n  'slateExtension',\n  {\n    onNodeChange: (options: {\n      editor: SlateEditor;\n      node: Descendant;\n      operation: NodeOperation;\n      prevNode: Descendant;\n    }) => void;\n    onTextChange: (options: {\n      editor: SlateEditor;\n      node: Descendant;\n      operation: TextOperation;\n      prevText: string;\n      text: string;\n    }) => void;\n  },\n  {},\n  {\n    init: OmitFirst<typeof init>;\n    insertExitBreak: OmitFirst<typeof insertExitBreak>;\n    resetBlock: OmitFirst<typeof resetBlock>;\n    setValue: OmitFirst<typeof setValue>;\n  }\n>;\n\n/** Opinionated extension of slate default behavior. */\nexport const SlateExtensionPlugin = createTSlatePlugin<SlateExtensionConfig>({\n  key: 'slateExtension',\n  options: {\n    onNodeChange: () => {},\n    onTextChange: () => {},\n  },\n}).extendEditorTransforms(({ editor, getOption, tf: { apply } }) => ({\n  /**\n   * Initialize the editor value, selection and normalization. Set `value` to\n   * `null` to skip children initialization.\n   */\n  init: bindFirst(init, editor),\n  insertExitBreak: bindFirst(insertExitBreak, editor),\n  resetBlock: bindFirst(resetBlock, editor),\n  setValue: bindFirst(setValue, editor),\n  apply(operation) {\n    // Performance optimization: skip state capture if no handlers are registered\n    const noop = () => {};\n    const hasNodeHandlers =\n      editor.meta.pluginCache.handlers.onNodeChange.length > 0 ||\n      getOption('onNodeChange') !== noop;\n    const hasTextHandlers =\n      editor.meta.pluginCache.handlers.onTextChange.length > 0 ||\n      getOption('onTextChange') !== noop;\n\n    if (!hasNodeHandlers && !hasTextHandlers) {\n      apply(operation);\n      return;\n    }\n\n    let prevNode: Descendant | undefined;\n    let node: Descendant | undefined;\n    let prevText: string | undefined;\n    let text: string | undefined;\n    let parentNode: Descendant | undefined;\n\n    if (OperationApi.isNodeOperation(operation) && hasNodeHandlers) {\n      // Get node states BEFORE applying the operation\n      switch (operation.type) {\n        case 'insert_node': {\n          // Both are the new node being inserted\n          prevNode = operation.node;\n          node = operation.node;\n          break;\n        }\n\n        case 'merge_node':\n        case 'move_node':\n        case 'set_node':\n        case 'split_node': {\n          // Get the node before the operation\n          prevNode = NodeApi.get(editor, operation.path);\n          break;\n        }\n        case 'remove_node': {\n          // Both are the node being removed\n          prevNode = operation.node;\n          node = operation.node;\n          break;\n        }\n      }\n    } else if (OperationApi.isTextOperation(operation) && hasTextHandlers) {\n      // Get parent node that contains the text\n      const parentPath = PathApi.parent(operation.path);\n      parentNode = NodeApi.get<Descendant>(editor, parentPath);\n\n      // Get text node before operation\n      const textNode = NodeApi.get<TText>(editor, operation.path)!;\n      prevText = textNode.text;\n    }\n\n    // Apply the operation\n    apply(operation);\n\n    // Get AFTER state for operations where node changes\n    if (OperationApi.isNodeOperation(operation) && hasNodeHandlers) {\n      switch (operation.type) {\n        case 'insert_node':\n        case 'remove_node': {\n          // Already set above, keep the same\n          break;\n        }\n\n        case 'merge_node': {\n          // Get the merged result (at previous path)\n          const prevPath = PathApi.previous(operation.path);\n\n          if (prevPath) {\n            node = NodeApi.get(editor, prevPath);\n          }\n\n          break;\n        }\n\n        case 'move_node': {\n          // Get node at new location\n          node = NodeApi.get(editor, operation.newPath);\n          break;\n        }\n\n        case 'set_node': {\n          // Get the updated node\n          node = NodeApi.get(editor, operation.path);\n          break;\n        }\n\n        case 'split_node': {\n          // Get the first part of the split\n          node = NodeApi.get(editor, operation.path);\n          break;\n        }\n      }\n\n      // Ensure node is set (fallback to prevNode if needed)\n      if (!node) {\n        node = prevNode;\n      }\n\n      // Call handlers - both node and prevNode are guaranteed to be defined\n      const eventIsHandled = pipeOnNodeChange(\n        editor,\n        node!,\n        prevNode!,\n        operation\n      );\n\n      if (!eventIsHandled) {\n        const onNodeChange = getOption('onNodeChange');\n        onNodeChange({ editor, node: node!, operation, prevNode: prevNode! });\n      }\n    }\n\n    // Handle text operations\n    if (OperationApi.isTextOperation(operation) && hasTextHandlers) {\n      const textNodeAfter = NodeApi.get<TText>(editor, operation.path);\n      if (textNodeAfter) {\n        text = textNodeAfter.text;\n      }\n\n      const eventIsHandled = pipeOnTextChange(\n        editor,\n        parentNode!,\n        text!,\n        prevText!,\n        operation\n      );\n\n      if (!eventIsHandled) {\n        const onTextChange = getOption('onTextChange');\n        onTextChange({\n          editor,\n          node: parentNode!,\n          operation,\n          prevText: prevText!,\n          text: text!,\n        });\n      }\n    }\n  },\n}));\n","import type { Descendant, NodeOperation } from '@platejs/slate';\n\nimport type { SlateEditor } from '../editor/SlateEditor';\n\nexport const pipeOnNodeChange = (\n  editor: SlateEditor,\n  node: Descendant,\n  prevNode: Descendant,\n  operation: NodeOperation\n) => {\n  return editor.meta.pluginCache.handlers.onNodeChange.some((key) => {\n    const plugin = editor.getPlugin({ key });\n\n    // Skip if plugin not found or readOnly\n    if (!plugin || editor.dom?.readOnly) {\n      return false;\n    }\n\n    const handler = plugin.handlers?.onNodeChange;\n    if (!handler) {\n      return false;\n    }\n\n    // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    const shouldTreatEventAsHandled = handler({\n      editor,\n      node,\n      operation,\n      plugin,\n      prevNode,\n    } as any);\n\n    if (shouldTreatEventAsHandled != null) {\n      return shouldTreatEventAsHandled;\n    }\n\n    return false;\n  });\n};\n","import type { Descendant, TextOperation } from '@platejs/slate';\n\nimport type { SlateEditor } from '../editor/SlateEditor';\n\nexport const pipeOnTextChange = (\n  editor: SlateEditor,\n  node: Descendant,\n  text: string,\n  prevText: string,\n  operation: TextOperation\n) => {\n  return editor.meta.pluginCache.handlers.onTextChange.some((key) => {\n    const plugin = editor.getPlugin({ key });\n\n    // Skip if plugin not found or readOnly\n    if (!plugin || editor.dom?.readOnly) {\n      return false;\n    }\n\n    const handler = plugin.handlers?.onTextChange;\n    if (!handler) {\n      return false;\n    }\n\n    // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    const shouldTreatEventAsHandled = handler({\n      editor,\n      node,\n      operation,\n      plugin,\n      prevText,\n      text,\n    } as any);\n\n    if (shouldTreatEventAsHandled != null) {\n      return shouldTreatEventAsHandled;\n    }\n\n    return false;\n  });\n};\n","import type { SlateEditor } from '../../lib/editor';\n\nimport { getEditorPlugin } from '../../lib/plugin';\nimport { isEditOnly } from './isEditOnlyDisabled';\n\n/** Normalize initial value from editor plugins. Set into plate store if diff. */\nexport const pipeNormalizeInitialValue = (editor: SlateEditor) => {\n  const value = editor.meta.isNormalizing;\n\n  editor.meta.isNormalizing = true;\n\n  editor.meta.pluginCache.normalizeInitialValue.forEach((key) => {\n    const p = editor.getPlugin({ key });\n\n    if (isEditOnly(editor.dom.readOnly, p, 'normalizeInitialValue')) {\n      return;\n    }\n\n    p.normalizeInitialValue?.({\n      ...getEditorPlugin(editor, p),\n      value: editor.children,\n    } as any);\n  });\n\n  editor.meta.isNormalizing = value;\n};\n","import type { EditorTransforms, TSelection, Value } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { pipeNormalizeInitialValue } from '../../../../internal/plugin/pipeNormalizeInitialValue';\n\nexport type InitOptions = {\n  autoSelect?: boolean | 'end' | 'start';\n  selection?: TSelection;\n  shouldNormalizeEditor?: boolean;\n  value?: any;\n  onReady?: (ctx: {\n    editor: SlateEditor;\n    isAsync: boolean;\n    value: Value;\n  }) => void;\n};\n\nexport const init = (\n  editor: SlateEditor,\n  { autoSelect, selection, shouldNormalizeEditor, value, onReady }: InitOptions\n) => {\n  const onValueLoaded = (isAsync = false) => {\n    if (!editor.children || editor.children?.length === 0) {\n      editor.children = editor.api.create.value();\n    }\n\n    if (selection) {\n      editor.selection = selection;\n    } else if (autoSelect) {\n      const edge = autoSelect === 'start' ? 'start' : 'end';\n      const target =\n        edge === 'start' ? editor.api.start([]) : editor.api.end([]);\n\n      editor.tf.select(target!);\n    }\n    if (editor.children.length > 0) {\n      pipeNormalizeInitialValue(editor);\n    }\n    if (shouldNormalizeEditor) {\n      (editor.tf as EditorTransforms).normalize({ force: true });\n    }\n\n    // Only trigger React re-render for async initialization\n    if (onReady) {\n      onReady({ editor, isAsync, value: editor.children });\n    }\n  };\n\n  if (value === null) {\n    onValueLoaded();\n  } else {\n    if (typeof value === 'string') {\n      editor.children = editor.api.html.deserialize({\n        element: value,\n      }) as Value;\n      onValueLoaded();\n    } else if (typeof value === 'function') {\n      const result = value(editor);\n\n      // Check if result is a promise (async function)\n      if (result && typeof result.then === 'function') {\n        result.then((resolvedValue: any) => {\n          editor.children = resolvedValue;\n          onValueLoaded(true);\n        });\n      } else {\n        // Synchronous function\n        editor.children = result;\n        onValueLoaded();\n      }\n    } else if (value) {\n      editor.children = value;\n      onValueLoaded();\n    } else {\n      onValueLoaded();\n    }\n  }\n};\n","import {\n  type EditorAboveOptions,\n  combineMatchOptions,\n  PathApi,\n} from '@platejs/slate';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { getPluginByType } from '../../../plugin/getSlatePlugin';\n\nexport type InsertExitBreakOptions = {\n  match?: EditorAboveOptions['match'];\n  reverse?: boolean;\n};\n\n/**\n * Exits the current block structure by creating a new block next to the\n * appropriate ancestor.\n *\n * This function automatically determines the exit point by finding the first\n * ancestor that doesn't have strict sibling constraints (`isStrictSiblings:\n * false`), allowing standard text blocks to be inserted as siblings.\n *\n * For example:\n *\n * - In `column_group > column > codeblock > codeline`, exits after `codeblock`,\n *   then after `column_group`\n * - In `table > tr > td > p`, exits after `table`\n */\nexport const insertExitBreak = (\n  editor: SlateEditor,\n  { match, reverse }: InsertExitBreakOptions = {}\n) => {\n  if (!editor.selection || !editor.api.isCollapsed()) return;\n\n  const block = editor.api.block();\n\n  if (!block) return;\n\n  // Find the nearest ancestor that allows arbitrary block siblings (isStrictSiblings: false)\n  // We traverse up the tree until we find an element that can have paragraph siblings\n  const target = editor.api.above({\n    at: block[1],\n    match: combineMatchOptions(\n      editor,\n      (n, p) =>\n        p.length === 1 ||\n        (p.length > 1 &&\n          !!n.type &&\n          !getPluginByType(editor, n.type as string)?.node.isStrictSiblings),\n      { match }\n    ),\n  });\n\n  const ancestorPath = target?.[1] ?? block[1];\n\n  const targetPath = reverse ? ancestorPath : PathApi.next(ancestorPath);\n\n  if (!targetPath) return;\n\n  editor.tf.insertNodes(editor.api.create.block(), {\n    at: targetPath,\n    select: true,\n  });\n\n  return true;\n};\n","import { type Path, NodeApi } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../../editor';\n\nimport { BaseParagraphPlugin } from '../../paragraph';\n\n/**\n * Reset the current block to a paragraph, removing all properties except id and\n * type.\n */\nexport const resetBlock = (editor: SlateEditor, { at }: { at?: Path } = {}) => {\n  const entry = editor.api.block({ at });\n  if (!entry?.[0]) return;\n\n  const [block, path] = entry;\n\n  editor.tf.withoutNormalizing(() => {\n    // Extract only id and type, unset all other properties\n    const { id, type, ...otherProps } = NodeApi.extractProps(block);\n\n    // Unset all properties except id and type\n    Object.keys(otherProps).forEach((key) => {\n      editor.tf.unsetNodes(key, { at: path });\n    });\n\n    const paragraphType = editor.getType(BaseParagraphPlugin.key);\n\n    if (block.type !== paragraphType) {\n      // Set the new type to paragraph\n      editor.tf.setNodes({ type: paragraphType }, { at: path });\n    }\n  });\n\n  return true;\n};\n","import type { Descendant, EditorTransforms, Value } from '@platejs/slate';\n\nimport type { SlateEditor } from '../../../editor';\n\nexport const setValue = <V extends Value>(\n  editor: SlateEditor,\n  value?: V | string\n) => {\n  let children: Descendant[] = value as any;\n\n  if (typeof value === 'string') {\n    children = editor.api.html.deserialize({\n      element: value,\n    });\n  } else if (!value || value.length === 0) {\n    children = editor.api.create.value();\n  }\n\n  (editor.tf as EditorTransforms).replaceNodes(children, {\n    at: [],\n    children: true,\n  });\n};\n","import type { DOMElement, DOMNode, DOMText } from '@platejs/slate';\n\nconst getDefaultView = (value: any): Window | null => {\n  return value?.ownerDocument?.defaultView || null;\n};\n\n/** Check if a DOM node is an element node. */\n\nconst isDOMElement = (value: any): value is DOMElement => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n\n/** Check if a value is a DOM node. */\n\nconst isDOMNode = (value: any): value is DOMNode => {\n  const window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n\n/** Check if a DOM node is an element node. */\nconst isDOMText = (value: any): value is DOMText => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n\nexport const getPlainText = (domNode: DOMNode) => {\n  let text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (const childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n\n    const display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n","import { DOMPlugin } from '../../plugins';\nimport { getPlainText } from '../internal/getPlainText';\nimport { getSelectedDomFragment } from '../utils/getSelectedDomFragment';\nimport { getSelectedDomNode } from '../utils/getSelectedDomNode';\nimport { isSelectOutside } from '../utils/isSelectOutside';\n\nexport const ViewPlugin = DOMPlugin.extendEditorApi(({ editor }) => ({\n  getFragment() {\n    return getSelectedDomFragment(editor);\n  },\n})).overrideEditor(({ editor, tf: { setFragmentData } }) => ({\n  transforms: {\n    setFragmentData(data, originEvent) {\n      if (originEvent !== 'copy') return setFragmentData(data, originEvent);\n\n      const fragment = getSelectedDomFragment(editor);\n      const html = getSelectedDomNode();\n\n      if (!html || !fragment) return;\n\n      const selectOutside = isSelectOutside(html);\n\n      if (selectOutside) return;\n\n      // only crossing multiple blocks\n      if (fragment.length > 0) {\n        const string = JSON.stringify(fragment);\n        const encoded = window.btoa(encodeURIComponent(string));\n\n        data.setData('application/x-slate-fragment', encoded);\n        data.setData('text/html', html.innerHTML);\n        data.setData('text/plain', getPlainText(html));\n      }\n    },\n  },\n}));\n","import { ViewPlugin } from './ViewPlugin';\n\nexport const getStaticPlugins = () => {\n  const staticPlugins = [ViewPlugin];\n\n  return [...staticPlugins];\n};\n","/** Get slate class name: slate-<type> */\nexport const getSlateClass = (type?: string) => (type ? `slate-${type}` : '');\n","import type { Editor } from '@platejs/slate';\n\nimport { IS_APPLE } from '@udecode/utils';\nimport { type KeyboardEventLike, isKeyHotkey } from 'is-hotkey';\n\nexport { isHotkey } from 'is-hotkey';\n\n/** Hotkey mappings for each platform. */\nconst HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  escape: 'escape',\n  extendBackward: 'shift+left',\n  extendDownward: 'shift+down',\n  extendForward: 'shift+right',\n  extendUpward: 'shift+up',\n  insertSoftBreak: 'shift+enter',\n  italic: 'mod+i',\n  moveBackward: 'left',\n  moveDownward: 'down',\n  moveForward: 'right',\n  moveUpward: 'up',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  selectAll: 'mod+a',\n  splitBlock: 'enter',\n  tab: 'tab',\n  undo: 'mod+z',\n  untab: 'shift+tab',\n};\n\nconst APPLE_HOTKEYS = {\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n};\n\nconst WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n};\n\n/** Create a platform-aware hotkey checker. */\n\nexport const createHotkey = (key: string) => {\n  const generic = (HOTKEYS as any)[key];\n  const apple = (APPLE_HOTKEYS as any)[key];\n  const windows = (WINDOWS_HOTKEYS as any)[key];\n  const isGeneric = generic && isKeyHotkey(generic);\n  const isApple = apple && isKeyHotkey(apple);\n  const isWindows = windows && isKeyHotkey(windows);\n\n  return (event: KeyboardEventLike) => {\n    if (isGeneric?.(event)) return true;\n    if (IS_APPLE && isApple?.(event)) return true;\n    if (!IS_APPLE && isWindows?.(event)) return true;\n\n    return false;\n  };\n};\n\nconst createComposing =\n  (key: string) =>\n  (\n    editor: Editor,\n    event: React.KeyboardEvent,\n    {\n      composing,\n    }: {\n      /** Ignore the event if composing. */\n      composing?: boolean;\n    } = {}\n  ) => {\n    if (!createHotkey(key)(event)) return false;\n    if (!!composing !== editor.api.isComposing()) return false;\n\n    return true;\n  };\n\nexport const Hotkeys = {\n  isBold: createHotkey('bold'),\n  isCompose: createHotkey('compose'),\n  isDeleteBackward: createHotkey('deleteBackward'),\n  isDeleteForward: createHotkey('deleteForward'),\n  isDeleteLineBackward: createHotkey('deleteLineBackward'),\n  isDeleteLineForward: createHotkey('deleteLineForward'),\n  isDeleteWordBackward: createHotkey('deleteWordBackward'),\n  isDeleteWordForward: createHotkey('deleteWordForward'),\n  isEscape: createHotkey('escape'),\n  isExtendBackward: createHotkey('extendBackward'),\n  isExtendDownward: createHotkey('extendDownward'),\n  isExtendForward: createHotkey('extendForward'),\n  isExtendLineBackward: createHotkey('extendLineBackward'),\n  isExtendLineForward: createHotkey('extendLineForward'),\n  isExtendUpward: createHotkey('extendUpward'),\n  isItalic: createHotkey('italic'),\n  isMoveBackward: createHotkey('moveBackward'),\n  isMoveDownward: createHotkey('moveDownward'),\n  isMoveForward: createHotkey('moveForward'),\n  isMoveLineBackward: createHotkey('moveLineBackward'),\n  isMoveLineForward: createHotkey('moveLineForward'),\n  isMoveUpward: createHotkey('moveUpward'),\n  isMoveWordBackward: createHotkey('moveWordBackward'),\n  isMoveWordForward: createHotkey('moveWordForward'),\n  isRedo: createHotkey('redo'),\n  isSelectAll: createHotkey('selectAll'),\n  isSoftBreak: createHotkey('insertSoftBreak'),\n  isSplitBlock: createHotkey('splitBlock'),\n  isTab: createComposing('tab'),\n  isTransposeCharacter: createHotkey('transposeCharacter'),\n  isUndo: createHotkey('undo'),\n  isUntab: createComposing('untab'),\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { SlateEditor } from '../editor';\n\n/** Does the node match the type provided. */\nexport const isType = (\n  editor: SlateEditor,\n  node: any,\n  key?: string[] | string\n) => {\n  const keys = castArray(key);\n  const types: string[] = [];\n\n  keys.forEach((_key) => types.push(editor.getType(_key)));\n\n  return types.includes(node?.type);\n};\n","import type { TNode } from '@platejs/slate';\n\nimport merge from 'lodash/merge.js';\n\nimport {\n  type ApplyDeepToNodesOptions,\n  applyDeepToNodes,\n} from './applyDeepToNodes';\n\n/** Recursively merge a source object to children nodes with a query. */\nexport const mergeDeepToNodes = <N extends TNode>(\n  options: Omit<ApplyDeepToNodesOptions<N>, 'apply'>\n) => {\n  applyDeepToNodes({ ...options, apply: merge });\n};\n","import type { AnySlatePlugin, SlatePluginContext } from '../plugin';\n\nexport const omitPluginContext = <T extends SlatePluginContext<AnySlatePlugin>>(\n  ctx: T\n) => {\n  const {\n    api,\n    editor,\n    getOption,\n    getOptions,\n    plugin,\n    setOption,\n    setOptions,\n    tf,\n    type,\n    ...rest\n  } = ctx;\n\n  return rest;\n};\n","import defaultsDeep from 'lodash/defaultsDeep.js';\n\nimport type { AnySlatePlugin } from '../plugin/SlatePlugin';\n\n/**\n * Recursive deep merge of each plugin from `override.plugins` into plugin with\n * same key (plugin > plugin.plugins).\n */\nexport const overridePluginsByKey = (\n  plugin: AnySlatePlugin,\n  overrideByKey: Record<string, Partial<AnySlatePlugin>> = {},\n  nested = false\n): AnySlatePlugin => {\n  if (overrideByKey[plugin.key]) {\n    const {\n      __extensions: pluginOverridesExtensions,\n      plugins: pluginOverridesPlugins,\n      ...pluginOverrides\n    } = overrideByKey[plugin.key];\n\n    // Override plugin\n    plugin = defaultsDeep({}, pluginOverrides, plugin);\n\n    // Merge __extensions\n    if (pluginOverridesExtensions) {\n      plugin.__extensions = [\n        ...(plugin.__extensions || []),\n        ...pluginOverridesExtensions,\n      ];\n    }\n    if (!nested) {\n      // Concat new pluginOverrides.plugins to plugin.plugins\n      pluginOverridesPlugins?.forEach((pOverrides) => {\n        if (!plugin.plugins) plugin.plugins = [];\n\n        const found = plugin.plugins.find((p) => p.key === pOverrides.key);\n\n        if (!found) plugin.plugins.push(pOverrides);\n      });\n    }\n  }\n  if (plugin.plugins) {\n    // Override plugin.plugins\n    plugin.plugins = plugin.plugins.map((p) =>\n      overridePluginsByKey(p, overrideByKey, true)\n    );\n  }\n\n  return plugin;\n};\n","import type { SlateEditor } from '../editor';\nimport type { ParserOptions } from '../plugin/BasePlugin';\nimport type { AnyEditorPlugin } from '../plugin/SlatePlugin';\n\nimport { getEditorPlugin } from '../plugin';\n\n/** Is the plugin disabled by another plugin. */\nexport const pipeInsertDataQuery = (\n  editor: SlateEditor,\n  plugins: Partial<AnyEditorPlugin>[],\n  options: ParserOptions\n) =>\n  plugins.every((p) => {\n    const query = p.parser?.query;\n\n    return (\n      !query ||\n      query({\n        ...getEditorPlugin(editor, p as any),\n        ...options,\n      })\n    );\n  });\n","import { pipeInsertFragment } from '../../internal/plugin/pipeInsertFragment';\nimport { pipeTransformData } from '../../internal/plugin/pipeTransformData';\nimport { pipeTransformFragment } from '../../internal/plugin/pipeTransformFragment';\nimport { type Parser, createSlatePlugin, getEditorPlugin } from '../plugin';\nimport { getInjectedPlugins } from '../utils';\nimport { pipeInsertDataQuery } from '../utils/pipeInsertDataQuery';\n\nexport const ParserPlugin = createSlatePlugin({\n  key: 'parser',\n}).overrideEditor(({ editor, tf: { insertData } }) => ({\n  transforms: {\n    insertData(dataTransfer: DataTransfer) {\n      const inserted = [...editor.meta.pluginList].reverse().some((plugin) => {\n        const parser = plugin.parser as Parser | undefined;\n\n        if (!parser) return false;\n\n        const injectedPlugins = getInjectedPlugins(editor, plugin);\n        const { deserialize, format, mimeTypes } = parser;\n\n        if (!format && !mimeTypes) return false;\n\n        // Handle both string and string[] formats\n        const formats = Array.isArray(format) ? format : format ? [format] : [];\n        const mimeTypeList =\n          mimeTypes ||\n          formats.map((fmt) => (fmt.includes('/') ? fmt : `text/${fmt}`));\n\n        for (const mimeType of mimeTypeList) {\n          let data = dataTransfer.getData(mimeType);\n\n          if (\n            (mimeType !== 'Files' && !data) ||\n            (mimeType === 'Files' && dataTransfer.files.length === 0)\n          )\n            continue;\n          if (\n            !pipeInsertDataQuery(editor, injectedPlugins, {\n              data,\n              dataTransfer,\n              mimeType,\n            })\n          ) {\n            continue;\n          }\n\n          data = pipeTransformData(editor, injectedPlugins, {\n            data,\n            dataTransfer,\n            mimeType,\n          });\n\n          let fragment = deserialize?.({\n            ...getEditorPlugin(editor, plugin),\n            data,\n            dataTransfer,\n            mimeType,\n          });\n\n          if (!fragment?.length) continue;\n\n          fragment = pipeTransformFragment(editor, injectedPlugins, {\n            data,\n            dataTransfer,\n            fragment,\n            mimeType,\n          });\n\n          if (fragment.length === 0) continue;\n\n          pipeInsertFragment(editor, injectedPlugins, {\n            data,\n            dataTransfer,\n            fragment,\n            mimeType,\n          });\n\n          return true;\n        }\n\n        return false;\n      });\n\n      if (inserted) return;\n\n      insertData(dataTransfer);\n    },\n  },\n}));\n","/* eslint-disable perfectionist/sort-imports */\nimport type { AnyPluginConfig, PluginConfig } from '../plugin/BasePlugin';\nimport type { SlatePlugin } from '../plugin/SlatePlugin';\n\nimport { AstPlugin } from './AstPlugin';\nimport { HistoryPlugin } from './HistoryPlugin';\nimport { OverridePlugin } from './override/OverridePlugin';\nimport { ParserPlugin } from './ParserPlugin';\nimport { type DebugErrorType, type LogLevel, DebugPlugin } from './debug';\nimport { DOMPlugin } from './dom';\nimport { HtmlPlugin } from './html';\nimport { LengthPlugin } from './length';\nimport { AffinityPlugin } from './affinity';\nimport { type NodeIdConfig, NodeIdPlugin } from './node-id/NodeIdPlugin';\nimport { BaseParagraphPlugin } from './paragraph';\nimport {\n  type SlateExtensionConfig,\n  SlateExtensionPlugin,\n} from './slate-extension';\nimport { type ChunkingConfig, ChunkingPlugin } from './chunking/ChunkingPlugin';\n\nexport type CorePlugin = ReturnType<typeof getCorePlugins>[number];\n\nexport type GetCorePluginsOptions = {\n  /** Enable mark/element affinity. */\n  affinity?: boolean;\n  /** Configure Slate's chunking optimization. */\n  chunking?: ChunkingConfig['options'] | boolean;\n  /** Specifies the maximum number of characters allowed in the editor. */\n  maxLength?: number;\n  /** Configure the node id plugin. */\n  nodeId?: NodeIdConfig['options'] | boolean;\n  /** Override the core plugins using the same key. */\n  plugins?: AnyPluginConfig[];\n};\n\nexport const getCorePlugins = ({\n  affinity,\n  chunking,\n  maxLength,\n  nodeId,\n  plugins = [],\n}: GetCorePluginsOptions) => {\n  // Disable nodeId by default in test environment for deterministic tests\n  let resolvedNodeId: any = nodeId;\n  if (process.env.NODE_ENV === 'test' && nodeId === undefined) {\n    resolvedNodeId = false;\n  }\n\n  let corePlugins = [\n    DebugPlugin as SlatePlugin<DebugConfig>,\n    SlateExtensionPlugin,\n    DOMPlugin,\n    HistoryPlugin,\n    OverridePlugin,\n    ParserPlugin,\n    maxLength\n      ? LengthPlugin.configure({ options: { maxLength } })\n      : LengthPlugin,\n    HtmlPlugin,\n    AstPlugin,\n    NodeIdPlugin.configure({\n      enabled: resolvedNodeId !== false,\n      options: resolvedNodeId === false ? undefined : resolvedNodeId,\n    }),\n    AffinityPlugin.configure({ enabled: affinity }),\n    BaseParagraphPlugin,\n    ChunkingPlugin.configure({\n      enabled: chunking !== false,\n      options: typeof chunking === 'boolean' ? undefined : chunking,\n    }),\n  ];\n\n  // Create a map for quick lookup of custom plugins\n  const customPluginsMap = new Map(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n\n  // Replace core plugins with custom plugins if they exist and remove them from plugins\n  corePlugins = corePlugins.map((corePlugin) => {\n    const customPlugin = customPluginsMap.get(corePlugin.key);\n\n    if (customPlugin) {\n      // Remove the custom plugin from the plugins array\n      const index = plugins.findIndex((p) => p.key === corePlugin.key);\n\n      if (index !== -1) {\n        plugins.splice(index, 1);\n      }\n\n      return customPlugin;\n    }\n\n    return corePlugin as any;\n  });\n\n  return corePlugins;\n};\n\nexport type CorePluginTransforms = SlateExtensionConfig['transforms'];\nexport type CorePluginApi = SlateExtensionConfig['api'];\n\nexport type DebugConfig = PluginConfig<\n  'debug',\n  {\n    isProduction: boolean;\n    logger: Partial<Record<LogLevel, LogFunction>>;\n    logLevel: LogLevel;\n    throwErrors: boolean;\n  },\n  {\n    debug: {\n      error: (\n        message: string | unknown,\n        type?: DebugErrorType,\n        details?: any\n      ) => void;\n      info: (message: string, type?: DebugErrorType, details?: any) => void;\n      log: (message: string, type?: DebugErrorType, details?: any) => void;\n      warn: (message: string, type?: DebugErrorType, details?: any) => void;\n    };\n  }\n>;\n\nexport type LengthConfig = PluginConfig<\n  'length',\n  {\n    maxLength: number;\n  }\n>;\n\ntype LogFunction = (\n  message: string,\n  type?: DebugErrorType,\n  details?: any\n) => void;\n","export { nanoid } from 'nanoid';\n","export type { TStateApi as ZustandStoreApi } from 'zustand-x';\n\nexport { createZustandStore } from 'zustand-x';\n"],"mappings":"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","names":["import_slate","import_nanoid","import_utils","import_merge","mergeWith","config","result","merge","merge","import_slate","import_slate","import_slate","import_slate","import_slate","import_slate","defaults","import_slate","import_react","React","SlateElement","import_react","import_react","React","import_slate","kebabCase","import_clsx","import_clsx","import_utils","clsx","clsx","node","import_slate","React","plugin","Component","React","plugin","import_react","import_clsx","import_react","import_slate","import_clsx","import_react","import_clsx","React","render","clsx","React","clsx","React","render","clsx","import_react","React","import_slate","import_slate","import_slate","import_slate","isEqual","import_slate","import_slate","beforeEnd","import_slate","import_utils","omitBy","isUndefined","import_utils","import_slate","import_slate_hyperscript","import_utils","castArray","import_slate","import_slate_hyperscript","document","import_slate","import_slate","import_utils","import_castArray","cloneDeep","castArray","node","entry","import_slate","import_utils","import_slate","import_slate","window","pick","import_utils","import_is_hotkey","import_castArray","castArray","import_merge","merge","defaultsDeep","import_nanoid","import_zustand_x"]}