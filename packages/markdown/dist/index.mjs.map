{"version":3,"sources":["../../../node_modules/lodash/_arrayReduce.js","../../../node_modules/lodash/_basePropertyOf.js","../../../node_modules/lodash/_deburrLetter.js","../../../node_modules/lodash/_freeGlobal.js","../../../node_modules/lodash/_root.js","../../../node_modules/lodash/_Symbol.js","../../../node_modules/lodash/_arrayMap.js","../../../node_modules/lodash/isArray.js","../../../node_modules/lodash/_getRawTag.js","../../../node_modules/lodash/_objectToString.js","../../../node_modules/lodash/_baseGetTag.js","../../../node_modules/lodash/isObjectLike.js","../../../node_modules/lodash/isSymbol.js","../../../node_modules/lodash/_baseToString.js","../../../node_modules/lodash/toString.js","../../../node_modules/lodash/deburr.js","../../../node_modules/lodash/_asciiWords.js","../../../node_modules/lodash/_hasUnicodeWord.js","../../../node_modules/lodash/_unicodeWords.js","../../../node_modules/lodash/words.js","../../../node_modules/lodash/_createCompounder.js","../../../node_modules/lodash/kebabCase.js","../src/lib/MarkdownPlugin.ts","../src/lib/types.ts","../src/lib/deserializer/utils/customMdxDeserialize.ts","../src/lib/rules/defaultRules.ts","../src/lib/serializer/convertNodesSerialize.ts","../src/lib/serializer/convertTextsSerialize.ts","../src/lib/serializer/utils/getCustomMark.ts","../src/lib/rules/columnRules.ts","../src/lib/rules/utils/parseAttributes.ts","../src/lib/rules/fontRules.ts","../src/lib/rules/mediaRules.ts","../src/lib/serializer/utils/getMergedOptionsSerialize.ts","../src/lib/serializer/utils/getSerializerByKey.ts","../src/lib/serializer/utils/unreachable.ts","../src/lib/serializer/listToMdastTree.ts","../src/lib/serializer/serializeInlineMd.ts","../src/lib/serializer/serializeMd.ts","../src/lib/deserializer/utils/getDeserializerByKey.ts","../src/lib/deserializer/utils/deserializeInlineMd.ts","../src/lib/deserializer/utils/stripMarkdown.ts","../src/lib/utils/getRemarkPluginsWithoutMdx.ts","../src/lib/deserializer/utils/getMergedOptionsDeserialize.ts","../src/lib/deserializer/utils/getStyleValue.ts","../src/lib/deserializer/utils/markdownToSlateNodesSafely.ts","../src/lib/deserializer/deserializeMd.ts","../src/lib/deserializer/mdastToSlate.ts","../src/lib/deserializer/utils/splitIncompleteMdx.ts","../src/lib/deserializer/utils/parseMarkdownBlocks.ts","../src/lib/deserializer/convertNodesDeserialize.ts","../src/lib/deserializer/convertChildrenDeserialize.ts","../src/lib/deserializer/convertTextsDeserialize.ts","../src/lib/plugins/remarkMdx.ts","../../../node_modules/unist-util-is/lib/index.js","../../../node_modules/unist-util-visit-parents/lib/color.node.js","../../../node_modules/unist-util-visit-parents/lib/index.js","../../../node_modules/unist-util-visit/lib/index.js","../src/lib/plugins/remarkMention.ts"],"sourcesContent":["/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function(key) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = basePropertyOf;\n","var basePropertyOf = require('./_basePropertyOf');\n\n/** Used to map Latin Unicode letters to basic Latin letters. */\nvar deburredLetters = {\n  // Latin-1 Supplement block.\n  '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n  '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n  '\\xc7': 'C',  '\\xe7': 'c',\n  '\\xd0': 'D',  '\\xf0': 'd',\n  '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n  '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n  '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n  '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n  '\\xd1': 'N',  '\\xf1': 'n',\n  '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n  '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n  '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n  '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n  '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n  '\\xc6': 'Ae', '\\xe6': 'ae',\n  '\\xde': 'Th', '\\xfe': 'th',\n  '\\xdf': 'ss',\n  // Latin Extended-A block.\n  '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n  '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n  '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n  '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n  '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n  '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n  '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n  '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n  '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n  '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n  '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n  '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n  '\\u0134': 'J',  '\\u0135': 'j',\n  '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n  '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n  '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n  '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n  '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n  '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n  '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n  '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n  '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n  '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n  '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n  '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n  '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n  '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n  '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n  '\\u0174': 'W',  '\\u0175': 'w',\n  '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n  '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n  '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n  '\\u0132': 'IJ', '\\u0133': 'ij',\n  '\\u0152': 'Oe', '\\u0153': 'oe',\n  '\\u0149': \"'n\", '\\u017f': 's'\n};\n\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */\nvar deburrLetter = basePropertyOf(deburredLetters);\n\nmodule.exports = deburrLetter;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var deburrLetter = require('./_deburrLetter'),\n    toString = require('./toString');\n\n/** Used to match Latin Unicode letters (excluding mathematical operators). */\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n/** Used to compose unicode character classes. */\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\n\n/** Used to compose unicode capture groups. */\nvar rsCombo = '[' + rsComboRange + ']';\n\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */\nvar reComboMark = RegExp(rsCombo, 'g');\n\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('déjà vu');\n * // => 'deja vu'\n */\nfunction deburr(string) {\n  string = toString(string);\n  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n}\n\nmodule.exports = deburr;\n","/** Used to match words composed of alphanumeric characters. */\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction asciiWords(string) {\n  return string.match(reAsciiWord) || [];\n}\n\nmodule.exports = asciiWords;\n","/** Used to detect strings that need a more robust regexp to match words. */\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */\nfunction hasUnicodeWord(string) {\n  return reHasUnicodeWord.test(string);\n}\n\nmodule.exports = hasUnicodeWord;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsDingbatRange = '\\\\u2700-\\\\u27bf',\n    rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n    rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n    rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n    rsPunctuationRange = '\\\\u2000-\\\\u206f',\n    rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n    rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n    rsVarRange = '\\\\ufe0e\\\\ufe0f',\n    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nvar rsApos = \"['\\u2019]\",\n    rsBreak = '[' + rsBreakRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsDigits = '\\\\d+',\n    rsDingbat = '[' + rsDingbatRange + ']',\n    rsLower = '[' + rsLowerRange + ']',\n    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsUpper = '[' + rsUpperRange + ']',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n    reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n    rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;\n\n/** Used to match complex or compound words. */\nvar reUnicodeWord = RegExp([\n  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n  rsUpper + '+' + rsOptContrUpper,\n  rsOrdUpper,\n  rsOrdLower,\n  rsDigits,\n  rsEmoji\n].join('|'), 'g');\n\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction unicodeWords(string) {\n  return string.match(reUnicodeWord) || [];\n}\n\nmodule.exports = unicodeWords;\n","var asciiWords = require('./_asciiWords'),\n    hasUnicodeWord = require('./_hasUnicodeWord'),\n    toString = require('./toString'),\n    unicodeWords = require('./_unicodeWords');\n\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */\nfunction words(string, pattern, guard) {\n  string = toString(string);\n  pattern = guard ? undefined : pattern;\n\n  if (pattern === undefined) {\n    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n  }\n  return string.match(pattern) || [];\n}\n\nmodule.exports = words;\n","var arrayReduce = require('./_arrayReduce'),\n    deburr = require('./deburr'),\n    words = require('./words');\n\n/** Used to compose unicode capture groups. */\nvar rsApos = \"['\\u2019]\";\n\n/** Used to match apostrophes. */\nvar reApos = RegExp(rsApos, 'g');\n\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */\nfunction createCompounder(callback) {\n  return function(string) {\n    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n  };\n}\n\nmodule.exports = createCompounder;\n","var createCompounder = require('./_createCompounder');\n\n/**\n * Converts `string` to\n * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the kebab cased string.\n * @example\n *\n * _.kebabCase('Foo Bar');\n * // => 'foo-bar'\n *\n * _.kebabCase('fooBar');\n * // => 'foo-bar'\n *\n * _.kebabCase('__FOO_BAR__');\n * // => 'foo-bar'\n */\nvar kebabCase = createCompounder(function(result, word, index) {\n  return result + (index ? '-' : '') + word.toLowerCase();\n});\n\nmodule.exports = kebabCase;\n","import type { Plugin } from 'unified';\n\nimport {\n  type OmitFirst,\n  type PluginConfig,\n  bindFirst,\n  createTSlatePlugin,\n  isUrl,\n  KEYS,\n} from 'platejs';\n\nimport type { MdRules, PlateType } from './types';\n\nimport { deserializeInlineMd, deserializeMd } from './deserializer';\nimport { serializeMd } from './serializer';\n\nexport type AllowNodeConfig = {\n  /** Custom filter function for nodes during deserialization */\n  deserialize?: (node: any) => boolean;\n  /** Custom filter function for nodes during serialization */\n  serialize?: (node: any) => boolean;\n};\n\nexport type MarkdownConfig = PluginConfig<\n  'markdown',\n  {\n    /**\n     * Configuration for allowed node types. Cannot be combined with\n     * disallowedNodes.\n     */\n    allowedNodes: PlateType[] | null;\n    /**\n     * Configuration for disallowed node types. Cannot be combined with\n     * allowedNodes.\n     *\n     * @default null\n     */\n    disallowedNodes: PlateType[] | null;\n    /**\n     * Array of remark plugins to extend Markdown parsing and serialization\n     * functionality. For example, you can add remark-gfm to support GFM syntax,\n     * remark-math to support mathematical formulas, etc. These plugins will be\n     * used during the parsing and generation of Markdown text.\n     *\n     * @default undefined\n     */\n    remarkPlugins: Plugin[];\n    /**\n     * Rules that define how to convert Markdown syntax elements to Slate editor\n     * elements. Or rules that how to convert Slate editor elements to Markdown\n     * syntax elements. Includes conversion rules for elements such as\n     * paragraphs, headings, lists, links, images, etc.\n     *\n     * You can pass null disable default node parser.\n     *\n     * NOTE: don't forget pass `mark:true` when you custom inline nodes.\n     *\n     * @default null\n     */\n    rules: MdRules | null;\n    /**\n     * Custom filter function for nodes during deserialization and\n     * serialization.\n     *\n     * @default null\n     */\n    allowNode?: AllowNodeConfig;\n  },\n  {\n    markdown: {\n      deserialize: OmitFirst<typeof deserializeMd>;\n      deserializeInline: OmitFirst<typeof deserializeInlineMd>;\n      serialize: OmitFirst<typeof serializeMd>;\n    };\n  }\n>;\n\nexport const MarkdownPlugin = createTSlatePlugin<MarkdownConfig>({\n  key: KEYS.markdown,\n  options: {\n    allowedNodes: null,\n    disallowedNodes: null,\n    remarkPlugins: [],\n    rules: null,\n  },\n})\n  .extendApi(({ editor }) => ({\n    deserialize: bindFirst(deserializeMd, editor),\n    deserializeInline: bindFirst(deserializeInlineMd, editor),\n    serialize: bindFirst(serializeMd, editor),\n  }))\n  .extend(({ api }) => ({\n    parser: {\n      format: 'text/plain',\n      deserialize: ({ data }) => api.markdown.deserialize(data),\n      query: ({ data, dataTransfer }) => {\n        const htmlData = dataTransfer.getData('text/html');\n\n        if (htmlData) return false;\n\n        const { files } = dataTransfer;\n\n        if (\n          !files?.length && // if content is simply a URL pass through to not break LinkPlugin\n          isUrl(data)\n        ) {\n          return false;\n        }\n\n        return true;\n      },\n    },\n  }));\n","/* eslint-disable perfectionist/sort-object-types */\n\nexport type * as unistLib from 'unist';\n\nimport type { StrictExtract } from 'ts-essentials';\n\nimport {\n  type NodeKey,\n  type Nullable,\n  type SlateEditor,\n  type TElement,\n  type TNodeMap,\n  type TText,\n  getPluginKey,\n} from 'platejs';\n\nimport type { DeserializeMdOptions } from './deserializer';\nimport type {\n  MdBlockquote,\n  MdBreak,\n  MdCode,\n  MdDefinition,\n  MdDelete,\n  MdEmphasis,\n  MdFootnoteDefinition,\n  MdFootnoteReference,\n  MdHeading,\n  MdHtml,\n  MdImage,\n  MdImageReference,\n  MdInlineCode,\n  MdInlineMath,\n  MdLink,\n  MdLinkReference,\n  MdList,\n  MdMath,\n  MdParagraph,\n  MdRootContent,\n  MdStrong,\n  MdTable,\n  MdTableCell,\n  MdTableRow,\n  MdText,\n  MdThematicBreak,\n  MdYaml,\n} from './mdast';\nimport type { SerializeMdOptions } from './serializer';\n\nimport 'mdast-util-mdx';\n\nexport type MdRules = Partial<{\n  [K in keyof PlateNodeMap]: Nullable<MdNodeParser<K>>;\n}> &\n  Record<string, Nullable<AnyNodeParser>>;\n\nexport type MdNodeParser<K extends keyof PlateNodeMap> = {\n  mark?: boolean;\n  deserialize?: (\n    mdastNode: MdNodeMap[K],\n    deco: MdDecoration,\n    options: DeserializeMdOptions\n  ) => PlateNodeMap[K];\n  serialize?: (\n    slateNode: PlateNodeMap[K],\n    options: SerializeMdOptions\n  ) => MdNodeMap[K];\n};\n\ntype AnyNodeParser = {\n  mark?: boolean;\n  deserialize?: (\n    mdastNode: any,\n    deco: MdDecoration,\n    options: DeserializeMdOptions\n  ) => any;\n  serialize?: (slateNode: any, options: SerializeMdOptions) => any;\n};\n\ntype StrictMdType = MdGFM | MdRootContent['type'] | MdStyle;\n\nexport type MdType = (string & {}) | StrictMdType;\n\ntype MdGFM = 'del' | 'mark' | 'sub' | 'sup' | 'u';\n\ntype MdStyle =\n  | 'backgroundColor'\n  | 'color'\n  | 'fontFamily'\n  | 'fontSize'\n  | 'fontWeight';\n\nexport type MdMark = MdDelete | MdEmphasis | MdInlineCode | MdStrong | MdText;\n\nexport type MdDecoration = Readonly<\n  Partial<\n    Record<\n      | (string & {})\n      | (MdDelete | MdEmphasis | MdInlineCode | MdStrong)['type']\n      | MdStyle\n      | 'underline',\n      boolean | string\n    >\n  >\n>;\n\nexport type StrictPlateType =\n  | StrictExtract<\n      NodeKey,\n      | 'a'\n      | 'blockquote'\n      | 'bold'\n      | 'callout'\n      | 'code'\n      | 'code_block'\n      | 'code_line'\n      | 'column'\n      | 'column_group'\n      | 'comment'\n      | 'date'\n      | 'equation'\n      | 'hr'\n      | 'img'\n      | 'inline_equation'\n      | 'italic'\n      | 'li'\n      | 'mention'\n      | 'p'\n      | 'strikethrough'\n      | 'subscript'\n      | 'suggestion'\n      | 'superscript'\n      | 'table'\n      | 'td'\n      | 'th'\n      | 'toc'\n      | 'toggle'\n      | 'tr'\n      | 'underline'\n    >\n  | 'heading'\n  | 'list'\n  | 'text';\n\nexport type PlateType = (string & {}) | StrictPlateType;\n\ntype PlateNodeMap = Pick<\n  TNodeMap,\n  | 'a'\n  | 'audio'\n  | 'blockquote'\n  | 'bold'\n  | 'callout'\n  | 'code'\n  | 'code_block'\n  | 'column'\n  | 'column_group'\n  | 'comment'\n  | 'date'\n  | 'equation'\n  | 'file'\n  | 'hr'\n  | 'img'\n  | 'inline_equation'\n  | 'italic'\n  | 'mention'\n  | 'p'\n  | 'strikethrough'\n  | 'subscript'\n  | 'suggestion'\n  | 'superscript'\n  | 'table'\n  | 'td'\n  | 'th'\n  | 'toc'\n  | 'toggle'\n  | 'tr'\n  | 'underline'\n  | 'video'\n> & {\n  /** Markdown only */\n  text: TText;\n  list: any;\n  heading: TElement;\n  footnoteReference: any;\n  definition: any;\n  footnoteDefinition: any;\n  break: any;\n  yaml: any;\n  imageReference: any;\n  linkReference: any;\n  html: any;\n};\n\ntype MdNodeMap = {\n  /** Common Elements */\n  a: MdLink;\n  blockquote: MdBlockquote;\n  code_block: MdCode;\n  equation: MdMath;\n  heading: MdHeading;\n  hr: MdThematicBreak;\n  img: MdImage;\n  inline_equation: MdInlineMath;\n  p: MdParagraph;\n  table: MdTable;\n  td: MdTableCell;\n  th: MdTableCell;\n  tr: MdTableRow;\n  list: MdList;\n\n  /** Common Marks */\n  bold: MdStrong;\n  italic: MdEmphasis;\n  code: MdInlineCode;\n  text: MdText;\n  strikethrough: MdDelete;\n\n  /** Markdown only */\n  footnoteReference: MdFootnoteReference;\n  definition: MdDefinition;\n  footnoteDefinition: MdFootnoteDefinition;\n  break: MdBreak;\n  yaml: MdYaml;\n  imageReference: MdImageReference;\n  linkReference: MdLinkReference;\n  html: MdHtml;\n\n  /** Plate only */\n  column_group: any;\n  column: any;\n  toc: any;\n  callout: any;\n  toggle: any;\n  mention: any;\n  date: any;\n  underline: any;\n  comment: any;\n  superscript: any;\n  subscript: any;\n  suggestion: any;\n  file: any;\n  video: any;\n  audio: any;\n};\n\nconst PLATE_TO_MDAST = {\n  a: 'link',\n  blockquote: 'blockquote',\n  bold: 'strong',\n  callout: 'callout',\n  code: 'inlineCode',\n  code_block: 'code',\n  code_line: 'code_line',\n  column: 'column',\n  column_group: 'column_group',\n  comment: 'comment',\n  date: 'date',\n  equation: 'math',\n  heading: 'heading',\n  hr: 'thematicBreak',\n  img: 'image',\n  inline_equation: 'inlineMath',\n  italic: 'emphasis',\n  li: 'listItem',\n  list: 'list',\n  mention: 'mention',\n  p: 'paragraph',\n  strikethrough: 'delete',\n  subscript: 'sub',\n  suggestion: 'suggestion',\n  superscript: 'sup',\n  table: 'table',\n  td: 'tableCell',\n  text: 'text',\n  th: 'tableCell',\n  toc: 'toc',\n  toggle: 'toggle',\n  tr: 'tableRow',\n  underline: 'u',\n} as const satisfies Record<StrictPlateType, MdType>;\n\nconst MDAST_TO_PLATE = {\n  backgroundColor: 'backgroundColor',\n  blockquote: 'blockquote',\n  break: 'break',\n  code: 'code_block',\n  color: 'color',\n  definition: 'definition',\n  del: 'strikethrough',\n  delete: 'strikethrough',\n  emphasis: 'italic',\n  fontFamily: 'fontFamily',\n  fontSize: 'fontSize',\n  fontWeight: 'fontWeight',\n  footnoteDefinition: 'footnoteDefinition',\n  footnoteReference: 'footnoteReference',\n  heading: 'heading',\n  html: 'html',\n  image: 'img',\n  imageReference: 'imageReference',\n  inlineCode: 'code',\n  inlineMath: 'inline_equation',\n  link: 'a',\n  linkReference: 'linkReference',\n  list: 'list',\n  listItem: 'li',\n  mark: 'highlight',\n  math: 'equation',\n  mdxFlowExpression: 'mdxFlowExpression',\n  mdxjsEsm: 'mdxjsEsm',\n  mdxJsxFlowElement: 'mdxJsxFlowElement',\n  mdxJsxTextElement: 'mdxJsxTextElement',\n  mdxTextExpression: 'mdxTextExpression',\n  paragraph: 'p',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  table: 'table',\n  tableCell: 'td',\n  tableRow: 'tr',\n  text: 'text',\n  thematicBreak: 'hr',\n  u: 'underline',\n  yaml: 'yaml',\n} as const satisfies Record<StrictMdType, PlateType>;\n\n/**\n * Get plate node type from mdast node type if the mdast is mdast only return\n * the mdast type itself.\n */\nexport const mdastToPlate = <T extends StrictMdType>(\n  editor: SlateEditor,\n  mdastType: T\n) => {\n  const plateKey = MDAST_TO_PLATE[mdastType];\n\n  return getPluginKey(editor, plateKey) ?? plateKey ?? mdastType;\n};\n\n/**\n * Get mdast node type from plate element type if the plateType is plate only\n * return the plateType itself.\n */\nexport const plateToMdast = <T extends StrictPlateType>(plateType: T) => {\n  return PLATE_TO_MDAST[plateType] ?? plateType;\n};\n","import type { MdxJsxFlowElement, MdxJsxTextElement } from 'mdast-util-mdx';\n\nimport { getPluginKey, getPluginType, KEYS } from 'platejs';\n\nimport type { MdDecoration } from '../../types';\nimport type { DeserializeMdOptions } from '../deserializeMd';\n\nimport { mdastToPlate } from '../../types';\nimport { convertChildrenDeserialize } from '../convertChildrenDeserialize';\nimport { getDeserializerByKey } from './getDeserializerByKey';\n\nexport const customMdxDeserialize = (\n  mdastNode: MdxJsxFlowElement | MdxJsxTextElement,\n  deco: MdDecoration,\n  options: DeserializeMdOptions\n) => {\n  const customJsxElementKey = mdastNode.name;\n\n  const key =\n    getPluginKey(options.editor!, customJsxElementKey as any) ?? mdastNode.name;\n\n  if (key) {\n    const nodeParserDeserialize = getDeserializerByKey(\n      mdastToPlate(options.editor!, key as any),\n      options\n    );\n\n    if (nodeParserDeserialize)\n      return nodeParserDeserialize(mdastNode, deco, options) as any;\n  } else {\n    console.warn(\n      'This MDX node does not have a parser for deserialization',\n      mdastNode\n    );\n  }\n\n  // Default fallback: preserve tag structure as text\n  if (mdastNode.type === 'mdxJsxTextElement') {\n    const tagName = mdastNode.name;\n    let textContent = '';\n\n    if (mdastNode.children) {\n      textContent = mdastNode.children\n        .map((child) => {\n          if ('value' in child) return child.value;\n          return '';\n        })\n        .join('');\n    }\n\n    return [\n      {\n        text: `<${tagName}>${textContent}</${tagName}>`,\n      },\n    ];\n  }\n\n  if (mdastNode.type === 'mdxJsxFlowElement') {\n    const tagName = mdastNode.name;\n\n    // Return as a paragraph with the tag structure preserved\n    return [\n      {\n        children: [\n          {\n            text: `<${tagName}>\\n`,\n          },\n          ...convertChildrenDeserialize(mdastNode.children, deco, options),\n          {\n            text: `\\n</${tagName}>`,\n          },\n        ],\n        type: getPluginType(options.editor!, KEYS.p),\n      },\n    ];\n  }\n};\n","import {\n  type SlateEditor,\n  type TElement,\n  type TListElement,\n  type TMentionElement,\n  type TText,\n  getPluginKey,\n  getPluginType,\n  KEYS,\n} from 'platejs';\n\nimport type {\n  MdHeading,\n  MdImage,\n  MdLink,\n  MdList,\n  MdMdxJsxFlowElement,\n  MdMdxJsxTextElement,\n  MdParagraph,\n  MdRootContent,\n  MdTable,\n  MdTableCell,\n  MdTableRow,\n} from '../mdast';\nimport type { MentionNode } from '../plugins/remarkMention';\nimport type { MdRules } from '../types';\n\nimport {\n  buildSlateNode,\n  convertChildrenDeserialize,\n  convertTextsDeserialize,\n} from '../deserializer';\nimport { convertNodesSerialize } from '../serializer';\nimport { columnRules } from './columnRules';\nimport { fontRules } from './fontRules';\nimport { mediaRules } from './mediaRules';\n\nfunction isBoolean(value: any) {\n  return (\n    value === true ||\n    value === false ||\n    (!!value &&\n      typeof value == 'object' &&\n      Object.prototype.toString.call(value) == '[object Boolean]')\n  );\n}\n\nexport const defaultRules: MdRules = {\n  a: {\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        children: convertChildrenDeserialize(mdastNode.children, deco, options),\n        type: getPluginType(options.editor!, KEYS.a),\n        url: mdastNode.url,\n      };\n    },\n    serialize: (node, options) => {\n      return {\n        children: convertNodesSerialize(\n          node.children,\n          options\n        ) as MdLink['children'],\n        type: 'link',\n        url: node.url,\n      };\n    },\n  },\n  blockquote: {\n    deserialize: (mdastNode, deco, options) => {\n      const children =\n        mdastNode.children.length > 0\n          ? mdastNode.children.flatMap((paragraph, index, children) => {\n              if (paragraph.type === 'paragraph') {\n                if (children.length > 1 && children.length - 1 !== index) {\n                  // add a line break between the paragraphs\n                  const paragraphChildren = convertChildrenDeserialize(\n                    paragraph.children,\n                    deco,\n                    options\n                  );\n                  paragraphChildren.push({ text: '\\n' }, { text: '\\n' });\n                  return paragraphChildren;\n                }\n                return convertChildrenDeserialize(\n                  paragraph.children,\n                  deco,\n                  options\n                );\n              }\n\n              if ('children' in paragraph) {\n                return convertChildrenDeserialize(\n                  paragraph.children,\n                  deco,\n                  options\n                );\n              }\n\n              return [{ text: '' }];\n            })\n          : [{ text: '' }];\n\n      const flattenedChildren = children.flatMap((child: any) =>\n        child.type === 'blockquote' ? child.children : [child]\n      );\n\n      return {\n        children: flattenedChildren,\n        type: getPluginType(options.editor!, KEYS.blockquote),\n      };\n    },\n    serialize: (node, options) => {\n      const nodes = [] as any;\n\n      for (const child of node.children) {\n        if (child.text === '\\n') {\n          nodes.push({\n            type: 'break',\n          });\n        } else {\n          nodes.push(child);\n        }\n      }\n\n      const paragraphChildren = convertNodesSerialize(\n        nodes,\n        options\n      ) as MdParagraph['children'];\n\n      if (\n        paragraphChildren.length > 0 &&\n        paragraphChildren.at(-1)!.type === 'break'\n      ) {\n        // if the last child of the paragraph is a line break add an additional one\n\n        paragraphChildren.at(-1)!.type = 'html';\n        // @ts-expect-error -- value is ok\n        paragraphChildren.at(-1)!.value = '\\n<br />';\n      }\n\n      return {\n        children: [\n          {\n            children: paragraphChildren,\n            type: 'paragraph',\n          },\n        ],\n        type: 'blockquote',\n      };\n    },\n  },\n  bold: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertTextsDeserialize(mdastNode, deco, options);\n    },\n  },\n  br: {\n    deserialize() {\n      return [{ text: '\\n' }];\n    },\n  },\n  break: {\n    deserialize: (mdastNode, deco) => {\n      return {\n        text: '\\n',\n      };\n    },\n    serialize: () => {\n      return {\n        type: 'break',\n      };\n    },\n  },\n  callout: {\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        children: convertChildrenDeserialize(mdastNode.children, deco, options),\n        type: getPluginType(options.editor!, KEYS.callout),\n      };\n    },\n    serialize(slateNode, options): MdMdxJsxFlowElement {\n      return {\n        attributes: [],\n        children: convertNodesSerialize(slateNode.children, options) as any,\n        name: 'callout',\n        type: 'mdxJsxFlowElement',\n      };\n    },\n  },\n  code: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        ...deco,\n        [getPluginType(options.editor!, KEYS.code) as 'code']: true,\n        text: mdastNode.value,\n      };\n    },\n  },\n  code_block: {\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        children: (mdastNode.value || '').split('\\n').map((line) => ({\n          children: [{ text: line } as TText],\n          type: getPluginType(options.editor!, KEYS.codeLine),\n        })),\n        lang: mdastNode.lang ?? undefined,\n        type: getPluginType(options.editor!, KEYS.codeBlock),\n      };\n    },\n    serialize: (node) => {\n      return {\n        lang: node.lang,\n        type: 'code',\n        value: node.children\n          .map((child: any) =>\n            child?.children === undefined\n              ? child.text\n              : child.children.map((c: any) => c.text).join('')\n          )\n          .join('\\n'),\n      };\n    },\n  },\n  date: {\n    deserialize(mdastNode, deco, options) {\n      const dateValue = (mdastNode.children?.[0] as any)?.value || '';\n      return {\n        children: [{ text: '' }],\n        date: dateValue,\n        type: getPluginType(options.editor!, KEYS.date),\n      };\n    },\n    serialize({ date }): MdMdxJsxTextElement {\n      return {\n        attributes: [],\n        children: [{ type: 'text', value: date ?? '' }],\n        name: 'date',\n        type: 'mdxJsxTextElement',\n      };\n    },\n  },\n  del: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertChildrenDeserialize(\n        mdastNode.children,\n        { [getPluginType(options.editor!, KEYS.strikethrough)]: true, ...deco },\n        options\n      ) as any;\n    },\n    // no serialize because it's mdx <del /> only\n  },\n  equation: {\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        children: [{ text: '' }],\n        texExpression: mdastNode.value,\n        type: getPluginType(options.editor!, KEYS.equation),\n      };\n    },\n    serialize: (node) => {\n      return {\n        type: 'math',\n        value: node.texExpression,\n      };\n    },\n  },\n  // plate doesn't support footnoteDefinition and footnoteReference\n  // so we need to convert them to p for now\n  footnoteDefinition: {\n    deserialize: (mdastNode, deco, options) => {\n      const children = convertChildrenDeserialize(\n        mdastNode.children,\n        deco,\n        options\n      );\n\n      // Flatten nested paragraphs similar to blockquote implementation\n      const flattenedChildren = children.flatMap((child: any) =>\n        child.type === 'p' ? child.children : [child]\n      );\n\n      return {\n        children: flattenedChildren,\n        type: getPluginType(options.editor!, KEYS.p),\n      };\n    },\n  },\n  footnoteReference: {},\n  heading: {\n    deserialize: (mdastNode, deco, options) => {\n      const headingType = {\n        1: 'h1',\n        2: 'h2',\n        3: 'h3',\n        4: 'h4',\n        5: 'h5',\n        6: 'h6',\n      };\n\n      const defaultType = headingType[mdastNode.depth];\n\n      const type = getPluginType(options.editor!, defaultType);\n\n      return {\n        children: convertChildrenDeserialize(mdastNode.children, deco, options),\n        type,\n      };\n    },\n    serialize: (node, options) => {\n      const key = getPluginKey(options.editor!, node.type) ?? node.type;\n      const depthMap = {\n        h1: 1,\n        h2: 2,\n        h3: 3,\n        h4: 4,\n        h5: 5,\n        h6: 6,\n      };\n\n      return {\n        children: convertNodesSerialize(\n          node.children,\n          options\n        ) as MdHeading['children'],\n        depth: depthMap[key as keyof typeof depthMap] as any,\n        type: 'heading',\n      };\n    },\n  },\n  highlight: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertChildrenDeserialize(\n        mdastNode.children,\n        { [getPluginType(options.editor!, KEYS.highlight)]: true, ...deco },\n        options\n      ) as any;\n    },\n    serialize(slateNode): MdMdxJsxTextElement {\n      return {\n        attributes: [],\n        children: [{ type: 'text', value: slateNode.text }],\n        name: 'mark',\n        type: 'mdxJsxTextElement',\n      };\n    },\n  },\n  hr: {\n    deserialize: (_, __, options) => {\n      return {\n        children: [{ text: '' } as TText],\n        type: getPluginType(options.editor!, KEYS.hr),\n      };\n    },\n    serialize: () => {\n      return { type: 'thematicBreak' };\n    },\n  },\n  html: {\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        text: (mdastNode.value || '').replaceAll('<br />', '\\n'),\n      };\n    },\n  },\n  img: {\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        caption: [{ text: mdastNode.alt } as TText],\n        children: [{ text: '' } as TText],\n        type: getPluginType(options.editor!, KEYS.img),\n        url: mdastNode.url,\n      };\n    },\n    serialize: ({ caption, url }) => {\n      const image: MdImage = {\n        alt: caption ? caption.map((c) => (c as any).text).join('') : undefined,\n        title: caption\n          ? caption.map((c) => (c as any).text).join('')\n          : undefined,\n        type: 'image',\n        url,\n      };\n\n      // since plate is using block image so we need to wrap it in a paragraph\n      return { children: [image], type: 'paragraph' } as any;\n    },\n  },\n  inline_equation: {\n    deserialize(mdastNode, _, options) {\n      return {\n        children: [{ text: '' }],\n        texExpression: mdastNode.value,\n        type: getPluginType(options.editor!, KEYS.inlineEquation),\n      };\n    },\n    serialize: (node) => {\n      return {\n        type: 'inlineMath',\n        value: node.texExpression,\n      };\n    },\n  },\n  italic: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertTextsDeserialize(mdastNode, deco, options);\n    },\n  },\n  kbd: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertChildrenDeserialize(\n        mdastNode.children,\n        { [getPluginType(options.editor!, KEYS.kbd)]: true, ...deco },\n        options\n      ) as any;\n    },\n    serialize(slateNode, options): MdMdxJsxTextElement {\n      return {\n        attributes: [],\n        children: [{ type: 'text', value: slateNode.text }],\n        name: 'kbd',\n        type: 'mdxJsxTextElement',\n      };\n    },\n  },\n  list: {\n    deserialize: (mdastNode: MdList, deco, options) => {\n      // Handle standard list\n      const isIndentList = !!options.editor?.plugins.list;\n\n      if (!isIndentList) {\n        // For standard lists, we need to ensure each list item is properly structured\n        const children = mdastNode.children.map((child) => {\n          if (child.type === 'listItem') {\n            // Process each list item\n            return {\n              children: child.children.map((itemChild) => {\n                if (itemChild.type === 'paragraph') {\n                  return {\n                    children: convertChildrenDeserialize(\n                      itemChild.children,\n                      deco,\n                      options\n                    ),\n                    type: getPluginType(options.editor!, KEYS.lic),\n                  };\n                }\n                return convertChildrenDeserialize(\n                  [itemChild],\n                  deco,\n                  options\n                )[0];\n              }),\n              type: getPluginType(options.editor!, KEYS.li),\n            };\n          }\n          return convertChildrenDeserialize([child], deco, options)[0];\n        });\n\n        return {\n          children,\n          type: getPluginType(\n            options.editor!,\n            mdastNode.ordered ? KEYS.olClassic : KEYS.ulClassic\n          ),\n        };\n      }\n\n      const parseListItems = (listNode: MdList, indent = 1, startIndex = 1) => {\n        const items: any[] = [];\n        const isOrdered = !!listNode.ordered;\n        let listStyleType = isOrdered\n          ? getPluginType(options.editor!, KEYS.ol)\n          : getPluginType(options.editor!, KEYS.ul);\n\n        listNode.children?.forEach((listItem, index) => {\n          if (listItem.type !== 'listItem') return;\n\n          const isTodoList = isBoolean(listItem.checked);\n\n          if (isTodoList)\n            listStyleType = getPluginType(options.editor!, KEYS.listTodo);\n\n          // Handle the main content of the list item\n          const [paragraph, ...subLists] = listItem.children || [];\n\n          // Create list item from paragraph content\n          const result = paragraph\n            ? buildSlateNode(paragraph, deco, options)\n            : {\n                children: [{ text: '' }],\n                type: getPluginType(options.editor!, KEYS.p),\n              };\n\n          // Convert result to array if it's not already\n          const itemNodes = Array.isArray(result) ? result : [result];\n\n          // Add list properties to each node\n          itemNodes.forEach((node: any) => {\n            const itemContent: TListElement = {\n              ...node,\n              indent,\n              type:\n                node.type === getPluginType(options.editor!, KEYS.img)\n                  ? node.type\n                  : getPluginType(options.editor!, KEYS.p),\n            };\n\n            // Only add listStyleType and listStart for appropriate cases\n            itemContent.listStyleType = listStyleType;\n            if (isTodoList) {\n              itemContent.checked = listItem.checked!;\n            }\n            if (isOrdered) {\n              itemContent.listStart = startIndex + index;\n            }\n\n            items.push(itemContent);\n          });\n\n          // Process sub-lists and other content\n          subLists.forEach((subNode) => {\n            if (subNode.type === 'list') {\n              // Recursively process nested lists\n              const subListStart = (subNode as any).start || 1;\n              const nestedItems = parseListItems(\n                subNode,\n                indent + 1,\n                subListStart\n              );\n              items.push(...nestedItems);\n            } else {\n              // Transform any other node type using buildSlateNode\n              const result = buildSlateNode(subNode, deco, options);\n\n              // Handle both array and single node results\n              if (Array.isArray(result)) {\n                items.push(\n                  ...result.map((item) => ({\n                    ...item,\n                    indent: indent + 1,\n                  }))\n                );\n              } else {\n                items.push({\n                  ...(result as any),\n                  indent: indent + 1,\n                });\n              }\n            }\n          });\n        });\n\n        return items;\n      };\n\n      const startIndex = (mdastNode as any).start || 1;\n      return parseListItems(mdastNode, 1, startIndex);\n    },\n    serialize: (node: { type: 'ol' | 'ul' } & TElement, options): MdList => {\n      const editor = options.editor!;\n      const isOrdered = getPluginKey(editor, node.type) === KEYS.olClassic;\n\n      const serializeListItems = (children: any[]): any[] => {\n        const items = [];\n        let currentItem: any = null;\n\n        for (const child of children) {\n          if (getPluginKey(editor, child.type) === 'li') {\n            if (currentItem) {\n              items.push(currentItem);\n            }\n            currentItem = {\n              children: [],\n              spread: false,\n              type: 'listItem',\n            };\n\n            for (const liChild of child.children) {\n              if (getPluginKey(editor, liChild.type) === 'lic') {\n                currentItem.children.push({\n                  children: convertNodesSerialize(liChild.children, options),\n                  type: 'paragraph',\n                });\n              } else if (\n                getPluginKey(editor, liChild.type) === 'ol' ||\n                getPluginKey(editor, liChild.type) === 'ul'\n              ) {\n                currentItem.children.push({\n                  children: serializeListItems(liChild.children),\n                  ordered: getPluginKey(editor, liChild.type) === 'ol',\n                  spread: false,\n                  type: 'list',\n                });\n              }\n            }\n          }\n        }\n\n        if (currentItem) {\n          items.push(currentItem);\n        }\n\n        return items;\n      };\n\n      return {\n        children: serializeListItems(node.children),\n        ordered: isOrdered,\n        spread: false,\n        type: 'list',\n      };\n    },\n  },\n  listItem: {\n    deserialize: (mdastNode, deco, options) => {\n      // Transform each paragraph in the list item into a 'lic' type\n      const children = mdastNode.children.map((child: MdRootContent) => {\n        if (child.type === 'paragraph') {\n          return {\n            children: convertChildrenDeserialize(child.children, deco, options),\n            type: getPluginType(options.editor!, KEYS.lic),\n          };\n        }\n        return convertChildrenDeserialize([child], deco, options)[0];\n      });\n\n      return {\n        children,\n        type: getPluginType(options.editor!, KEYS.li),\n      };\n    },\n    serialize: (node, options) => {\n      return {\n        children: convertNodesSerialize(node.children, options),\n        type: 'listItem',\n      };\n    },\n  },\n  mention: {\n    deserialize: (node: MentionNode, deco, options): TMentionElement => ({\n      children: [{ text: '' }],\n      type: getPluginType(options.editor!, KEYS.mention),\n      value: node.displayText || node.username,\n      ...(node.displayText && { key: node.username }),\n    }),\n    serialize: (node: TMentionElement) => {\n      const mentionId = node.key || node.value;\n      const displayText = node.value;\n\n      // Always use link format for all mentions\n      // Encode the mention ID to create a valid URL, manually encoding parentheses\n      const encodedId = encodeURIComponent(String(mentionId))\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29');\n      return {\n        children: [{ type: 'text', value: displayText }],\n        type: 'link',\n        url: `mention:${encodedId}`,\n      };\n    },\n  },\n  p: {\n    deserialize: (node, deco, options) => {\n      const isKeepLineBreak = options.splitLineBreaks;\n      const children = convertChildrenDeserialize(node.children, deco, options);\n      const splitBlockTypes = new Set(['img']);\n\n      const elements: any[] = [];\n      let inlineNodes: any[] = [];\n\n      const flushInlineNodes = () => {\n        if (inlineNodes.length > 0) {\n          elements.push({\n            children: inlineNodes,\n            type: getPluginType(options.editor!, KEYS.p),\n          });\n          inlineNodes = [];\n        }\n      };\n\n      children.forEach((c) => {\n        if (c.text === '\\u200B') {\n          c.text = '';\n        }\n      });\n\n      children.forEach((child, index, children) => {\n        const { type } = child as { type?: string };\n\n        if (type && splitBlockTypes.has(type)) {\n          flushInlineNodes();\n          elements.push(child);\n        } else if (\n          isKeepLineBreak &&\n          'text' in child &&\n          typeof child.text === 'string'\n        ) {\n          const textParts = child.text.split('\\n');\n\n          // Handle line break generated by <br>\n          const isSingleLineBreak =\n            child.text === '\\n' && inlineNodes.length === 0;\n\n          if (isSingleLineBreak) {\n            inlineNodes.push({ ...child, text: '' });\n            flushInlineNodes();\n\n            return;\n          }\n\n          textParts.forEach((part, index, array) => {\n            const isNotFirstPart = index > 0;\n            const isNotLastPart = index < array.length - 1;\n\n            // Create new paragraph for non-first parts\n            if (isNotFirstPart) {\n              flushInlineNodes();\n            }\n            // Only add non-empty text\n            if (part) {\n              inlineNodes.push({ ...child, text: part });\n            }\n            // Create paragraph break for non-last parts\n            if (isNotLastPart) {\n              flushInlineNodes();\n            }\n          });\n        } else {\n          if (\n            child.text === '\\n' &&\n            children.length > 1 &&\n            index === children.length - 1\n          ) {\n            // remove the last br of the paragraph if the previos element is not a br\n            // no op\n          } else {\n            inlineNodes.push(child);\n          }\n        }\n      });\n\n      flushInlineNodes();\n\n      return elements.length === 1 ? elements[0] : elements;\n    },\n    serialize: (node, options) => {\n      let enrichedChildren = node.children;\n\n      enrichedChildren = enrichedChildren.map((child) => {\n        if (child.text === '\\n') {\n          return {\n            type: 'break',\n          } as any;\n        }\n\n        if (child.text === '' && options.preserveEmptyParagraphs !== false) {\n          return { ...child, text: '\\u200B' };\n        }\n\n        return child;\n      });\n\n      const convertedNodes = convertNodesSerialize(\n        enrichedChildren,\n        options\n      ) as MdParagraph['children'];\n\n      if (\n        convertedNodes.length > 0 &&\n        enrichedChildren.at(-1)!.type === 'break'\n      ) {\n        // if the last child of the paragraph is a line break add an additional one\n        convertedNodes.at(-1)!.type = 'html';\n        // @ts-expect-error -- value is the right property here\n        convertedNodes.at(-1)!.value = '\\n<br />';\n      }\n\n      return {\n        children: convertedNodes,\n        type: 'paragraph',\n      };\n    },\n  },\n  strikethrough: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertTextsDeserialize(mdastNode, deco, options);\n    },\n  },\n  subscript: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertChildrenDeserialize(\n        mdastNode.children,\n        { [getPluginType(options.editor!, KEYS.sub)]: true, ...deco },\n        options\n      ) as any;\n    },\n    serialize(slateNode, options): MdMdxJsxTextElement {\n      return {\n        attributes: [],\n        children: [{ type: 'text', value: slateNode.text }],\n        name: 'sub',\n        type: 'mdxJsxTextElement',\n      };\n    },\n  },\n  superscript: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertChildrenDeserialize(\n        mdastNode.children,\n        { [getPluginType(options.editor!, KEYS.sup)]: true, ...deco },\n        options\n      ) as any;\n    },\n    serialize(slateNode, options): MdMdxJsxTextElement {\n      return {\n        attributes: [],\n        children: [{ type: 'text', value: slateNode.text }],\n        name: 'sup',\n        type: 'mdxJsxTextElement',\n      };\n    },\n  },\n  table: {\n    deserialize: (node, deco, options) => {\n      const rows =\n        node.children?.map((row, rowIndex) => {\n          return {\n            children:\n              row.children?.map((cell) => {\n                const cellType = rowIndex === 0 ? 'th' : 'td';\n\n                return {\n                  children: convertChildrenDeserialize(\n                    cell.children,\n                    deco,\n                    options\n                  ).map((child) => {\n                    if (!child.type) {\n                      return {\n                        children: [child],\n                        type: getPluginType(options.editor!, KEYS.p),\n                      };\n                    }\n\n                    return child;\n                  }),\n                  type: getPluginType(options.editor!, cellType),\n                };\n              }) || [],\n            type: getPluginType(options.editor!, KEYS.tr),\n          };\n        }) || [];\n\n      return {\n        children: rows,\n        type: getPluginType(options.editor!, KEYS.table),\n      };\n    },\n    serialize: (node, options) => {\n      return {\n        children: convertNodesSerialize(\n          node.children,\n          options\n        ) as MdTable['children'],\n        type: 'table',\n      };\n    },\n  },\n  td: {\n    serialize: (node, options) => {\n      return {\n        children: convertNodesSerialize(\n          node.children,\n          options\n        ) as MdTableCell['children'],\n        type: 'tableCell',\n      };\n    },\n  },\n  text: {\n    deserialize: (mdastNode, deco) => {\n      return {\n        ...deco,\n        text: mdastNode.value.replace(/^\\n/, ''),\n      };\n    },\n  },\n  th: {\n    serialize: (node, options) => {\n      return {\n        children: convertNodesSerialize(\n          node.children,\n          options\n        ) as MdTableCell['children'],\n        type: 'tableCell',\n      };\n    },\n  },\n  toc: {\n    deserialize: (mdastNode, deco, options) => {\n      return {\n        children: convertChildrenDeserialize(mdastNode.children, deco, options),\n        type: getPluginType(options.editor!, KEYS.toc),\n      };\n    },\n    serialize: (node, options): MdMdxJsxFlowElement => {\n      return {\n        attributes: [],\n        children: convertNodesSerialize(node.children, options) as any,\n        name: 'toc',\n        type: 'mdxJsxFlowElement',\n      };\n    },\n  },\n  tr: {\n    serialize: (node, options) => {\n      return {\n        children: convertNodesSerialize(\n          node.children,\n          options\n        ) as MdTableRow['children'],\n        type: 'tableRow',\n      };\n    },\n  },\n  underline: {\n    mark: true,\n    deserialize: (mdastNode, deco, options) => {\n      return convertChildrenDeserialize(\n        mdastNode.children,\n        { [getPluginType(options.editor!, KEYS.underline)]: true, ...deco },\n        options\n      ) as any;\n    },\n    serialize(slateNode, options): MdMdxJsxTextElement {\n      return {\n        attributes: [],\n        children: [{ type: 'text', value: slateNode.text }],\n        name: 'u',\n        type: 'mdxJsxTextElement',\n      };\n    },\n  },\n  ...fontRules,\n  ...mediaRules,\n  ...columnRules,\n};\n\nexport const buildRules = (editor: SlateEditor) => {\n  const keys = Object.keys(defaultRules);\n\n  const newRules: Record<string, any> = {};\n  keys.forEach((key) => {\n    const pluginKey = getPluginKey(editor, key);\n    newRules[pluginKey ?? key] = defaultRules[key];\n  });\n\n  return newRules;\n};\n","import {\n  type Descendant,\n  type TElement,\n  type TText,\n  getPluginKey,\n  getPluginType,\n  KEYS,\n  TextApi,\n} from 'platejs';\n\nimport type { unistLib } from '../types';\nimport type { SerializeMdOptions } from './serializeMd';\n\nimport { convertTextsSerialize } from './convertTextsSerialize';\nimport { listToMdastTree } from './listToMdastTree';\nimport { unreachable } from './utils';\nimport { getSerializerByKey } from './utils/getSerializerByKey';\n\nexport const convertNodesSerialize = (\n  nodes: Descendant[],\n  options: SerializeMdOptions\n): unistLib.Node[] => {\n  const mdastNodes: unistLib.Node[] = [];\n  let textQueue: TText[] = [];\n\n  const listBlock: TElement[] = [];\n\n  for (let i = 0; i <= nodes.length; i++) {\n    const n = nodes[i] as any;\n\n    if (n && TextApi.isText(n)) {\n      // Only add text nodes that pass the filtering\n      if (shouldIncludeText(n, options)) {\n        textQueue.push(n);\n      }\n    } else {\n      if (textQueue.length > 0) {\n        mdastNodes.push(\n          ...(convertTextsSerialize(\n            textQueue,\n            options\n          ) as any as unistLib.Node[])\n        );\n      }\n      textQueue = [];\n      if (!n) continue;\n\n      // Skip this node if it doesn't pass the filtering\n      if (!shouldIncludeNode(n, options)) {\n        continue;\n      }\n\n      const pType = getPluginType(options.editor!, KEYS.p) ?? KEYS.p;\n\n      if (n?.type === pType && 'listStyleType' in n) {\n        listBlock.push(n);\n\n        const next = nodes[i + 1] as TElement;\n        const isNextIndent =\n          next && next.type === pType && 'listStyleType' in next;\n\n        if (!isNextIndent) {\n          mdastNodes.push(listToMdastTree(listBlock as any, options));\n          listBlock.length = 0;\n        }\n      } else {\n        const node = buildMdastNode(n, options);\n\n        if (node) {\n          mdastNodes.push(node as unistLib.Node);\n        }\n      }\n    }\n  }\n\n  return mdastNodes;\n};\n\nexport const buildMdastNode = (node: any, options: SerializeMdOptions) => {\n  const editor = options.editor!;\n\n  let key = getPluginKey(editor, node.type) ?? node.type;\n\n  if (KEYS.heading.includes(key)) {\n    key = 'heading';\n  }\n\n  if (key === KEYS.olClassic || key === KEYS.ulClassic) {\n    key = 'list';\n  }\n\n  const nodeParser = getSerializerByKey(key, options);\n\n  if (nodeParser) {\n    return nodeParser(node, options);\n  }\n\n  unreachable(node);\n};\n\nconst shouldIncludeText = (\n  text: TText,\n  options: SerializeMdOptions\n): boolean => {\n  const { allowedNodes, allowNode, disallowedNodes } = options;\n\n  // First check allowedNodes/disallowedNodes\n  if (\n    allowedNodes &&\n    disallowedNodes &&\n    allowedNodes.length > 0 &&\n    disallowedNodes.length > 0\n  ) {\n    throw new Error('Cannot combine allowedNodes with disallowedNodes');\n  }\n\n  // Check text properties against allowedNodes/disallowedNodes\n  for (const [key, value] of Object.entries(text)) {\n    if (key === 'text') continue;\n\n    if (allowedNodes) {\n      // If allowedNodes is specified, only include if the mark is in allowedNodes\n      if (!allowedNodes.includes(key) && value) {\n        return false;\n      }\n    } else if (disallowedNodes?.includes(key) && value) {\n      // If using disallowedNodes, exclude if the mark is in disallowedNodes\n      return false;\n    }\n  }\n\n  // Finally, check allowNode if provided\n  if (allowNode?.serialize) {\n    return allowNode.serialize(text);\n  }\n\n  return true;\n};\n\nconst shouldIncludeNode = (\n  node: TElement,\n  options: SerializeMdOptions\n): boolean => {\n  const { allowedNodes, allowNode, disallowedNodes } = options;\n\n  if (!node.type) return true;\n\n  // First check allowedNodes/disallowedNodes\n  if (\n    allowedNodes &&\n    disallowedNodes &&\n    allowedNodes.length > 0 &&\n    disallowedNodes.length > 0\n  ) {\n    throw new Error('Cannot combine allowedNodes with disallowedNodes');\n  }\n\n  if (allowedNodes) {\n    // If allowedNodes is specified, only include if the type is in allowedNodes\n    if (!allowedNodes.includes(node.type)) {\n      return false;\n    }\n  } else if (disallowedNodes?.includes(node.type)) {\n    // If using disallowedNodes, exclude if the type is in disallowedNodes\n    return false;\n  }\n\n  // Finally, check allowNode if provided\n  if (allowNode?.serialize) {\n    return allowNode.serialize(node);\n  }\n\n  return true;\n};\n","import { type TText, getPluginType } from 'platejs';\n\nimport type { MdMark } from '../types';\nimport type { SerializeMdOptions } from './serializeMd';\n\nimport { getCustomMark } from './utils';\nimport { getSerializerByKey } from './utils/getSerializerByKey';\n\n// inlineCode should be last because of the spec in mdast\n// https://github.com/inokawa/remark-slate-transformer/issues/145\nexport const basicMarkdownMarks = ['italic', 'bold', 'strikethrough', 'code'];\n\nexport const convertTextsSerialize = (\n  slateTexts: readonly TText[],\n  options: SerializeMdOptions,\n  key?: string\n): MdMark[] => {\n  const customLeaf: string[] = getCustomMark(options);\n\n  const mdastTexts: MdMark[] = [];\n\n  const starts: string[] = [];\n  let ends: string[] = [];\n\n  let textTemp = '';\n  for (let j = 0; j < slateTexts.length; j++) {\n    const cur = slateTexts[j]!;\n    textTemp += cur.text;\n\n    const prevStarts = starts.slice();\n    const prevEnds = ends.slice();\n\n    const prev = slateTexts[j - 1];\n    const next = slateTexts[j + 1];\n    ends = [];\n    (\n      [\n        ...basicMarkdownMarks,\n        // exclude repeated marks\n        ...customLeaf.filter((k) => !basicMarkdownMarks.includes(k)),\n      ] as const\n    ).forEach((key) => {\n      const nodeType = getPluginType(options.editor!, key);\n\n      if (cur[nodeType]) {\n        if (!prev?.[nodeType]) {\n          starts.push(key);\n        }\n        if (!next?.[nodeType]) {\n          ends.push(key);\n        }\n      }\n    });\n\n    const endsToRemove = starts.reduce<{ key: string; index: number }[]>(\n      (acc, k, kIndex) => {\n        if (ends.includes(k)) {\n          acc.push({ key: k, index: kIndex });\n        }\n        return acc;\n      },\n      []\n    );\n\n    if (starts.length > 0) {\n      let bef = '';\n      let aft = '';\n      if (\n        endsToRemove.length === 1 &&\n        (prevStarts.toString() !== starts.toString() ||\n          // https://github.com/inokawa/remark-slate-transformer/issues/90\n          (prevEnds.includes('italic') && ends.includes('bold'))) &&\n        starts.length - endsToRemove.length === 0\n      ) {\n        while (textTemp.startsWith(' ')) {\n          bef += ' ';\n          textTemp = textTemp.slice(1);\n        }\n        while (textTemp.endsWith(' ')) {\n          aft += ' ';\n          textTemp = textTemp.slice(0, -1);\n        }\n      }\n      let res: MdMark = {\n        type: 'text',\n        value: textTemp,\n      };\n      textTemp = '';\n      starts\n        .slice()\n        .reverse()\n        .forEach((k) => {\n          const nodeParser = getSerializerByKey(k, options);\n\n          if (nodeParser) {\n            const node = nodeParser(cur, options) as any;\n            res = {\n              ...node,\n              children: [res],\n            };\n          }\n\n          switch (k) {\n            case 'bold': {\n              res = {\n                children: [res],\n                type: 'strong',\n              };\n              break;\n            }\n            case 'code': {\n              let currentRes = res;\n              while (\n                currentRes.type !== 'text' &&\n                currentRes.type !== 'inlineCode'\n              ) {\n                currentRes = currentRes.children[0] as MdMark;\n              }\n              currentRes.type = 'inlineCode';\n\n              break;\n            }\n            case 'italic': {\n              res = {\n                children: [res],\n                type: 'emphasis',\n              };\n              break;\n            }\n            case 'strikethrough': {\n              res = {\n                children: [res],\n                type: 'delete',\n              };\n              break;\n            }\n          }\n        });\n      const arr: MdMark[] = [];\n      if (bef.length > 0) {\n        arr.push({ type: 'text', value: bef });\n      }\n      arr.push(res);\n      if (aft.length > 0) {\n        arr.push({ type: 'text', value: aft });\n      }\n      mdastTexts.push(...arr);\n    }\n\n    if (endsToRemove.length > 0) {\n      endsToRemove.reverse().forEach((e) => {\n        starts.splice(e.index, 1);\n      });\n    } else {\n      mdastTexts.push({ type: 'text', value: textTemp });\n      textTemp = '';\n    }\n  }\n  if (textTemp) {\n    mdastTexts.push({ type: 'text', value: textTemp });\n    textTemp = '';\n  }\n\n  const mergedTexts = mergeTexts(mdastTexts);\n\n  const flattenedEmptyNodes = mergedTexts.map((node) => {\n    if (!hasContent(node)) {\n      return { type: 'text', value: '' } as MdMark;\n    }\n    return node;\n  });\n\n  return flattenedEmptyNodes;\n};\n\nconst hasContent = (node: MdMark): boolean => {\n  if (node.type === 'inlineCode') {\n    // inline has no children - no deeper search needed\n    return node.value !== '';\n  }\n\n  if (node.type === 'text') {\n    // inline has no children - no deeper search needed\n    return node.value !== '';\n  }\n\n  if (node.children?.length > 0) {\n    for (const child of node.children) {\n      // all types other then emphasis are represented with some characters that can also be formatted\n      if (\n        child.type !== 'emphasis' &&\n        child.type !== 'strong' &&\n        child.type !== 'inlineCode' &&\n        child.type !== 'delete' &&\n        child.type !== 'text'\n      ) {\n        return true;\n      }\n      if (hasContent(child)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nconst mergeTexts = (nodes: MdMark[]): MdMark[] => {\n  const res: MdMark[] = [];\n  for (const cur of nodes) {\n    const last = res.at(-1);\n    if (last && last.type === cur.type) {\n      if (last.type === 'text') {\n        last.value += (cur as typeof last).value;\n      } else if (last.type === 'inlineCode') {\n        last.value += (cur as typeof last).value;\n      } else {\n        last.children = mergeTexts(\n          last.children.concat((cur as typeof last).children) as MdMark[]\n        );\n      }\n    } else {\n      if (cur.type === 'text' && cur.value === '') continue;\n      res.push(cur);\n    }\n  }\n  return res;\n};\n","import type { SerializeMdOptions } from '../serializeMd';\n\nexport const getCustomMark = (options?: SerializeMdOptions): string[] => {\n  if (!options?.rules) {\n    return [];\n  }\n\n  return Object.entries(options.rules)\n    .filter(([_, parser]) => parser?.mark)\n    .map(([key]) => key);\n};\n","import { getPluginType, KEYS } from 'platejs';\n\nimport type { MdRules } from '../types';\n\nimport { convertChildrenDeserialize } from '../deserializer/convertChildrenDeserialize';\nimport { convertNodesSerialize } from '../serializer';\nimport { parseAttributes, propsToAttributes } from './utils';\n\nexport const columnRules: MdRules = {\n  column: {\n    deserialize: (mdastNode, deco, options) => {\n      const props = parseAttributes(mdastNode.attributes);\n      return {\n        children: convertChildrenDeserialize(\n          mdastNode.children,\n          { ...deco },\n          options\n        ) as any,\n        type: getPluginType(options.editor!, KEYS.column),\n        ...props,\n      } as any;\n    },\n    serialize: (node, options) => {\n      const { id, children, type, ...rest } = node;\n\n      return {\n        attributes: propsToAttributes(rest),\n        children: convertNodesSerialize(children, options) as any,\n        name: type,\n        type: 'mdxJsxFlowElement',\n      };\n    },\n  },\n  column_group: {\n    deserialize: (mdastNode, deco, options) => {\n      const props = parseAttributes(mdastNode.attributes);\n\n      return {\n        children: convertChildrenDeserialize(\n          mdastNode.children,\n          { ...deco },\n          options\n        ) as any,\n        type: getPluginType(options.editor!, KEYS.columnGroup) as any,\n        ...props,\n      };\n    },\n    serialize: (node, options) => {\n      const { id, children, type, ...rest } = node;\n\n      return {\n        attributes: propsToAttributes(rest),\n        children: convertNodesSerialize(children, options) as any,\n        name: type,\n        type: 'mdxJsxFlowElement',\n      };\n    },\n  },\n};\n","// Helper function to parse JSON attributes to props\nexport function parseAttributes(attributes: any[]): Record<string, any> {\n  const props: Record<string, any> = {};\n\n  if (attributes && attributes.length > 0) {\n    attributes.forEach((attr: any) => {\n      if (attr.name && attr.value !== undefined) {\n        let value = attr.value;\n\n        try {\n          value = JSON.parse(attr.value);\n        } catch (error) {\n          value = attr.value;\n        }\n\n        props[attr.name] = value;\n      }\n    });\n  }\n\n  return props;\n}\n\n// Helper function to convert props to attributes\nexport function propsToAttributes(props: Record<string, any>): any[] {\n  return Object.entries(props).map(([name, value]) => ({\n    name,\n    type: 'mdxJsxAttribute',\n    value: typeof value === 'string' ? value : JSON.stringify(value),\n  }));\n}\n","import kebabCase from 'lodash/kebabCase.js';\n\nimport type { MdMdxJsxTextElement } from '../mdast';\nimport type { MdRules } from '../types';\n\nimport { convertChildrenDeserialize, getStyleValue } from '../deserializer';\n\nfunction createFontRule(propName: string) {\n  const styleName = kebabCase(propName);\n\n  return {\n    mark: true,\n    serialize: (slateNode: any): MdMdxJsxTextElement => {\n      return {\n        attributes: [\n          {\n            name: 'style',\n            type: 'mdxJsxAttribute',\n            value: `${styleName}: ${slateNode[propName]};`,\n          },\n        ],\n        children: [{ type: 'text', value: slateNode.text }],\n        name: 'span',\n        type: 'mdxJsxTextElement',\n      };\n    },\n  };\n}\n\nexport const fontRules: MdRules = {\n  backgroundColor: createFontRule('backgroundColor'),\n  color: createFontRule('color'),\n  fontFamily: createFontRule('fontFamily'),\n  fontSize: createFontRule('fontSize'),\n  fontWeight: createFontRule('fontWeight'),\n  span: {\n    mark: true,\n    deserialize: (mdastNode: MdMdxJsxTextElement, deco: any, options: any) => {\n      const fontFamily = getStyleValue(mdastNode, 'font-family');\n      const fontSize = getStyleValue(mdastNode, 'font-size');\n      const fontWeight = getStyleValue(mdastNode, 'font-weight');\n      const color = getStyleValue(mdastNode, 'color');\n      const backgroundColor = getStyleValue(mdastNode, 'background-color');\n\n      return convertChildrenDeserialize(\n        mdastNode.children,\n        {\n          ...deco,\n          backgroundColor,\n          color,\n          fontFamily,\n          fontSize,\n          fontWeight,\n        },\n        options\n      ) as any;\n    },\n  },\n};\n","import type { TMediaElement } from 'platejs';\n\nimport type { MdMdxJsxFlowElement } from '../mdast';\nimport type { MdRules } from '../types';\n\nimport { convertNodesSerialize } from '../serializer';\nimport { parseAttributes, propsToAttributes } from './utils';\n\nfunction createMediaRule() {\n  return {\n    deserialize: (node: MdMdxJsxFlowElement): TMediaElement => {\n      const { src, ...props } = parseAttributes(node.attributes);\n\n      return {\n        children: [{ text: '' }],\n        type: node.name!,\n        url: src,\n        ...props,\n      } as TMediaElement;\n    },\n    serialize: (node: TMediaElement, options: any) => {\n      const { id, children, type, url, ...rest } = node;\n\n      return {\n        attributes: propsToAttributes({ ...rest, src: url }),\n        children: convertNodesSerialize(children, options) as any,\n        name: type,\n        type: 'mdxJsxFlowElement',\n      };\n    },\n  };\n}\n\nexport const mediaRules: MdRules = {\n  audio: createMediaRule(),\n  file: createMediaRule(),\n  video: createMediaRule(),\n};\n","import type { SlateEditor } from 'platejs';\n\nimport type { SerializeMdOptions } from '../serializeMd';\n\nimport { MarkdownPlugin } from '../../MarkdownPlugin';\nimport { buildRules } from '../../rules';\n\n/**\n * Merges Markdown configurations, following the principle that options take\n * precedence\n *\n * @param editor Editor instance used to get plugin default configurations\n * @param options User-provided options (higher priority)\n * @returns The final merged configuration\n */\nexport const getMergedOptionsSerialize = (\n  editor: SlateEditor,\n  options?: SerializeMdOptions\n): SerializeMdOptions => {\n  const {\n    allowedNodes: PluginAllowedNodes,\n    allowNode: PluginAllowNode,\n    disallowedNodes: PluginDisallowedNodes,\n    remarkPlugins: PluginRemarkPlugins,\n    rules: PluginRules,\n  } = editor.getOptions(MarkdownPlugin);\n\n  const mergedRules = Object.assign(\n    {},\n    buildRules(editor),\n    options?.rules ?? PluginRules\n  );\n\n  return {\n    allowedNodes: options?.allowedNodes ?? PluginAllowedNodes,\n    allowNode: options?.allowNode ?? PluginAllowNode,\n    disallowedNodes: options?.disallowedNodes ?? PluginDisallowedNodes,\n    editor,\n    remarkPlugins: options?.remarkPlugins ?? PluginRemarkPlugins ?? [],\n    rules: mergedRules,\n    spread: options?.spread,\n    value: options?.value ?? editor.children,\n  };\n};\n","import type { SerializeMdOptions } from '../serializeMd';\n\nimport { buildRules } from '../../rules/defaultRules';\n\nexport const getSerializerByKey = (\n  key: string,\n  options: SerializeMdOptions\n) => {\n  const nodes = options.rules;\n\n  const rules = buildRules(options.editor!);\n\n  return nodes?.[key]?.serialize === undefined\n    ? rules[key]?.serialize\n    : nodes?.[key]?.serialize;\n};\n","export const unreachable = (value: any) => {\n  console.warn(`Unreachable code: ${JSON.stringify(value)}`);\n};\n","import type { TListElement } from 'platejs';\n\nimport type { MdList, MdListItem, MdParagraph } from '../mdast';\nimport type { SerializeMdOptions } from './serializeMd';\n\nimport { convertNodesSerialize } from './convertNodesSerialize';\n\nexport function listToMdastTree(\n  nodes: TListElement[],\n  options: SerializeMdOptions\n): MdList {\n  if (nodes.length === 0) {\n    throw new Error('Cannot create a list from empty nodes');\n  }\n\n  const root: MdList = {\n    children: [],\n    ordered: nodes[0].listStyleType === 'decimal',\n    spread: options.spread ?? false,\n    start: nodes[0].listStart,\n    type: 'list',\n  };\n\n  // Stack to track parent nodes at different indentation levels\n  const indentStack: {\n    indent: number;\n    list: MdList;\n    parent: MdListItem | null;\n  }[] = [{ indent: nodes[0].indent, list: root, parent: null }];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const currentIndent = node.indent;\n\n    // Find the appropriate parent list for the current indentation level\n    while (\n      indentStack.length > 1 &&\n      indentStack.at(-1)!.indent > currentIndent\n    ) {\n      indentStack.pop();\n    }\n\n    const stackTop = indentStack.at(-1);\n    if (!stackTop) {\n      throw new Error('Stack should never be empty');\n    }\n\n    // Create the current list item\n    const listItem: MdListItem = {\n      checked: null,\n      children: [\n        {\n          children: convertNodesSerialize(\n            node.children,\n            options\n          ) as MdParagraph['children'],\n          type: 'paragraph',\n        },\n      ],\n      type: 'listItem',\n    } as any;\n\n    // Add spread property to list items when spread is true\n    if (options.spread) {\n      (listItem as any).spread = true;\n    }\n\n    // Add checked property for todo lists\n    if (node.listStyleType === 'todo' && node.checked !== undefined) {\n      listItem.checked = node.checked;\n    }\n\n    // Add the list item to the appropriate parent list\n    stackTop.list.children.push(listItem);\n\n    // Check if the next node has a higher indentation level\n    const nextNode = nodes[i + 1];\n    if (nextNode && nextNode.indent > currentIndent) {\n      // Create a new nested list for the next indentation level\n      const nestedList: MdList = {\n        children: [],\n        ordered: nextNode.listStyleType === 'decimal',\n        spread: options.spread ?? false,\n        start: nextNode.listStart,\n        type: 'list',\n      };\n\n      // Add the nested list to the current list item\n      listItem.children.push(nestedList);\n\n      // Push the new indentation level to the stack\n      indentStack.push({\n        indent: nextNode.indent,\n        list: nestedList,\n        parent: listItem,\n      });\n    }\n  }\n\n  return root;\n}\n","import type { SlateEditor } from 'platejs';\n\nimport remarkStringify from 'remark-stringify';\nimport { unified } from 'unified';\n\nimport type { SerializeMdOptions } from './serializeMd';\n\nimport { convertTextsSerialize } from './convertTextsSerialize';\nimport { getMergedOptionsSerialize } from './utils';\n\nexport const serializeInlineMd = (\n  editor: SlateEditor,\n  options?: SerializeMdOptions\n) => {\n  const mergedOptions = getMergedOptionsSerialize(editor, options);\n\n  const toRemarkProcessor = unified()\n    .use(mergedOptions.remarkPlugins ?? [])\n    .use(remarkStringify, {\n      emphasis: '_',\n    });\n\n  if (options?.value?.length === 0) return '';\n\n  const convertedTexts = convertTextsSerialize(mergedOptions.value as any, {\n    editor,\n  });\n\n  // Serialize the content\n  const serializedContent = toRemarkProcessor.stringify({\n    children: convertedTexts,\n    type: 'root',\n  });\n\n  return serializedContent;\n};\n","import type { Descendant, SlateEditor } from 'platejs';\n\nimport remarkStringify from 'remark-stringify';\nimport { type Plugin, unified } from 'unified';\n\nimport type { AllowNodeConfig } from '../MarkdownPlugin';\nimport type { MdRoot } from '../mdast';\nimport type { MdRules, PlateType } from '../types';\n\nimport { convertNodesSerialize } from './convertNodesSerialize';\nimport { getMergedOptionsSerialize } from './utils/getMergedOptionsSerialize';\nexport type SerializeMdOptions = {\n  allowedNodes?: PlateType[] | null;\n  allowNode?: AllowNodeConfig;\n  disallowedNodes?: PlateType[] | null;\n  editor?: SlateEditor;\n  preserveEmptyParagraphs?: boolean;\n  remarkPlugins?: Plugin[];\n  rules?: MdRules;\n  spread?: boolean;\n  value?: Descendant[];\n};\n\n/** Serialize the editor value to Markdown. */\nexport const serializeMd = (\n  editor: SlateEditor,\n  options?: Omit<SerializeMdOptions, 'editor'>\n) => {\n  const mergedOptions = getMergedOptionsSerialize(editor, options);\n\n  const { remarkPlugins, value } = mergedOptions;\n\n  const toRemarkProcessor = unified()\n    .use(remarkPlugins ?? [])\n    .use(remarkStringify, {\n      emphasis: '_',\n    });\n\n  const mdast = slateToMdast({\n    children: value!,\n    options: mergedOptions,\n  });\n\n  return toRemarkProcessor.stringify(mdast);\n};\n\nconst slateToMdast = ({\n  children,\n  options,\n}: {\n  children: Descendant[];\n  options: SerializeMdOptions;\n}): MdRoot => {\n  const ast = {\n    children: convertNodesSerialize(children, options) as MdRoot['children'],\n    type: 'root',\n  } as MdRoot;\n  return ast;\n};\n","import type { DeserializeMdOptions } from '../deserializeMd';\n\nimport { buildRules } from '../../rules/defaultRules';\n\nexport const getDeserializerByKey = (\n  key: string,\n  options: DeserializeMdOptions\n) => {\n  const rules = options.rules;\n\n  return rules?.[key]?.deserialize === undefined\n    ? buildRules(options.editor!)[key]?.deserialize\n    : rules?.[key]?.deserialize;\n};\n","import { type Descendant, type SlateEditor, ElementApi } from 'platejs';\n\nimport type { DeserializeMdOptions } from '../deserializeMd';\n\nimport { MarkdownPlugin } from '../../MarkdownPlugin';\nimport { stripMarkdownBlocks } from './stripMarkdown';\n\nexport const deserializeInlineMd = (\n  editor: SlateEditor,\n  text: string,\n  options?: DeserializeMdOptions\n) => {\n  const leadingSpaces = /^\\s*/.exec(text)?.[0] || '';\n  const trailingSpaces = /\\s*$/.exec(text)?.[0] || '';\n\n  const strippedText = stripMarkdownBlocks(text.trim());\n\n  const fragment: Descendant[] = [];\n\n  if (leadingSpaces) {\n    fragment.push({ text: leadingSpaces });\n  }\n\n  if (strippedText) {\n    const result = editor\n      .getApi(MarkdownPlugin)\n      .markdown.deserialize(strippedText, options)[0];\n\n    if (result) {\n      const nodes = ElementApi.isElement(result) ? result.children : [result];\n      fragment.push(...nodes);\n    }\n  }\n  if (trailingSpaces) {\n    fragment.push({ text: trailingSpaces });\n  }\n\n  return fragment;\n};\n","export const stripMarkdownBlocks = (text: string) => {\n  // Remove headers\n  text = text.replaceAll(/^#{1,6}\\s+/gm, '');\n\n  // Remove blockquotes\n  text = text.replaceAll(/^\\s*>\\s?/gm, '');\n\n  // Remove horizontal rules\n  text = text.replaceAll(/^([*_-]){3,}\\s*$/gm, '');\n\n  // Remove list symbols\n  text = text.replaceAll(/^(\\s*)([*+-]|\\d+\\.)\\s/gm, '$1');\n\n  // Remove code blocks\n  text = text.replaceAll(/^```[\\S\\s]*?^```/gm, '');\n\n  // Replace <br> with \\n\n  text = text.replaceAll('<br>', '\\n');\n\n  return text;\n};\n\nexport const stripMarkdownInline = (text: string) => {\n  // Remove emphasis (bold, italic)\n  text = text.replaceAll(/(\\*\\*|__)(.*?)\\1/g, '$2');\n  text = text.replaceAll(/(\\*|_)(.*?)\\1/g, '$2');\n\n  // Remove links\n  text = text.replaceAll(/\\[([^\\]]+)]\\(([^)]+)\\)/g, '$1');\n\n  // Remove inline code\n  text = text.replaceAll(/`(.+?)`/g, '$1');\n\n  // Replace HTML entities\n  text = text.replaceAll('&nbsp;', ' ');\n  text = text.replaceAll('&lt;', '<');\n  text = text.replaceAll('&gt;', '>');\n  text = text.replaceAll('&amp;', '&');\n\n  return text;\n};\n\nexport const stripMarkdown = (text: string) => {\n  text = stripMarkdownBlocks(text);\n  text = stripMarkdownInline(text);\n\n  // Remove HTML tags (including <br>)\n  // text = text.replace(/<[^>]*>/g, '');\n\n  // Replace HTML entities\n  // text = text.replace('&nbsp;', ' ');\n  // text = text.replace('&lt;', '<');\n  // text = text.replace('&gt;', '>');\n  // text = text.replace('&amp;', '&');\n\n  return text;\n};\n","import type { Plugin } from 'unified';\n\nexport const REMARK_MDX_TAG = 'remarkMdx';\n\nexport const tagRemarkPlugin = (pluginFn: any, tag: string) => {\n  const wrapped = function (this: any, ...args: any[]) {\n    return pluginFn.apply(this, args);\n  };\n  wrapped.__pluginTag = tag;\n  return wrapped;\n};\n\nexport const getRemarkPluginsWithoutMdx = (plugins: Plugin[]) => {\n  return plugins.filter((plugin) => {\n    return (plugin as any).__pluginTag !== REMARK_MDX_TAG;\n  });\n};\n","import type { SlateEditor } from 'platejs';\n\nimport type { DeserializeMdOptions } from '../deserializeMd';\n\nimport { MarkdownPlugin } from '../../MarkdownPlugin';\nimport { buildRules } from '../../rules';\nimport { getRemarkPluginsWithoutMdx } from '../../utils/getRemarkPluginsWithoutMdx';\n\n/**\n * Merges Markdown configurations, following the principle that options take\n * precedence\n *\n * @param editor Editor instance used to get plugin default configurations\n * @param options User-provided options (higher priority)\n * @returns The final merged configuration\n */\nexport const getMergedOptionsDeserialize = (\n  editor: SlateEditor,\n  options?: DeserializeMdOptions\n): DeserializeMdOptions => {\n  const {\n    allowedNodes: PluginAllowedNodes,\n    allowNode: PluginAllowNode,\n    disallowedNodes: PluginDisallowedNodes,\n    remarkPlugins: PluginRemarkPlugins,\n    rules: PluginRules,\n  } = editor.getOptions(MarkdownPlugin);\n\n  const mergedRules = Object.assign(\n    {},\n    buildRules(editor),\n    options?.rules ?? PluginRules\n  );\n\n  const remarkPlugins = options?.remarkPlugins ?? PluginRemarkPlugins ?? [];\n\n  return {\n    allowedNodes: options?.allowedNodes ?? PluginAllowedNodes,\n    allowNode: options?.allowNode ?? PluginAllowNode,\n    disallowedNodes: options?.disallowedNodes ?? PluginDisallowedNodes,\n    editor,\n    memoize: options?.memoize,\n    parser: options?.parser,\n    remarkPlugins: options?.withoutMdx\n      ? getRemarkPluginsWithoutMdx(remarkPlugins)\n      : remarkPlugins,\n    rules: mergedRules,\n    splitLineBreaks: options?.splitLineBreaks,\n  };\n};\n","import type { MdMdxJsxTextElement } from '../../mdast';\n\nexport const getStyleValue = (\n  mdastNode: MdMdxJsxTextElement,\n  styleName: string\n): string | undefined => {\n  const styleAttribute = mdastNode.attributes.find(\n    (attr) => 'name' in attr && attr.name === 'style'\n  ) as any;\n\n  if (!styleAttribute?.value) return undefined;\n\n  const styles = styleAttribute.value.split(';');\n  for (const style of styles) {\n    const [name, value] = style.split(':').map((s: string) => s.trim());\n    if (name === styleName) {\n      return value;\n    }\n  }\n  return undefined;\n};\n","import { type SlateEditor, getPluginType, KEYS } from 'platejs';\n\nimport {\n  type DeserializeMdOptions,\n  markdownToSlateNodes,\n} from '../deserializeMd';\nimport { deserializeInlineMd } from './deserializeInlineMd';\nimport { splitIncompleteMdx } from './splitIncompleteMdx';\n\nexport const markdownToSlateNodesSafely = (\n  editor: SlateEditor,\n  data: string,\n  options?: Omit<DeserializeMdOptions, 'editor'>\n) => {\n  const result = splitIncompleteMdx(data);\n\n  if (!Array.isArray(result))\n    return markdownToSlateNodes(editor, data, {\n      ...options,\n      withoutMdx: true,\n    });\n\n  const [completeString, incompleteString] = result;\n\n  const incompleteNodes = deserializeInlineMd(editor, incompleteString, {\n    ...options,\n    withoutMdx: true,\n  });\n\n  const completeNodes = markdownToSlateNodes(editor, completeString, options);\n\n  if (incompleteNodes.length === 0) {\n    return completeNodes;\n  }\n\n  const newBlock = {\n    children: incompleteNodes,\n    type: getPluginType(editor, KEYS.p),\n  };\n\n  // Push inlineNodes to the children of the last block in blockNodes\n  if (completeNodes.length === 0) {\n    return [newBlock];\n  }\n\n  const lastBlock = completeNodes.at(-1);\n\n  if (editor.api.isVoid(lastBlock)) {\n    return [newBlock];\n  }\n\n  // FIXME table column will fail, need recursive find the last p\n  if (lastBlock?.children) {\n    lastBlock.children.push(...incompleteNodes);\n    return completeNodes;\n  }\n\n  return completeNodes;\n};\n","import type { Root } from 'mdast';\nimport type { Plugin } from 'unified';\n\nimport {\n  type Descendant,\n  type SlateEditor,\n  getPluginKey,\n  KEYS,\n  TextApi,\n} from 'platejs';\nimport remarkParse from 'remark-parse';\nimport { unified } from 'unified';\n\nimport type { AllowNodeConfig } from '../MarkdownPlugin';\nimport type { MdRules, PlateType } from '../types';\n\nimport { mdastToSlate } from './mdastToSlate';\nimport { type ParseMarkdownBlocksOptions, parseMarkdownBlocks } from './utils';\nimport { getMergedOptionsDeserialize } from './utils/getMergedOptionsDeserialize';\nimport { markdownToSlateNodesSafely } from './utils/markdownToSlateNodesSafely';\n\n// TODO: fixes tests\n\nexport type DeserializeMdOptions = {\n  allowedNodes?: PlateType[] | null;\n  allowNode?: AllowNodeConfig;\n  disallowedNodes?: PlateType[] | null;\n  editor?: SlateEditor;\n  memoize?: boolean;\n  parser?: ParseMarkdownBlocksOptions;\n  preserveEmptyParagraphs?: boolean;\n  remarkPlugins?: Plugin[];\n  rules?: MdRules | null;\n  splitLineBreaks?: boolean;\n  withoutMdx?: boolean;\n  onError?: (error: Error) => void;\n};\n\nexport const markdownToAstProcessor = (\n  editor: SlateEditor,\n  data: string,\n  options?: DeserializeMdOptions\n) => {\n  const mergedOptions = getMergedOptionsDeserialize(editor, options);\n\n  return unified()\n    .use(remarkParse)\n    .use(mergedOptions.remarkPlugins ?? [])\n    .parse(data);\n};\n\nexport const markdownToSlateNodes = (\n  editor: SlateEditor,\n  data: string,\n  options?: Omit<DeserializeMdOptions, 'editor'>\n) => {\n  // if using remarkMdx, we need to replace <br> with <br /> since <br /> is not supported in mdx.\n  if (!options?.withoutMdx) {\n    data = data.replaceAll('<br>', '<br />');\n  }\n\n  const mergedOptions = getMergedOptionsDeserialize(editor, options);\n\n  const toSlateProcessor = unified()\n    .use(remarkParse)\n    .use(mergedOptions.remarkPlugins ?? [])\n    .use(remarkToSlate, mergedOptions);\n\n  if (options?.memoize) {\n    return parseMarkdownBlocks(data, options.parser).flatMap((token) => {\n      if (token.type === 'space') {\n        return {\n          ...editor.api.create.block(),\n          _memo: token.raw,\n        };\n      }\n\n      return toSlateProcessor\n        .processSync(token.raw)\n        .result.map((result: any) => {\n          return {\n            _memo: token.raw,\n            ...result,\n          };\n        });\n    });\n  }\n\n  return toSlateProcessor.processSync(data).result;\n};\n\nexport const deserializeMd = (\n  editor: SlateEditor,\n  data: string,\n  options?: Omit<DeserializeMdOptions, 'editor'>\n): any => {\n  let output = null;\n\n  try {\n    output = markdownToSlateNodes(editor, data, options);\n  } catch (error) {\n    options?.onError?.(error as Error);\n\n    if (!options?.withoutMdx) {\n      output = markdownToSlateNodesSafely(editor, data, options);\n    }\n  }\n\n  // when output is inline text, we need to wrap the text in a paragraph\n  return output?.map((item) =>\n    TextApi.isText(item)\n      ? {\n          children: [item],\n          type: getPluginKey(editor, KEYS.p) ?? KEYS.p,\n        }\n      : item\n  );\n};\n\ndeclare module 'unified' {\n  interface CompileResultMap {\n    remarkToSlateNode: Descendant[];\n  }\n}\n\nconst remarkToSlate: Plugin<[DeserializeMdOptions?], Root, Descendant[]> =\n  // TODO: options\n  function (options = {}) {\n    this.compiler = function (node) {\n      return mdastToSlate(node as Root, options);\n    };\n  };\n","import type { Root } from 'mdast';\n\nimport { type Descendant, getPluginKey, KEYS } from 'platejs';\n\nimport type { MdRoot } from '../mdast';\nimport type { DeserializeMdOptions } from './deserializeMd';\n\nimport { convertNodesDeserialize } from './convertNodesDeserialize';\n\nexport const mdastToSlate = (\n  node: Root,\n  options: DeserializeMdOptions\n): Descendant[] => {\n  return buildSlateRoot(node, options);\n};\n\nconst buildSlateRoot = (\n  root: MdRoot,\n  options: DeserializeMdOptions\n): Descendant[] => {\n  if (!options.splitLineBreaks) {\n    root.children = root.children.map((child) => {\n      if (child.type === 'html' && child.value === '<br />') {\n        return {\n          children: [{ type: 'text', value: '\\n' }],\n          type: 'paragraph',\n        };\n      }\n      return child;\n    });\n    return convertNodesDeserialize(root.children, {}, options);\n  }\n\n  // Split line breaks into separate paragraphs\n  const results: Descendant[] = [];\n  let startLine = root.position?.start.line ?? 1;\n\n  const addEmptyParagraphs = (count: number) => {\n    if (count > 0) {\n      results.push(\n        ...Array.from({ length: count }).map(() => ({\n          children: [{ text: '' }],\n          type: options.editor\n            ? (getPluginKey(options.editor, KEYS.p) ?? KEYS.p)\n            : KEYS.p,\n        }))\n      );\n    }\n  };\n\n  root.children?.forEach((child, index) => {\n    const isFirstChild = index === 0;\n    const isLastChild = index === root.children!.length - 1;\n\n    if (child.position) {\n      const emptyLinesBefore =\n        child.position.start.line - (isFirstChild ? startLine : startLine + 1);\n      addEmptyParagraphs(emptyLinesBefore);\n\n      const transformValue = convertNodesDeserialize([child], {}, options);\n      results.push(...transformValue);\n\n      if (isLastChild) {\n        const emptyLinesAfter =\n          root.position!.end.line - child.position.end.line - 1;\n        addEmptyParagraphs(emptyLinesAfter);\n      }\n\n      startLine = child.position.end.line;\n    } else {\n      const transformValue = convertNodesDeserialize([child], {}, options);\n      results.push(...transformValue);\n    }\n  });\n\n  return results;\n};\n","/** Check if character is valid for tag name: A-Z / a-z / 0-9 / - _ : */\nconst isNameChar = (c: number) =>\n  (c >= 48 && c <= 57) || // 0-9\n  (c >= 65 && c <= 90) || // A-Z\n  (c >= 97 && c <= 122) || // a-z\n  c === 45 || // -\n  c === 95 || // _\n  c === 58; // :\n\nexport const splitIncompleteMdx = (data: string): string[] | string => {\n  interface Frame {\n    name: string;\n    pos: number;\n  }\n  const stack: Frame[] = [];\n\n  const len = data.length;\n  let i = 0;\n  let cutPos = -1; // Once \"incomplete\" is found, record the starting position and exit scanning\n\n  while (i < len) {\n    if (data.codePointAt(i) !== 60 /* '<' */) {\n      i++;\n      continue;\n    }\n\n    const tagStart = i; // Remember the position of '<'\n    i++; // Skip '<'\n    if (i >= len) {\n      cutPos = tagStart;\n      break;\n    } // Stream breaks at '<'\n\n    let closing = false;\n    if (data[i] === '/') {\n      closing = true;\n      i++;\n    }\n\n    /* Parse tag name -------------------------------------------------- */\n    const nameStart = i;\n    while (i < len && isNameChar(data.codePointAt(i) as number)) i++;\n    if (nameStart === i) {\n      cutPos = tagStart;\n      break;\n    } // No name after '<'\n\n    const tagName = data.slice(nameStart, i).toLowerCase();\n\n    /* Skip to matching '>' (considering quotes) ------------------------------------ */\n    let inQuote: \"'\" | '\"' | null = null;\n    let selfClosing = false;\n\n    while (i < len) {\n      const ch = data[i];\n      if (inQuote) {\n        if (ch === inQuote) inQuote = null;\n      } else {\n        if (ch === '\"' || ch === \"'\") inQuote = ch;\n        else if (ch === '>') {\n          selfClosing = data[i - 1] === '/';\n          i++; // Include '>'\n          break;\n        }\n      }\n      i++;\n    }\n\n    if (i >= len) {\n      // Didn't reach '>'\n      cutPos = tagStart;\n      break;\n    }\n\n    /* Maintain stack ------------------------------------------------------ */\n    if (selfClosing) continue;\n\n    if (closing) {\n      for (let j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].name === tagName) {\n          stack.splice(j, 1);\n          break;\n        }\n      }\n    } else {\n      stack.push({ name: tagName, pos: tagStart });\n    }\n  }\n\n  /* Calculate final cut point -------------------------------------------------- */\n  if (stack.length > 0) {\n    const firstUnmatched = stack[0].pos;\n    cutPos = cutPos === -1 ? firstUnmatched : Math.min(cutPos, firstUnmatched);\n  }\n\n  return cutPos === -1 ? data : [data.slice(0, cutPos), data.slice(cutPos)];\n};\n","import { type Token, marked } from 'marked';\n\nexport type ParseMarkdownBlocksOptions = {\n  /**\n   * Token types to exclude from the output.\n   *\n   * @default ['space']\n   */\n  exclude?: string[];\n  /**\n   * Whether to trim the content.\n   *\n   * @default true\n   */\n  trim?: boolean;\n};\n\nexport const parseMarkdownBlocks = (\n  content: string,\n  { exclude = ['space'], trim = true }: ParseMarkdownBlocksOptions = {}\n): Token[] => {\n  let tokens = [...marked.lexer(content)];\n\n  if (exclude.length > 0) {\n    tokens = tokens.filter((token) => !exclude.includes(token.type));\n  }\n  if (trim) {\n    tokens = tokens.map((token) => ({\n      ...token,\n      raw: token.raw.trimEnd(),\n    }));\n  }\n\n  return tokens;\n};\n","import type { Descendant } from 'platejs';\n\nimport type { MdRootContent } from '../mdast';\nimport type { MdDecoration } from '../types';\nimport type { DeserializeMdOptions } from './deserializeMd';\n\nimport { mdastToPlate } from '../types';\nimport { customMdxDeserialize } from './utils';\nimport { getDeserializerByKey } from './utils/getDeserializerByKey';\n\nexport const convertNodesDeserialize = (\n  nodes: MdRootContent[],\n  deco: MdDecoration,\n  options: DeserializeMdOptions\n): Descendant[] => {\n  return nodes.reduce<Descendant[]>((acc, node) => {\n    // Only process nodes that pass the filtering\n    if (shouldIncludeNode(node, options)) {\n      acc.push(...buildSlateNode(node, deco, options));\n    }\n    return acc;\n  }, []);\n};\n\nexport const buildSlateNode = (\n  mdastNode: MdRootContent,\n  deco: MdDecoration,\n  options: DeserializeMdOptions\n): Descendant[] => {\n  /** Handle custom mdx nodes */\n  if (\n    mdastNode.type === 'mdxJsxTextElement' ||\n    mdastNode.type === 'mdxJsxFlowElement'\n  ) {\n    const result = customMdxDeserialize(mdastNode, deco, options);\n    return Array.isArray(result) ? result : [result];\n  }\n\n  const type = mdastToPlate(options.editor!, mdastNode.type);\n\n  const nodeParser = getDeserializerByKey(type, options);\n\n  if (nodeParser) {\n    const result = nodeParser(mdastNode as any, deco, options);\n    return Array.isArray(result) ? result : [result];\n  }\n  return [];\n};\n\nconst shouldIncludeNode = (\n  node: MdRootContent,\n  options: DeserializeMdOptions\n): boolean => {\n  const { allowedNodes, allowNode, disallowedNodes } = options;\n\n  if (!node.type) return true;\n\n  const type = mdastToPlate(options.editor!, node.type);\n\n  // First check allowedNodes/disallowedNodes\n  if (\n    allowedNodes &&\n    disallowedNodes &&\n    allowedNodes.length > 0 &&\n    disallowedNodes.length > 0\n  ) {\n    throw new Error('Cannot combine allowedNodes with disallowedNodes');\n  }\n\n  if (allowedNodes) {\n    // If allowedNodes is specified, only include if the type is in allowedNodes\n    if (!allowedNodes.includes(type)) {\n      return false;\n    }\n  } else if (disallowedNodes?.includes(type)) {\n    // If using disallowedNodes, exclude if the type is in disallowedNodes\n    return false;\n  }\n\n  // Finally, check allowNode if provided\n  if (allowNode?.deserialize) {\n    return allowNode.deserialize({\n      ...node,\n      type,\n    });\n  }\n\n  return true;\n};\n","import type { Descendant } from 'platejs';\n\nimport type { MdRootContent } from '../mdast';\nimport type { MdDecoration } from '../types';\nimport type { DeserializeMdOptions } from './deserializeMd';\n\nimport { convertNodesDeserialize } from './convertNodesDeserialize';\n\nexport const convertChildrenDeserialize = (\n  children: MdRootContent[],\n  deco: MdDecoration,\n  options: DeserializeMdOptions\n): Descendant[] => {\n  if (children.length === 0) {\n    return [{ text: '' }];\n  }\n\n  return convertNodesDeserialize(children, deco, options);\n};\n","import { getPluginType } from 'platejs';\n\nimport type { MdDelete, MdEmphasis, MdStrong } from '../mdast';\nimport type { MdDecoration } from '../types';\nimport type { DeserializeMdOptions } from './deserializeMd';\n\nimport { mdastToPlate } from '../types';\nimport { buildSlateNode } from './convertNodesDeserialize';\n\nexport const convertTextsDeserialize = (\n  mdastNode: MdDelete | MdEmphasis | MdStrong,\n  deco: MdDecoration,\n  options: DeserializeMdOptions\n) => {\n  return mdastNode.children.reduce((acc: any, n: any) => {\n    const key = mdastToPlate(options.editor!, mdastNode.type);\n    const type = getPluginType(options.editor!, key);\n\n    acc.push(...buildSlateNode(n, { ...deco, [type]: true }, options));\n    return acc;\n  }, []);\n};\n","import baseRemarkMdx from 'remark-mdx';\n\nimport { REMARK_MDX_TAG, tagRemarkPlugin } from '../utils';\n\nexport const remarkMdx = tagRemarkPlugin(\n  baseRemarkMdx,\n  REMARK_MDX_TAG\n) as typeof baseRemarkMdx;\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return '\\u001B[33m' + d + '\\u001B[39m'\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn’t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when it’s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","import type { Node, Parent, RootContent, Text } from 'mdast';\nimport type { Plugin } from 'unified';\n\nimport { visit } from 'unist-util-visit';\n\nexport interface MentionNode {\n  children: { type: 'text'; value: string }[];\n  type: 'mention';\n  username: string;\n  displayText?: string;\n}\n\ndeclare module 'mdast' {\n  interface StaticPhrasingContentMap {\n    mention: MentionNode;\n  }\n}\n\n/**\n * A remark plugin that converts @username patterns and [display\n * text](mention:id) patterns in text nodes into mention nodes. This plugin runs\n * after remark-gfm and transforms mention patterns into special mention nodes\n * that can be later converted into Plate mention elements.\n *\n * Supports two formats:\n *\n * - @username - Simple mention format (no spaces allowed)\n * - [display text](mention:id) - Markdown link-style format (supports spaces)\n */\nexport const remarkMention: Plugin = function () {\n  return (tree: Node) => {\n    // First, convert link nodes with mention: protocol to mention nodes\n    visit(\n      tree,\n      'link',\n      (node: any, index: number, parent: Parent | undefined) => {\n        if (!parent || typeof index !== 'number') return;\n\n        // Check if this is a mention link\n        if (node.url?.startsWith('mention:')) {\n          let username = node.url.slice('mention:'.length);\n          // Decode URL-encoded spaces and special characters\n          username = decodeURIComponent(username);\n          const displayText = node.children?.[0]?.value || username;\n\n          const mentionNode: MentionNode = {\n            children: [{ type: 'text', value: displayText }],\n            displayText: displayText,\n            type: 'mention',\n            username: username,\n          };\n\n          parent.children[index] = mentionNode as any;\n        }\n      }\n    );\n\n    // Then process text nodes for @mentions\n    visit(\n      tree,\n      'text',\n      (node: Text, index: number, parent: Parent | undefined) => {\n        if (!parent || typeof index !== 'number') return;\n\n        // Pattern for @username mentions (no spaces)\n        // Matches @username but excludes trailing punctuation\n        const atMentionPattern = /(?:^|\\s)@([a-zA-Z0-9_-]+)(?=[\\s.,;:!?)]|$)/g;\n\n        const parts: (MentionNode | Text)[] = [];\n        let lastIndex = 0;\n\n        const text = node.value;\n        const allMatches: { end: number; node: MentionNode; start: number }[] =\n          [];\n\n        // Find all @username mentions\n        let match;\n        while ((match = atMentionPattern.exec(text)) !== null) {\n          const mentionStart = match[0].startsWith(' ')\n            ? match.index + 1\n            : match.index;\n          const mentionEnd =\n            mentionStart + match[0].length - (match[0].startsWith(' ') ? 1 : 0);\n\n          allMatches.push({\n            end: mentionEnd,\n            node: {\n              children: [{ type: 'text', value: `@${match[1]}` }],\n              type: 'mention',\n              username: match[1],\n            },\n            start: mentionStart,\n          });\n        }\n\n        // Sort matches by start position\n        allMatches.sort((a, b) => a.start - b.start);\n\n        // Build the parts array\n        for (const matchInfo of allMatches) {\n          if (matchInfo.start > lastIndex) {\n            parts.push({\n              type: 'text',\n              value: text.slice(lastIndex, matchInfo.start),\n            });\n          }\n          parts.push(matchInfo.node);\n          lastIndex = matchInfo.end;\n        }\n\n        if (lastIndex < text.length) {\n          parts.push({\n            type: 'text',\n            value: text.slice(lastIndex),\n          });\n        }\n\n        if (parts.length > 0) {\n          parent.children.splice(index, 1, ...(parts as RootContent[]));\n        }\n      }\n    );\n  };\n};\n"],"mappings":"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","names":["Symbol","Symbol","Symbol","Symbol","kebabCase","KEYS","getPluginKey","getPluginType","KEYS","getPluginKey","getPluginType","KEYS","getPluginKey","getPluginType","KEYS","getPluginType","kebabCase","color","key","getPluginType","getPluginType","KEYS","getPluginKey","remarkStringify","unified","unified","remarkStringify","getPluginType","KEYS","children","getPluginKey","startIndex","result","index","getPluginKey","getPluginType","KEYS","getPluginType","KEYS","getPluginKey","KEYS","TextApi","unified","getPluginKey","KEYS","getPluginKey","KEYS","unified","TextApi","getPluginKey","KEYS","getPluginType","KEYS","shouldIncludeNode","getPluginType","getPluginType","KEYS","index","is","visit"]}