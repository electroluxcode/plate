{"version":3,"sources":["../src/index.ts","../src/lib/BaseYjsPlugin.ts","../../../node_modules/lib0/math.js","../../../node_modules/lib0/set.js","../../../node_modules/lib0/array.js","../../../node_modules/lib0/time.js","../../../node_modules/lib0/map.js","../../../node_modules/lib0/observable.js","../../../node_modules/lib0/object.js","../../../node_modules/lib0/traits.js","../../../node_modules/lib0/function.js","../../../node_modules/y-protocols/awareness.js","../src/utils/slateToDeterministicYjsState.ts","../src/lib/providers/hocuspocus-provider.ts","../src/lib/providers/webrtc-provider.ts","../src/lib/providers/registry.ts","../src/lib/withPlateYjs.ts","../src/lib/withTCursors.ts","../src/lib/withTYHistory.ts","../src/lib/withTYjs.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\nexport * from './utils/index';\n","import { YjsEditor } from '@slate-yjs/core';\nimport {\n  type InitOptions,\n  type Value,\n  createTSlatePlugin,\n  KEYS,\n} from 'platejs';\nimport { Awareness } from 'y-protocols/awareness';\nimport * as Y from 'yjs';\n\nimport { slateToDeterministicYjsState } from '../utils/slateToDeterministicYjsState';\nimport {\n  type UnifiedProvider,\n  type YjsConfig,\n  type YjsProviderConfig,\n  type YjsProviderType,\n  createProvider,\n} from './providers';\nimport { withPlateYjs } from './withPlateYjs';\n\n// Helper to check if an object is a provider config\nconst isProviderConfig = (\n  item: UnifiedProvider | YjsProviderConfig\n): item is YjsProviderConfig => {\n  return (\n    typeof item === 'object' &&\n    item !== null &&\n    'type' in item &&\n    'options' in item\n  );\n};\n\nexport const BaseYjsPlugin = createTSlatePlugin<YjsConfig>({\n  key: KEYS.yjs,\n  extendEditor: withPlateYjs,\n  options: {\n    _isConnected: false,\n    _isSynced: false,\n    _providers: [],\n    awareness: null!,\n    cursors: {},\n    localOrigin: null,\n    positionStorageOrigin: null,\n    providers: [],\n    ydoc: null!,\n    onConnect: () => {},\n    onDisconnect: () => {},\n    onError: () => {},\n    onSyncChange: () => {},\n  },\n})\n  .extend(({ getOptions }) => {\n    const { localOrigin, positionStorageOrigin, ...options } = getOptions();\n    let { awareness, ydoc } = options;\n\n    if (!ydoc) {\n      ydoc = new Y.Doc();\n    }\n\n    if (!awareness) {\n      awareness = new Awareness(ydoc);\n    }\n\n    return {\n      options: {\n        awareness,\n        localOrigin: localOrigin ?? undefined,\n        positionStorageOrigin: positionStorageOrigin ?? undefined,\n        ydoc,\n      },\n    };\n  })\n  .extendApi((ctx) => ({\n    /**\n     * Connect to all providers or specific provider types.\n     *\n     * @param type Optional provider type(s) to connect to. If not specified,\n     *   connects to all providers.\n     */\n    connect: (type?: YjsProviderType | YjsProviderType[]) => {\n      const { getOptions } = ctx;\n      const { _providers } = getOptions();\n      const typesToConnect = type\n        ? Array.isArray(type)\n          ? type\n          : [type]\n        : null;\n\n      _providers.forEach((provider) => {\n        if (!typesToConnect || typesToConnect.includes(provider.type)) {\n          try {\n            provider.connect();\n          } catch (error) {\n            getOptions().onError?.({\n              error: error instanceof Error ? error : new Error(String(error)),\n              type: provider.type,\n            });\n          }\n        }\n      });\n    },\n\n    /**\n     * Disconnect from all providers or specific provider types. For WebRTC\n     * providers, we should NOT disconnect on cleanup as it will clear the\n     * awareness state. Instead, we'll let the providers handle their own\n     * cleanup via their internal mechanisms.\n     *\n     * @param providerType Optional provider type(s) to disconnect from. If not\n     *   specified, disconnects from all providers.\n     */\n    destroy: () => {\n      const { editor, getOptions } = ctx;\n      const { _providers } = getOptions();\n\n      for (const provider of [..._providers].reverse()) {\n        try {\n          if (provider.isConnected) {\n            provider.destroy();\n          }\n        } catch (error) {\n          console.warn(\n            `[yjs] Error disconnecting provider (${provider.type}):`,\n            error\n          );\n        }\n      }\n\n      try {\n        YjsEditor.disconnect(editor as any);\n      } catch (error) {}\n    },\n    /**\n     * Disconnect from all providers or specific provider types. For WebRTC\n     * providers, we should NOT disconnect on cleanup as it will clear the\n     * awareness state. Instead, we'll let the providers handle their own\n     * cleanup via their internal mechanisms.\n     *\n     * @param providerType Optional provider type(s) to disconnect from. If not\n     *   specified, disconnects from all providers.\n     */\n    disconnect: (type?: YjsProviderType | YjsProviderType[]) => {\n      const { editor, getOptions } = ctx;\n      const { _providers } = getOptions();\n\n      const typesToDisconnect = type\n        ? Array.isArray(type)\n          ? type\n          : [type]\n        : null;\n\n      for (const provider of [..._providers].reverse()) {\n        try {\n          if (\n            provider.isConnected &&\n            (typesToDisconnect === null ||\n              typesToDisconnect.includes(provider.type))\n          ) {\n            provider.disconnect();\n          }\n        } catch (error) {\n          console.warn(\n            `[yjs] Error disconnecting provider (${provider.type}):`,\n            error\n          );\n        }\n      }\n    },\n\n    /** Initialize yjs, providers connection and editor state. */\n    init: async ({\n      id,\n      autoConnect = true,\n      autoSelect,\n      selection,\n      value,\n    }: {\n      /**\n       * Id of the document.\n       *\n       * @default editor.id\n       */\n      id?: string;\n      /**\n       * Whether to automatically connect to providers.\n       *\n       * @default true\n       */\n      autoConnect?: boolean;\n    } & Omit<InitOptions, 'shouldNormalizeEditor'> = {}) => {\n      const { editor, getOptions, setOption } = ctx;\n\n      const options = getOptions();\n      const {\n        _providers,\n        awareness,\n        providers: providerConfigsOrInstances = [],\n        ydoc,\n      } = options;\n\n      // Validate configuration\n      if (providerConfigsOrInstances.length === 0) {\n        throw new Error(\n          'No providers specified. Please provide provider configurations or instances in the `providers` array.'\n        );\n      }\n\n      if (value !== null) {\n        let initialNodes = value as Value;\n        if (typeof value === 'string') {\n          initialNodes = editor.api.html.deserialize({\n            element: value,\n          }) as Value;\n        } else if (typeof value === 'function') {\n          initialNodes = await value(editor);\n        } else if (value) {\n          initialNodes = value;\n        }\n        if (!initialNodes || initialNodes?.length === 0) {\n          initialNodes = editor.api.create.value();\n        }\n\n        const initialDelta = await slateToDeterministicYjsState(\n          id ?? editor.id,\n          initialNodes\n        );\n        ydoc.transact(() => {\n          Y.applyUpdate(ydoc, initialDelta);\n        });\n      }\n\n      // Final providers array that will contain both configured and custom providers\n      const finalProviders: UnifiedProvider[] = [];\n\n      // Connect the YjsEditor first to set up slate-yjs bindings.\n      YjsEditor.connect(editor as any);\n\n      editor.tf.init({\n        autoSelect,\n        selection,\n        // Skipped since YjsEditor.connect already normalizes the editor\n        shouldNormalizeEditor: false,\n        value: null,\n      });\n\n      // Then process and create providers\n      for (const item of providerConfigsOrInstances) {\n        if (isProviderConfig(item)) {\n          // It's a configuration object, create the provider\n          const { options, type } = item;\n\n          if (!options) {\n            console.warn(\n              `[yjs] No options provided for provider type: ${type}`\n            );\n            continue;\n          }\n\n          try {\n            // Create provider with shared handlers, Y.Doc, and Awareness\n            const provider = createProvider({\n              awareness,\n              doc: ydoc,\n              options,\n              type,\n              onConnect: () => {\n                getOptions().onConnect?.({ type });\n                // At least one provider is connected\n                setOption('_isConnected', true);\n              },\n              onDisconnect: () => {\n                getOptions().onDisconnect?.({ type });\n\n                // Check for any connected providers\n                const { _providers } = getOptions();\n                const hasConnectedProvider = _providers.some(\n                  (provider) => provider.isConnected\n                );\n                if (!hasConnectedProvider) {\n                  setOption('_isConnected', false);\n                }\n              },\n              onError: (error) => {\n                getOptions().onError?.({ error, type });\n              },\n              onSyncChange: (isSynced) => {\n                getOptions().onSyncChange?.({ isSynced, type });\n                setOption('_isSynced', isSynced);\n              },\n            });\n            finalProviders.push(provider);\n          } catch (error) {\n            console.warn(\n              `[yjs] Error creating provider of type ${type}:`,\n              error\n            );\n          }\n        } else {\n          // It's a pre-instantiated UnifiedProvider instance\n          const customProvider = item;\n\n          // Check if the provider's document matches our shared document\n          if (customProvider.document !== ydoc) {\n            console.warn(\n              `[yjs] Custom provider instance (${customProvider.type}) has a different Y.Doc. ` +\n                'This may cause synchronization issues. Ensure custom providers use the shared Y.Doc.'\n            );\n          }\n          // Check if the provider's awareness matches our shared awareness\n          if (customProvider.awareness !== awareness) {\n            console.warn(\n              `[yjs] Custom provider instance (${customProvider.type}) has a different Awareness instance. ` +\n                'Ensure custom providers use the shared Awareness instance for cursor consistency.'\n            );\n          }\n\n          // Add the custom provider to our providers array\n          finalProviders.push(customProvider);\n        }\n      }\n\n      if (finalProviders.length === 0) {\n        console.warn(\n          '[yjs] No providers were successfully created or provided.'\n        );\n      }\n\n      // Update provider counts after creation\n      setOption('_providers', finalProviders);\n\n      // Finally, connect providers if autoConnect is true\n      if (autoConnect) {\n        _providers.forEach((provider) => {\n          try {\n            provider.connect();\n          } catch (error) {\n            getOptions().onError?.({\n              error: error instanceof Error ? error : new Error(String(error)),\n              type: provider.type,\n            });\n          }\n        });\n      }\n    },\n  }));\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set =>\n  set.values().next().value ?? undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n\n/**\n * This function bubble-sorts a single item to the correct position. The sort happens in-place and\n * might be useful to ensure that a single item is at the correct position in an otherwise sorted\n * array.\n *\n * @example\n *  const arr = [3, 2, 5]\n *  arr.sort((a, b) => a - b)\n *  arr // => [2, 3, 5]\n *  arr.splice(1, 0, 7)\n *  array.bubbleSortItem(arr, 1, (a, b) => a - b)\n *  arr // => [2, 3, 5, 7]\n *\n * @template T\n * @param {Array<T>} arr\n * @param {number} i\n * @param {(a:T,b:T) => number} compareFn\n */\nexport const bubblesortItem = (arr, i, compareFn) => {\n  const n = arr[i]\n  let j = i\n  // try to sort to the right\n  while (j + 1 < arr.length && compareFn(n, arr[j + 1]) > 0) {\n    arr[j] = arr[j + 1]\n    arr[++j] = n\n  }\n  if (i === j && j > 0) { // no change yet\n    // sort to the left\n    while (j > 0 && compareFn(arr[j - 1], n) > 0) {\n      arr[j] = arr[j - 1]\n      arr[--j] = n\n    }\n  }\n  return j\n}\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10μs.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const size = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|null|undefined} obj\n */\nexport const isEmpty = obj => {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (size(a) === size(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n\n/**\n * Make an object immutable. This hurts performance and is usually not needed if you perform good\n * coding practices.\n */\nexport const freeze = Object.freeze\n\n/**\n * Make an object and all its children immutable.\n * This *really* hurts performance and is usually not needed if you perform good coding practices.\n *\n * @template {any} T\n * @param {T} o\n * @return {Readonly<T>}\n */\nexport const deepFreeze = (o) => {\n  for (const key in o) {\n    const c = o[key]\n    if (typeof c === 'object' || typeof c === 'function') {\n      deepFreeze(o[key])\n    }\n  }\n  return freeze(o)\n}\n","export const EqualityTraitSymbol = Symbol('Equality')\n\n/**\n * @typedef {{ [EqualityTraitSymbol]:(other:EqualityTrait)=>boolean }} EqualityTrait\n */\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\nimport * as traits from './traits.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((array.isArray(a) && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a === b) {\n    return true\n  }\n  if (a == null || b == null || a.constructor !== b.constructor) {\n    return false\n  }\n  if (a[traits.EqualityTraitSymbol] != null) {\n    return a[traits.EqualityTraitSymbol](b)\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nexport const isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nexport const isArray = array.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nexport const isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nexport const isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nexport const is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nexport const isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n","/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n","import type { Value } from 'platejs';\n\nimport { slateNodesToInsertDelta } from '@slate-yjs/core';\nimport * as Y from 'yjs';\n\n/**\n * Produce the canonical \"initial update\" from a Slate node array using a\n * deterministically generated clientID based on guid and initialNodes.\n *\n * Every peer can call this _locally_ and get **bit‑identical** bytes, provided\n * `guid` and `initialNodes` are the same.\n */\nexport async function slateToDeterministicYjsState(\n  guid: string, // use doc/room id\n  initialNodes: Value // your template\n): Promise<Uint8Array> {\n  //  Generate clientID deterministically\n  const deterministicClientId = await generateDeterministicClientId(\n    guid,\n    initialNodes\n  );\n\n  // 2Build the update in a temp doc with the deterministic clientID\n  const tmp = new Y.Doc({ guid });\n  tmp.clientID = deterministicClientId;\n\n  const delta = slateNodesToInsertDelta(initialNodes);\n  const content = tmp.get('content', Y.XmlText) as Y.XmlText;\n  content.applyDelta(delta);\n  const initialUpdate = Y.encodeStateAsUpdate(tmp);\n  tmp.destroy();\n  return initialUpdate;\n}\n\n// Helper to convert ArrayBuffer to a non-negative 31-bit integer + 1\nfunction arrayBufferToClientId(buffer: ArrayBuffer): number {\n  const dataView = new DataView(buffer);\n  // Use the first 4 bytes (32 bits)\n  const int32 = dataView.getInt32(0, false); // false for big-endian\n  // Take absolute value, modulo 2^31 - 1 to fit in signed 31 bits, and add 1 to ensure non-zero.\n  // (2**31 - 1 is 0x7FFFFFFF)\n  // eslint-disable-next-line unicorn/number-literal-case\n  return (Math.abs(int32) % 0x7f_ff_ff_ff) + 1;\n}\n\n/**\n * Generates a deterministic Yjs clientID based on a GUID and initial Slate\n * nodes using the Web Crypto API (SHA-256).\n */\nasync function generateDeterministicClientId(\n  guid: string,\n  initialNodes: Value\n): Promise<number> {\n  const nodesString = JSON.stringify(initialNodes);\n  const combinedString = `${guid}-${nodesString}`;\n  const encoder = new TextEncoder();\n  const data = encoder.encode(combinedString);\n  const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);\n\n  return arrayBufferToClientId(hashBuffer);\n}\n","import type {\n  HocuspocusProviderConfiguration,\n  onDisconnectParameters,\n  onSyncedParameters,\n} from '@hocuspocus/provider';\nimport type { Awareness } from 'y-protocols/awareness';\nimport type * as Y from 'yjs';\n\nimport { HocuspocusProvider } from '@hocuspocus/provider';\n\nimport type {\n  ProviderEventHandlers,\n  UnifiedProvider,\n  YjsProviderType,\n} from './types';\n\nexport class HocuspocusProviderWrapper implements UnifiedProvider {\n  private _isConnected = false;\n  private _isSynced = false;\n  private onConnect?: () => void;\n  private onDisconnect?: () => void;\n  private onError?: (error: Error) => void;\n  private onSyncChange?: (isSynced: boolean) => void;\n  private provider: HocuspocusProvider;\n\n  destroy = () => {\n    if (this._isConnected) {\n      this.provider.disconnect();\n    }\n  };\n  disconnect = () => {\n    if (this._isConnected) {\n      this.provider.disconnect();\n      this._isConnected = false;\n\n      // If we were synced, notify about sync state change\n      if (this._isSynced) {\n        this._isSynced = false;\n        this?.onSyncChange?.(false);\n      }\n    }\n  };\n\n  type: YjsProviderType = 'hocuspocus';\n\n  constructor({\n    awareness,\n    doc,\n    options,\n    onConnect,\n    onDisconnect,\n    onError,\n    onSyncChange,\n  }: {\n    options: HocuspocusProviderConfiguration;\n    awareness?: Awareness;\n    doc?: Y.Doc;\n  } & ProviderEventHandlers) {\n    this.onConnect = onConnect;\n    this.onDisconnect = onDisconnect;\n    this.onSyncChange = onSyncChange;\n    this.onError = onError;\n\n    // If an existing Y.Doc is provided, ensure it's passed to the HocuspocusProvider\n    const providerOptions: HocuspocusProviderConfiguration = {\n      ...options,\n      ...(doc && { document: doc }),\n      ...(awareness && { awareness }),\n      // Disable broadcast channel here - we'll manually handle connections\n      broadcast: options.broadcast || false,\n      onAwarenessChange: options.onAwarenessChange || (() => {}),\n      onConnect: () => {\n        this._isConnected = true;\n        this.onConnect?.();\n        options.onConnect?.();\n      },\n      onDisconnect: (data: onDisconnectParameters) => {\n        this._isConnected = false;\n\n        // If we were synced, notify about sync state change\n        if (this._isSynced) {\n          this._isSynced = false;\n          this.onSyncChange?.(false);\n        }\n\n        this.onDisconnect?.();\n        options.onDisconnect?.(data);\n      },\n      onSynced: (data: onSyncedParameters) => {\n        const wasSynced = this._isSynced;\n        this._isSynced = true;\n\n        // Call onSyncChange only when sync state changes\n        if (!wasSynced) {\n          this.onSyncChange?.(true);\n        }\n\n        options.onSynced?.(data);\n      },\n    };\n\n    try {\n      this.provider = new HocuspocusProvider(providerOptions);\n    } catch (error) {\n      // Create a minimal provider that won't try to connect\n      this.provider = new HocuspocusProvider({\n        ...providerOptions,\n        connect: false,\n      });\n      this.onError?.(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  connect() {\n    try {\n      void this.provider.connect();\n    } catch (error) {\n      this._isConnected = false;\n    }\n  }\n\n  get awareness() {\n    return this.provider.awareness!;\n  }\n\n  get document() {\n    return this.provider.document;\n  }\n\n  get isConnected() {\n    return this._isConnected;\n  }\n\n  get isSynced() {\n    return this._isSynced;\n  }\n}\n","import type { Awareness } from 'y-protocols/awareness';\n\nimport { WebrtcProvider as YWebrtcProvider } from 'y-webrtc';\nimport * as Y from 'yjs';\n\nimport type {\n  ProviderEventHandlers,\n  UnifiedProvider,\n  WebRTCProviderOptions,\n  YjsProviderType,\n} from './types';\n\nexport class WebRTCProviderWrapper implements UnifiedProvider {\n  // Track connection and sync state\n  private _isConnected = false;\n  private _isSynced = false;\n  private doc: Y.Doc;\n\n  private onConnect?: () => void;\n  private onDisconnect?: () => void;\n  private onError?: (error: Error) => void;\n  private onSyncChange?: (isSynced: boolean) => void;\n  // Create a fallback awareness instance for when provider is null\n  private provider: YWebrtcProvider | null = null;\n\n  connect = () => {\n    if (this.provider) {\n      try {\n        this.provider.connect();\n      } catch (error) {\n        console.warn('[yjs] Error connecting WebRTC provider:', error);\n      }\n    }\n  };\n\n  destroy = () => {\n    if (this.provider) {\n      try {\n        this.provider.destroy();\n      } catch (error) {\n        console.warn('[yjs] Error destroying WebRTC provider:', error);\n      }\n    }\n  };\n\n  disconnect = () => {\n    if (this.provider) {\n      try {\n        this.provider.disconnect();\n        const wasSynced = this._isSynced;\n\n        this._isConnected = false;\n        this._isSynced = false;\n\n        // If we were synced, notify about sync state change\n        if (wasSynced) {\n          this.onSyncChange?.(false);\n        }\n      } catch (error) {\n        console.warn('[yjs] Error disconnecting WebRTC provider:', error);\n      }\n    }\n  };\n\n  type: YjsProviderType = 'webrtc';\n\n  // Autoconnects when created\n  constructor({\n    awareness,\n    doc,\n    options,\n    onConnect,\n    onDisconnect,\n    onError,\n    onSyncChange,\n  }: {\n    options: WebRTCProviderOptions;\n    awareness?: Awareness;\n    doc?: Y.Doc;\n  } & ProviderEventHandlers) {\n    this.onConnect = onConnect;\n    this.onDisconnect = onDisconnect;\n    this.onError = onError;\n    this.onSyncChange = onSyncChange;\n\n    this.doc = doc || new Y.Doc();\n    try {\n      this.provider = new YWebrtcProvider(options.roomName, this.doc, {\n        awareness: awareness,\n        filterBcConns: options.filterBcConns,\n        maxConns: options.maxConns,\n        password: options.password,\n        peerOpts: options.peerOpts,\n        signaling: options.signaling,\n      });\n\n      // Set connection status\n      this.provider.on('status', (status: { connected: boolean }) => {\n        const wasConnected = this._isConnected;\n        this._isConnected = status.connected;\n\n        if (status.connected) {\n          // Notify about connection only if it wasn't connected before\n          if (!wasConnected) {\n            onConnect?.();\n          }\n          // Treat first connection as sync for P2P, trigger sync change if not already synced\n          if (!this._isSynced) {\n            this._isSynced = true;\n            onSyncChange?.(true);\n          }\n        } else {\n          // Handle disconnection only if it was connected before\n          if (wasConnected) {\n            onDisconnect?.();\n\n            // Explicitly set synced to false on disconnect if it was true\n            // This ensures onSyncChange(false) is called reliably\n            if (this._isSynced) {\n              this._isSynced = false;\n              onSyncChange?.(false);\n            }\n          }\n        }\n      });\n    } catch (error) {\n      console.warn('[yjs] Error creating WebRTC provider:', error);\n      onError?.(error instanceof Error ? error : new Error(String(error)));\n      // Don't throw, just log the error - the provider will be null\n    }\n  }\n\n  get awareness(): Awareness {\n    return this.provider!.awareness;\n  }\n\n  get document() {\n    return this.doc;\n  }\n\n  get isConnected() {\n    return this._isConnected;\n  }\n\n  get isSynced() {\n    return this._isSynced;\n  }\n}\n","import type {\n  ProviderConstructor,\n  ProviderConstructorProps,\n  ProviderRegistry,\n  YjsProviderType,\n} from './types';\n\nimport { HocuspocusProviderWrapper } from './hocuspocus-provider';\nimport { WebRTCProviderWrapper } from './webrtc-provider';\n\n// Provider registry for extensibility\nconst providerRegistry: ProviderRegistry = {\n  hocuspocus: HocuspocusProviderWrapper,\n  webrtc: WebRTCProviderWrapper,\n};\n\n// Register a new provider type\nexport const registerProviderType = <T>(\n  type: string,\n  providerClass: ProviderConstructor<T>\n) => {\n  providerRegistry[type as YjsProviderType] =\n    providerClass as ProviderConstructor;\n};\n\n// Get a provider constructor by type\nexport const getProviderClass = (\n  type: YjsProviderType\n): ProviderConstructor | undefined => {\n  return providerRegistry[type];\n};\n\n// Create a provider instance\nexport const createProvider = ({\n  type,\n  ...props\n}: ProviderConstructorProps & {\n  type: YjsProviderType;\n}) => {\n  const ProviderClass = getProviderClass(type);\n\n  if (!ProviderClass) {\n    throw new Error(`Provider type \"${type}\" not found in registry`);\n  }\n\n  return new ProviderClass(props);\n};\n","import type { ExtendEditor, SlateEditor } from 'platejs';\n\nimport * as Y from 'yjs';\n\nimport type { YjsConfig } from './providers/types';\n\nimport { type PlateYjsEditorProps, withTCursors } from './withTCursors';\nimport { withTYHistory } from './withTYHistory';\nimport { type YjsEditorProps, withTYjs } from './withTYjs';\n\nexport const withPlateYjs: ExtendEditor<YjsConfig> = ({\n  editor: e,\n  getOptions,\n}) => {\n  let editor = e as unknown as PlateYjsEditorProps &\n    SlateEditor &\n    YjsEditorProps;\n\n  const { awareness, cursors, localOrigin, positionStorageOrigin, ydoc } =\n    getOptions();\n\n  // Get the shared document type from the Y.Doc\n  const sharedType = ydoc!.get('content', Y.XmlText) as Y.XmlText;\n\n  // Apply core Yjs binding first\n  editor = withTYjs(editor, sharedType, {\n    autoConnect: false,\n    localOrigin,\n    positionStorageOrigin,\n  }) as any;\n\n  // Apply YJS transformations to the editor\n  // Conditionally apply cursor support based on cursors\n  if (cursors) {\n    // Use the shared awareness instance for cursors\n    if (awareness) {\n      let autoSend = true;\n\n      if (cursors.autoSend === false) {\n        autoSend = false;\n      }\n\n      editor = withTCursors(editor, awareness, {\n        ...cursors,\n        autoSend,\n      });\n    } else {\n      // This also shouldn't happen if BaseYjsPlugin ran correctly\n      editor.api.debug.error(\n        'Yjs plugin: Internal shared awareness (awareness) is missing but cursors are enabled.'\n      );\n    }\n  }\n\n  // Apply history last\n  return withTYHistory(editor);\n};\n","import type { SlateEditor } from 'platejs';\nimport type { Awareness } from 'y-protocols/awareness';\n\nimport {\n  type CursorEditor,\n  type WithCursorsOptions,\n  withCursors,\n} from '@slate-yjs/core';\n\nimport type { YjsEditorProps } from './withTYjs';\n\nexport type PlateYjsEditorProps = Pick<\n  CursorEditor,\n  | 'awareness'\n  | 'cursorDataField'\n  | 'selectionStateField'\n  | 'sendCursorData'\n  | 'sendCursorPosition'\n> &\n  YjsEditorProps;\n\nexport const withTCursors = <TCursorData extends Record<string, unknown>>(\n  editor: SlateEditor,\n  awareness: Awareness,\n  options?: WithCursorsOptions<TCursorData>\n) =>\n  withCursors(editor as any, awareness, options) as PlateYjsEditorProps &\n    SlateEditor &\n    YjsEditorProps;\n","import type { SlateEditor } from 'platejs';\nimport type * as Y from 'yjs';\n\nimport {\n  type WithYHistoryOptions,\n  type YjsEditor,\n  withYHistory,\n} from '@slate-yjs/core';\n\nimport type { YjsEditorProps } from './withTYjs';\n\nexport type YHistoryEditor = {\n  undoManager: Y.UndoManager;\n  withoutSavingOrigin: unknown;\n  redo: () => void;\n  undo: () => void;\n} & YjsEditor;\n\nexport type YHistoryEditorProps = Pick<\n  YHistoryEditor,\n  'redo' | 'undo' | 'undoManager' | 'withoutSavingOrigin'\n> &\n  YjsEditorProps;\n\nexport const withTYHistory = (\n  editor: SlateEditor,\n  options?: WithYHistoryOptions\n) =>\n  withYHistory(editor as any, options) as SlateEditor &\n    YHistoryEditorProps &\n    YjsEditorProps;\n","import type { Operation, SlateEditor } from 'platejs';\nimport type * as Y from 'yjs';\n\nimport { type YjsEditor, withYjs } from '@slate-yjs/core';\n\nexport type WithYjsOptions = {\n  /**\n   * Whether to automatically connect to providers.\n   *\n   * @default false\n   */\n  autoConnect?: boolean;\n  /** Origin used when applying local slate operations to yjs. */\n  localOrigin?: unknown;\n  /** Origin used when storing positions. */\n  positionStorageOrigin?: unknown;\n};\n\nexport type YjsEditorProps = {\n  storeLocalChange: (op: Operation) => void;\n} & Pick<\n  YjsEditor,\n  | 'applyRemoteEvents'\n  | 'connect'\n  | 'disconnect'\n  | 'flushLocalChanges'\n  | 'isLocalOrigin'\n  | 'localOrigin'\n  | 'positionStorageOrigin'\n  | 'sharedRoot'\n>;\n\nexport const withTYjs = (\n  editor: SlateEditor,\n  sharedRoot: Y.XmlText,\n  options?: WithYjsOptions\n) =>\n  withYjs(editor as any, sharedRoot, options) as SlateEditor & YjsEditorProps;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAA,eAA0B;AAC1B,qBAKO;;;ACAA,IAAM,QAAQ,KAAK;AAkCnB,IAAM,QAAQ,OAAO;;;AClCrB,IAAM,SAAS,MAAM,oBAAI,IAAI;;;AC6C7B,IAAM,OAAO,MAAM;AAgFnB,IAAM,UAAU,MAAM;;;AC9GtB,IAAM,cAAc,KAAK;;;ACPzB,IAAMC,UAAS,MAAM,oBAAI,IAAI;AAgC7B,IAAM,iBAAiB,CAAC,KAAK,KAAK,YAAY;AACnD,MAAI,MAAM,IAAI,IAAI,GAAG;AACrB,MAAI,QAAQ,QAAW;AACrB,QAAI,IAAI,KAAK,MAAM,QAAQ,CAAC;AAAA,EAC9B;AACA,SAAO;AACT;;;AC4CO,IAAM,aAAN,MAAiB;AAAA,EACtB,cAAe;AAKb,SAAK,aAAiBC,QAAO;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,GAAI,MAAM,GAAG;AACX,IAAI,eAAe,KAAK,YAAY,MAAU,MAAM,EAAE,IAAI,CAAC;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAM,MAAM,GAAG;AAIb,UAAM,KAAK,IAAI,SAAS;AACtB,WAAK,IAAI,MAAM,EAAE;AACjB,QAAE,GAAG,IAAI;AAAA,IACX;AACA,SAAK,GAAG,MAAM,EAAE;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAK,MAAM,GAAG;AACZ,UAAM,YAAY,KAAK,WAAW,IAAI,IAAI;AAC1C,QAAI,cAAc,QAAW;AAC3B,gBAAU,OAAO,CAAC;AAClB,UAAI,UAAU,SAAS,GAAG;AACxB,aAAK,WAAW,OAAO,IAAI;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,KAAM,MAAM,MAAM;AAEhB,WAAa,MAAM,KAAK,WAAW,IAAI,IAAI,KAASA,QAAO,GAAG,OAAO,CAAC,EAAE,QAAQ,OAAK,EAAE,GAAG,IAAI,CAAC;AAAA,EACjG;AAAA,EAEA,UAAW;AACT,SAAK,aAAiBA,QAAO;AAAA,EAC/B;AACF;;;AC5IO,IAAM,OAAO,OAAO;AAkCpB,IAAM,SAAS,SAAO,KAAK,GAAG,EAAE;AAsDhC,IAAM,cAAc,CAAC,KAAK,QAAQ,OAAO,UAAU,eAAe,KAAK,KAAK,GAAG;;;AC3G/E,IAAM,sBAAsB,OAAO,UAAU;;;ACsE7C,IAAM,eAAe,CAAC,GAAG,MAAM;AACpC,MAAI,MAAM,GAAG;AACX,WAAO;AAAA,EACT;AACA,MAAI,KAAK,QAAQ,KAAK,QAAQ,EAAE,gBAAgB,EAAE,aAAa;AAC7D,WAAO;AAAA,EACT;AACA,MAAI,EAAS,mBAAmB,KAAK,MAAM;AACzC,WAAO,EAAS,mBAAmB,EAAE,CAAC;AAAA,EACxC;AACA,UAAQ,EAAE,aAAa;AAAA,IACrB,KAAK;AACH,UAAI,IAAI,WAAW,CAAC;AACpB,UAAI,IAAI,WAAW,CAAC;AAAA;AAAA,IAEtB,KAAK,YAAY;AACf,UAAI,EAAE,eAAe,EAAE,YAAY;AACjC,eAAO;AAAA,MACT;AACA,eAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,YAAI,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG;AACjB,iBAAO;AAAA,QACT;AAAA,MACF;AACA;AAAA,IACF;AAAA,IACA,KAAK,KAAK;AACR,UAAI,EAAE,SAAS,EAAE,MAAM;AACrB,eAAO;AAAA,MACT;AACA,iBAAW,SAAS,GAAG;AACrB,YAAI,CAAC,EAAE,IAAI,KAAK,GAAG;AACjB,iBAAO;AAAA,QACT;AAAA,MACF;AACA;AAAA,IACF;AAAA,IACA,KAAK,KAAK;AACR,UAAI,EAAE,SAAS,EAAE,MAAM;AACrB,eAAO;AAAA,MACT;AACA,iBAAW,OAAO,EAAE,KAAK,GAAG;AAC1B,YAAI,CAAC,EAAE,IAAI,GAAG,KAAK,CAAC,aAAa,EAAE,IAAI,GAAG,GAAG,EAAE,IAAI,GAAG,CAAC,GAAG;AACxD,iBAAO;AAAA,QACT;AAAA,MACF;AACA;AAAA,IACF;AAAA,IACA,KAAK;AACH,UAAW,OAAO,CAAC,MAAa,OAAO,CAAC,GAAG;AACzC,eAAO;AAAA,MACT;AACA,iBAAW,OAAO,GAAG;AACnB,YAAI,CAAQ,YAAY,GAAG,GAAG,KAAK,CAAC,aAAa,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG;AAChE,iBAAO;AAAA,QACT;AAAA,MACF;AACA;AAAA,IACF,KAAK;AACH,UAAI,EAAE,WAAW,EAAE,QAAQ;AACzB,eAAO;AAAA,MACT;AACA,eAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,YAAI,CAAC,aAAa,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG;AAC7B,iBAAO;AAAA,QACT;AAAA,MACF;AACA;AAAA,IACF;AACE,aAAO;AAAA,EACX;AACA,SAAO;AACT;;;ACpIA,QAAmB;AAEZ,IAAM,kBAAkB;AA0BxB,IAAM,YAAN,cAAwB,WAAW;AAAA;AAAA;AAAA;AAAA,EAIxC,YAAa,KAAK;AAChB,UAAM;AACN,SAAK,MAAM;AAIX,SAAK,WAAW,IAAI;AAKpB,SAAK,SAAS,oBAAI,IAAI;AAItB,SAAK,OAAO,oBAAI,IAAI;AACpB,SAAK;AAAA,IAAqC,YAAY,MAAM;AAC1D,YAAM,MAAW,YAAY;AAC7B,UAAI,KAAK,cAAc,MAAM,QAAS,kBAAkB,KAAK;AAAA,MAA2C,KAAK,KAAK,IAAI,KAAK,QAAQ,EAAG,aAAc;AAElJ,aAAK,cAAc,KAAK,cAAc,CAAC;AAAA,MACzC;AAIA,YAAM,SAAS,CAAC;AAChB,WAAK,KAAK,QAAQ,CAAC,MAAM,aAAa;AACpC,YAAI,aAAa,KAAK,YAAY,mBAAmB,MAAM,KAAK,eAAe,KAAK,OAAO,IAAI,QAAQ,GAAG;AACxG,iBAAO,KAAK,QAAQ;AAAA,QACtB;AAAA,MACF,CAAC;AACD,UAAI,OAAO,SAAS,GAAG;AACrB,8BAAsB,MAAM,QAAQ,SAAS;AAAA,MAC/C;AAAA,IACF,GAAQ,MAAM,kBAAkB,EAAE,CAAC;AACnC,QAAI,GAAG,WAAW,MAAM;AACtB,WAAK,QAAQ;AAAA,IACf,CAAC;AACD,SAAK,cAAc,CAAC,CAAC;AAAA,EACvB;AAAA,EAEA,UAAW;AACT,SAAK,KAAK,WAAW,CAAC,IAAI,CAAC;AAC3B,SAAK,cAAc,IAAI;AACvB,UAAM,QAAQ;AACd,kBAAc,KAAK,cAAc;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAiB;AACf,WAAO,KAAK,OAAO,IAAI,KAAK,QAAQ,KAAK;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,cAAe,OAAO;AACpB,UAAM,WAAW,KAAK;AACtB,UAAM,gBAAgB,KAAK,KAAK,IAAI,QAAQ;AAC5C,UAAM,QAAQ,kBAAkB,SAAY,IAAI,cAAc,QAAQ;AACtE,UAAM,YAAY,KAAK,OAAO,IAAI,QAAQ;AAC1C,QAAI,UAAU,MAAM;AAClB,WAAK,OAAO,OAAO,QAAQ;AAAA,IAC7B,OAAO;AACL,WAAK,OAAO,IAAI,UAAU,KAAK;AAAA,IACjC;AACA,SAAK,KAAK,IAAI,UAAU;AAAA,MACtB;AAAA,MACA,aAAkB,YAAY;AAAA,IAChC,CAAC;AACD,UAAM,QAAQ,CAAC;AACf,UAAM,UAAU,CAAC;AACjB,UAAM,kBAAkB,CAAC;AACzB,UAAM,UAAU,CAAC;AACjB,QAAI,UAAU,MAAM;AAClB,cAAQ,KAAK,QAAQ;AAAA,IACvB,WAAW,aAAa,MAAM;AAC5B,UAAI,SAAS,MAAM;AACjB,cAAM,KAAK,QAAQ;AAAA,MACrB;AAAA,IACF,OAAO;AACL,cAAQ,KAAK,QAAQ;AACrB,UAAI,CAAG,aAAa,WAAW,KAAK,GAAG;AACrC,wBAAgB,KAAK,QAAQ;AAAA,MAC/B;AAAA,IACF;AACA,QAAI,MAAM,SAAS,KAAK,gBAAgB,SAAS,KAAK,QAAQ,SAAS,GAAG;AACxE,WAAK,KAAK,UAAU,CAAC,EAAE,OAAO,SAAS,iBAAiB,QAAQ,GAAG,OAAO,CAAC;AAAA,IAC7E;AACA,SAAK,KAAK,UAAU,CAAC,EAAE,OAAO,SAAS,QAAQ,GAAG,OAAO,CAAC;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBAAoB,OAAO,OAAO;AAChC,UAAM,QAAQ,KAAK,cAAc;AACjC,QAAI,UAAU,MAAM;AAClB,WAAK,cAAc;AAAA,QACjB,GAAG;AAAA,QACH,CAAC,KAAK,GAAG;AAAA,MACX,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAa;AACX,WAAO,KAAK;AAAA,EACd;AACF;AAUO,IAAM,wBAAwB,CAAC,WAAW,SAAS,WAAW;AACnE,QAAM,UAAU,CAAC;AACjB,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,UAAM,WAAW,QAAQ,CAAC;AAC1B,QAAI,UAAU,OAAO,IAAI,QAAQ,GAAG;AAClC,gBAAU,OAAO,OAAO,QAAQ;AAChC,UAAI,aAAa,UAAU,UAAU;AACnC,cAAM;AAAA;AAAA,UAA0C,UAAU,KAAK,IAAI,QAAQ;AAAA;AAC3E,kBAAU,KAAK,IAAI,UAAU;AAAA,UAC3B,OAAO,QAAQ,QAAQ;AAAA,UACvB,aAAkB,YAAY;AAAA,QAChC,CAAC;AAAA,MACH;AACA,cAAQ,KAAK,QAAQ;AAAA,IACvB;AAAA,EACF;AACA,MAAI,QAAQ,SAAS,GAAG;AACtB,cAAU,KAAK,UAAU,CAAC,EAAE,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG,QAAQ,GAAG,MAAM,CAAC;AACtE,cAAU,KAAK,UAAU,CAAC,EAAE,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG,QAAQ,GAAG,MAAM,CAAC;AAAA,EACxE;AACF;;;AVlLA,IAAAC,KAAmB;;;AWNnB,kBAAwC;AACxC,IAAAC,KAAmB;AASnB,eAAsB,6BACpB,MACA,cACqB;AAErB,QAAM,wBAAwB,MAAM;AAAA,IAClC;AAAA,IACA;AAAA,EACF;AAGA,QAAM,MAAM,IAAM,OAAI,EAAE,KAAK,CAAC;AAC9B,MAAI,WAAW;AAEf,QAAM,YAAQ,qCAAwB,YAAY;AAClD,QAAM,UAAU,IAAI,IAAI,WAAa,UAAO;AAC5C,UAAQ,WAAW,KAAK;AACxB,QAAM,gBAAkB,uBAAoB,GAAG;AAC/C,MAAI,QAAQ;AACZ,SAAO;AACT;AAGA,SAAS,sBAAsB,QAA6B;AAC1D,QAAM,WAAW,IAAI,SAAS,MAAM;AAEpC,QAAM,QAAQ,SAAS,SAAS,GAAG,KAAK;AAIxC,SAAQ,KAAK,IAAI,KAAK,IAAI,aAAiB;AAC7C;AAMA,eAAe,8BACb,MACA,cACiB;AACjB,QAAM,cAAc,KAAK,UAAU,YAAY;AAC/C,QAAM,iBAAiB,GAAG,IAAI,IAAI,WAAW;AAC7C,QAAM,UAAU,IAAI,YAAY;AAChC,QAAM,OAAO,QAAQ,OAAO,cAAc;AAC1C,QAAM,aAAa,MAAM,OAAO,OAAO,OAAO,OAAO,WAAW,IAAI;AAEpE,SAAO,sBAAsB,UAAU;AACzC;;;ACpDA,sBAAmC;AAQ5B,IAAM,4BAAN,MAA2D;AAAA,EACxD,eAAe;AAAA,EACf,YAAY;AAAA,EACZ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,UAAU,MAAM;AACd,QAAI,KAAK,cAAc;AACrB,WAAK,SAAS,WAAW;AAAA,IAC3B;AAAA,EACF;AAAA,EACA,aAAa,MAAM;AACjB,QAAI,KAAK,cAAc;AACrB,WAAK,SAAS,WAAW;AACzB,WAAK,eAAe;AAGpB,UAAI,KAAK,WAAW;AAClB,aAAK,YAAY;AACjB,cAAM,eAAe,KAAK;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAwB;AAAA,EAExB,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAI2B;AACzB,SAAK,YAAY;AACjB,SAAK,eAAe;AACpB,SAAK,eAAe;AACpB,SAAK,UAAU;AAGf,UAAM,kBAAmD;AAAA,MACvD,GAAG;AAAA,MACH,GAAI,OAAO,EAAE,UAAU,IAAI;AAAA,MAC3B,GAAI,aAAa,EAAE,UAAU;AAAA;AAAA,MAE7B,WAAW,QAAQ,aAAa;AAAA,MAChC,mBAAmB,QAAQ,sBAAsB,MAAM;AAAA,MAAC;AAAA,MACxD,WAAW,MAAM;AACf,aAAK,eAAe;AACpB,aAAK,YAAY;AACjB,gBAAQ,YAAY;AAAA,MACtB;AAAA,MACA,cAAc,CAAC,SAAiC;AAC9C,aAAK,eAAe;AAGpB,YAAI,KAAK,WAAW;AAClB,eAAK,YAAY;AACjB,eAAK,eAAe,KAAK;AAAA,QAC3B;AAEA,aAAK,eAAe;AACpB,gBAAQ,eAAe,IAAI;AAAA,MAC7B;AAAA,MACA,UAAU,CAAC,SAA6B;AACtC,cAAM,YAAY,KAAK;AACvB,aAAK,YAAY;AAGjB,YAAI,CAAC,WAAW;AACd,eAAK,eAAe,IAAI;AAAA,QAC1B;AAEA,gBAAQ,WAAW,IAAI;AAAA,MACzB;AAAA,IACF;AAEA,QAAI;AACF,WAAK,WAAW,IAAI,mCAAmB,eAAe;AAAA,IACxD,SAAS,OAAO;AAEd,WAAK,WAAW,IAAI,mCAAmB;AAAA,QACrC,GAAG;AAAA,QACH,SAAS;AAAA,MACX,CAAC;AACD,WAAK,UAAU,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC,CAAC;AAAA,IAC1E;AAAA,EACF;AAAA,EAEA,UAAU;AACR,QAAI;AACF,WAAK,KAAK,SAAS,QAAQ;AAAA,IAC7B,SAAS,OAAO;AACd,WAAK,eAAe;AAAA,IACtB;AAAA,EACF;AAAA,EAEA,IAAI,YAAY;AACd,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,IAAI,WAAW;AACb,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AACF;;;ACtIA,sBAAkD;AAClD,IAAAC,KAAmB;AASZ,IAAM,wBAAN,MAAuD;AAAA;AAAA,EAEpD,eAAe;AAAA,EACf,YAAY;AAAA,EACZ;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA,WAAmC;AAAA,EAE3C,UAAU,MAAM;AACd,QAAI,KAAK,UAAU;AACjB,UAAI;AACF,aAAK,SAAS,QAAQ;AAAA,MACxB,SAAS,OAAO;AACd,gBAAQ,KAAK,2CAA2C,KAAK;AAAA,MAC/D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,UAAU,MAAM;AACd,QAAI,KAAK,UAAU;AACjB,UAAI;AACF,aAAK,SAAS,QAAQ;AAAA,MACxB,SAAS,OAAO;AACd,gBAAQ,KAAK,2CAA2C,KAAK;AAAA,MAC/D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,aAAa,MAAM;AACjB,QAAI,KAAK,UAAU;AACjB,UAAI;AACF,aAAK,SAAS,WAAW;AACzB,cAAM,YAAY,KAAK;AAEvB,aAAK,eAAe;AACpB,aAAK,YAAY;AAGjB,YAAI,WAAW;AACb,eAAK,eAAe,KAAK;AAAA,QAC3B;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,KAAK,8CAA8C,KAAK;AAAA,MAClE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAwB;AAAA;AAAA,EAGxB,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAI2B;AACzB,SAAK,YAAY;AACjB,SAAK,eAAe;AACpB,SAAK,UAAU;AACf,SAAK,eAAe;AAEpB,SAAK,MAAM,OAAO,IAAM,OAAI;AAC5B,QAAI;AACF,WAAK,WAAW,IAAI,gBAAAC,eAAgB,QAAQ,UAAU,KAAK,KAAK;AAAA,QAC9D;AAAA,QACA,eAAe,QAAQ;AAAA,QACvB,UAAU,QAAQ;AAAA,QAClB,UAAU,QAAQ;AAAA,QAClB,UAAU,QAAQ;AAAA,QAClB,WAAW,QAAQ;AAAA,MACrB,CAAC;AAGD,WAAK,SAAS,GAAG,UAAU,CAAC,WAAmC;AAC7D,cAAM,eAAe,KAAK;AAC1B,aAAK,eAAe,OAAO;AAE3B,YAAI,OAAO,WAAW;AAEpB,cAAI,CAAC,cAAc;AACjB,wBAAY;AAAA,UACd;AAEA,cAAI,CAAC,KAAK,WAAW;AACnB,iBAAK,YAAY;AACjB,2BAAe,IAAI;AAAA,UACrB;AAAA,QACF,OAAO;AAEL,cAAI,cAAc;AAChB,2BAAe;AAIf,gBAAI,KAAK,WAAW;AAClB,mBAAK,YAAY;AACjB,6BAAe,KAAK;AAAA,YACtB;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,cAAQ,KAAK,yCAAyC,KAAK;AAC3D,gBAAU,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC,CAAC;AAAA,IAErE;AAAA,EACF;AAAA,EAEA,IAAI,YAAuB;AACzB,WAAO,KAAK,SAAU;AAAA,EACxB;AAAA,EAEA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AACF;;;ACxIA,IAAM,mBAAqC;AAAA,EACzC,YAAY;AAAA,EACZ,QAAQ;AACV;AAGO,IAAM,uBAAuB,CAClC,MACA,kBACG;AACH,mBAAiB,IAAuB,IACtC;AACJ;AAGO,IAAM,mBAAmB,CAC9B,SACoC;AACpC,SAAO,iBAAiB,IAAI;AAC9B;AAGO,IAAM,iBAAiB,CAAC;AAAA,EAC7B;AAAA,EACA,GAAG;AACL,MAEM;AACJ,QAAM,gBAAgB,iBAAiB,IAAI;AAE3C,MAAI,CAAC,eAAe;AAClB,UAAM,IAAI,MAAM,kBAAkB,IAAI,yBAAyB;AAAA,EACjE;AAEA,SAAO,IAAI,cAAc,KAAK;AAChC;;;AC5CA,IAAAC,KAAmB;;;ACCnB,IAAAC,eAIO;AAcA,IAAM,eAAe,CAC1B,QACA,WACA,gBAEA,0BAAY,QAAe,WAAW,OAAO;;;ACvB/C,IAAAC,eAIO;AAiBA,IAAM,gBAAgB,CAC3B,QACA,gBAEA,2BAAa,QAAe,OAAO;;;ACzBrC,IAAAC,eAAwC;AA6BjC,IAAM,WAAW,CACtB,QACA,YACA,gBAEA,sBAAQ,QAAe,YAAY,OAAO;;;AH3BrC,IAAM,eAAwC,CAAC;AAAA,EACpD,QAAQ;AAAA,EACR;AACF,MAAM;AACJ,MAAI,SAAS;AAIb,QAAM,EAAE,WAAW,SAAS,aAAa,uBAAuB,KAAK,IACnE,WAAW;AAGb,QAAM,aAAa,KAAM,IAAI,WAAa,UAAO;AAGjD,WAAS,SAAS,QAAQ,YAAY;AAAA,IACpC,aAAa;AAAA,IACb;AAAA,IACA;AAAA,EACF,CAAC;AAID,MAAI,SAAS;AAEX,QAAI,WAAW;AACb,UAAI,WAAW;AAEf,UAAI,QAAQ,aAAa,OAAO;AAC9B,mBAAW;AAAA,MACb;AAEA,eAAS,aAAa,QAAQ,WAAW;AAAA,QACvC,GAAG;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH,OAAO;AAEL,aAAO,IAAI,MAAM;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,SAAO,cAAc,MAAM;AAC7B;;;AfnCA,IAAM,mBAAmB,CACvB,SAC8B;AAC9B,SACE,OAAO,SAAS,YAChB,SAAS,QACT,UAAU,QACV,aAAa;AAEjB;AAEO,IAAM,oBAAgB,mCAA8B;AAAA,EACzD,KAAK,oBAAK;AAAA,EACV,cAAc;AAAA,EACd,SAAS;AAAA,IACP,cAAc;AAAA,IACd,WAAW;AAAA,IACX,YAAY,CAAC;AAAA,IACb,WAAW;AAAA,IACX,SAAS,CAAC;AAAA,IACV,aAAa;AAAA,IACb,uBAAuB;AAAA,IACvB,WAAW,CAAC;AAAA,IACZ,MAAM;AAAA,IACN,WAAW,MAAM;AAAA,IAAC;AAAA,IAClB,cAAc,MAAM;AAAA,IAAC;AAAA,IACrB,SAAS,MAAM;AAAA,IAAC;AAAA,IAChB,cAAc,MAAM;AAAA,IAAC;AAAA,EACvB;AACF,CAAC,EACE,OAAO,CAAC,EAAE,WAAW,MAAM;AAC1B,QAAM,EAAE,aAAa,uBAAuB,GAAG,QAAQ,IAAI,WAAW;AACtE,MAAI,EAAE,WAAW,KAAK,IAAI;AAE1B,MAAI,CAAC,MAAM;AACT,WAAO,IAAM,OAAI;AAAA,EACnB;AAEA,MAAI,CAAC,WAAW;AACd,gBAAY,IAAI,UAAU,IAAI;AAAA,EAChC;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,MACA,aAAa,eAAe;AAAA,MAC5B,uBAAuB,yBAAyB;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACF,CAAC,EACA,UAAU,CAAC,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOnB,SAAS,CAAC,SAA+C;AACvD,UAAM,EAAE,WAAW,IAAI;AACvB,UAAM,EAAE,WAAW,IAAI,WAAW;AAClC,UAAM,iBAAiB,OACnB,MAAM,QAAQ,IAAI,IAChB,OACA,CAAC,IAAI,IACP;AAEJ,eAAW,QAAQ,CAAC,aAAa;AAC/B,UAAI,CAAC,kBAAkB,eAAe,SAAS,SAAS,IAAI,GAAG;AAC7D,YAAI;AACF,mBAAS,QAAQ;AAAA,QACnB,SAAS,OAAO;AACd,qBAAW,EAAE,UAAU;AAAA,YACrB,OAAO,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,YAC/D,MAAM,SAAS;AAAA,UACjB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,SAAS,MAAM;AACb,UAAM,EAAE,QAAQ,WAAW,IAAI;AAC/B,UAAM,EAAE,WAAW,IAAI,WAAW;AAElC,eAAW,YAAY,CAAC,GAAG,UAAU,EAAE,QAAQ,GAAG;AAChD,UAAI;AACF,YAAI,SAAS,aAAa;AACxB,mBAAS,QAAQ;AAAA,QACnB;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ;AAAA,UACN,uCAAuC,SAAS,IAAI;AAAA,UACpD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,QAAI;AACF,6BAAU,WAAW,MAAa;AAAA,IACpC,SAAS,OAAO;AAAA,IAAC;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,YAAY,CAAC,SAA+C;AAC1D,UAAM,EAAE,QAAQ,WAAW,IAAI;AAC/B,UAAM,EAAE,WAAW,IAAI,WAAW;AAElC,UAAM,oBAAoB,OACtB,MAAM,QAAQ,IAAI,IAChB,OACA,CAAC,IAAI,IACP;AAEJ,eAAW,YAAY,CAAC,GAAG,UAAU,EAAE,QAAQ,GAAG;AAChD,UAAI;AACF,YACE,SAAS,gBACR,sBAAsB,QACrB,kBAAkB,SAAS,SAAS,IAAI,IAC1C;AACA,mBAAS,WAAW;AAAA,QACtB;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ;AAAA,UACN,uCAAuC,SAAS,IAAI;AAAA,UACpD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,OAAO;AAAA,IACX;AAAA,IACA,cAAc;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAaiD,CAAC,MAAM;AACtD,UAAM,EAAE,QAAQ,YAAY,UAAU,IAAI;AAE1C,UAAM,UAAU,WAAW;AAC3B,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA,WAAW,6BAA6B,CAAC;AAAA,MACzC;AAAA,IACF,IAAI;AAGJ,QAAI,2BAA2B,WAAW,GAAG;AAC3C,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,UAAU,MAAM;AAClB,UAAI,eAAe;AACnB,UAAI,OAAO,UAAU,UAAU;AAC7B,uBAAe,OAAO,IAAI,KAAK,YAAY;AAAA,UACzC,SAAS;AAAA,QACX,CAAC;AAAA,MACH,WAAW,OAAO,UAAU,YAAY;AACtC,uBAAe,MAAM,MAAM,MAAM;AAAA,MACnC,WAAW,OAAO;AAChB,uBAAe;AAAA,MACjB;AACA,UAAI,CAAC,gBAAgB,cAAc,WAAW,GAAG;AAC/C,uBAAe,OAAO,IAAI,OAAO,MAAM;AAAA,MACzC;AAEA,YAAM,eAAe,MAAM;AAAA,QACzB,MAAM,OAAO;AAAA,QACb;AAAA,MACF;AACA,WAAK,SAAS,MAAM;AAClB,QAAE,eAAY,MAAM,YAAY;AAAA,MAClC,CAAC;AAAA,IACH;AAGA,UAAM,iBAAoC,CAAC;AAG3C,2BAAU,QAAQ,MAAa;AAE/B,WAAO,GAAG,KAAK;AAAA,MACb;AAAA,MACA;AAAA;AAAA,MAEA,uBAAuB;AAAA,MACvB,OAAO;AAAA,IACT,CAAC;AAGD,eAAW,QAAQ,4BAA4B;AAC7C,UAAI,iBAAiB,IAAI,GAAG;AAE1B,cAAM,EAAE,SAAAC,UAAS,KAAK,IAAI;AAE1B,YAAI,CAACA,UAAS;AACZ,kBAAQ;AAAA,YACN,gDAAgD,IAAI;AAAA,UACtD;AACA;AAAA,QACF;AAEA,YAAI;AAEF,gBAAM,WAAW,eAAe;AAAA,YAC9B;AAAA,YACA,KAAK;AAAA,YACL,SAAAA;AAAA,YACA;AAAA,YACA,WAAW,MAAM;AACf,yBAAW,EAAE,YAAY,EAAE,KAAK,CAAC;AAEjC,wBAAU,gBAAgB,IAAI;AAAA,YAChC;AAAA,YACA,cAAc,MAAM;AAClB,yBAAW,EAAE,eAAe,EAAE,KAAK,CAAC;AAGpC,oBAAM,EAAE,YAAAC,YAAW,IAAI,WAAW;AAClC,oBAAM,uBAAuBA,YAAW;AAAA,gBACtC,CAACC,cAAaA,UAAS;AAAA,cACzB;AACA,kBAAI,CAAC,sBAAsB;AACzB,0BAAU,gBAAgB,KAAK;AAAA,cACjC;AAAA,YACF;AAAA,YACA,SAAS,CAAC,UAAU;AAClB,yBAAW,EAAE,UAAU,EAAE,OAAO,KAAK,CAAC;AAAA,YACxC;AAAA,YACA,cAAc,CAAC,aAAa;AAC1B,yBAAW,EAAE,eAAe,EAAE,UAAU,KAAK,CAAC;AAC9C,wBAAU,aAAa,QAAQ;AAAA,YACjC;AAAA,UACF,CAAC;AACD,yBAAe,KAAK,QAAQ;AAAA,QAC9B,SAAS,OAAO;AACd,kBAAQ;AAAA,YACN,yCAAyC,IAAI;AAAA,YAC7C;AAAA,UACF;AAAA,QACF;AAAA,MACF,OAAO;AAEL,cAAM,iBAAiB;AAGvB,YAAI,eAAe,aAAa,MAAM;AACpC,kBAAQ;AAAA,YACN,mCAAmC,eAAe,IAAI;AAAA,UAExD;AAAA,QACF;AAEA,YAAI,eAAe,cAAc,WAAW;AAC1C,kBAAQ;AAAA,YACN,mCAAmC,eAAe,IAAI;AAAA,UAExD;AAAA,QACF;AAGA,uBAAe,KAAK,cAAc;AAAA,MACpC;AAAA,IACF;AAEA,QAAI,eAAe,WAAW,GAAG;AAC/B,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAGA,cAAU,cAAc,cAAc;AAGtC,QAAI,aAAa;AACf,iBAAW,QAAQ,CAAC,aAAa;AAC/B,YAAI;AACF,mBAAS,QAAQ;AAAA,QACnB,SAAS,OAAO;AACd,qBAAW,EAAE,UAAU;AAAA,YACrB,OAAO,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,YAC/D,MAAM,SAAS;AAAA,UACjB,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF,EAAE;","names":["import_core","create","create","Y","Y","Y","YWebrtcProvider","Y","import_core","import_core","import_core","options","_providers","provider"]}