{"version":3,"sources":["../src/index.ts","../src/components/CursorOverlay.tsx","../src/hooks/useCursorOverlayPositions.ts","../src/hooks/useRefreshOnResize.ts","../src/hooks/useRequestReRender.ts","../src/queries/getCaretPosition.ts","../src/queries/getCursorOverlayState.ts","../src/queries/getSelectionRects.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './types';\nexport * from './components/index';\nexport * from './hooks/index';\nexport * from './queries/index';\n","import React from 'react';\n\nimport type { UnknownObject } from 'platejs';\n\nimport { useEditorMounted } from 'platejs/react';\n\nimport type {\n  CursorData,\n  CursorOverlayState,\n  CursorState,\n  SelectionRect,\n} from '../types';\n\nimport { useCursorOverlayPositions } from '../hooks/useCursorOverlayPositions';\n\nexport interface CursorOverlayProps<\n  TCursorData extends UnknownObject = UnknownObject,\n> extends Pick<\n    CursorProps<CursorData>,\n    | 'classNames'\n    | 'disableCaret'\n    | 'disableSelection'\n    | 'onRenderCaret'\n    | 'onRenderSelectionRect'\n  > {\n  /**\n   * Container the overlay will be rendered in. If set, all returned overlay\n   * positions will be relative to this container.\n   */\n  containerRef?: React.RefObject<HTMLElement | null>;\n\n  /** Cursor states to use for calculating the overlay positions, by key. */\n  cursors?: Record<string, CursorState<TCursorData>>;\n\n  /** Overrides `Cursor` component. */\n  onRenderCursor?: React.FC<CursorProps>;\n\n  /**\n   * Whether to refresh the cursor overlay positions on container resize.\n   *\n   * @default true\n   */\n  refreshOnResize?: boolean;\n}\n\nexport type CursorProps<TCursorData extends UnknownObject = UnknownObject> =\n  CursorOverlayState<TCursorData> & {\n    id: string;\n    classNames?: Partial<{\n      caret: string;\n      selectionRect: string;\n    }>;\n    /** Whether to disable the caret. */\n    disableCaret?: boolean;\n    /** Whether to disable the selection rects. */\n    disableSelection?: boolean;\n    /**\n     * Custom caret component. For example, you could display a label next to\n     * the caret.\n     *\n     * @default styled div\n     */\n    onRenderCaret?: React.FC<\n      Pick<CursorProps<TCursorData>, 'caretPosition' | 'data'>\n    >;\n    /** Overrides `Caret` component */\n    onRenderSelectionRect?: React.FC<\n      {\n        selectionRect: SelectionRect;\n      } & Pick<CursorProps<TCursorData>, 'data'>\n    >;\n  };\n\nexport function CursorOverlayContent<\n  TCursorData extends UnknownObject = UnknownObject,\n>({\n  classNames,\n  onRenderCaret,\n  onRenderCursor: CursorComponent,\n  onRenderSelectionRect,\n  ...props\n}: CursorOverlayProps<TCursorData>) {\n  const { disableCaret, disableSelection } = props;\n\n  const { cursors } = useCursorOverlayPositions(props);\n\n  const cursorProps = {\n    classNames,\n    disableCaret,\n    disableSelection,\n    onRenderCaret,\n    onRenderSelectionRect,\n  };\n\n  if (!CursorComponent) return null;\n\n  return (\n    <>\n      {cursors.map((cursor) => (\n        <CursorComponent\n          id={cursor.key}\n          key={cursor.key}\n          {...cursorProps}\n          {...cursor}\n        />\n      ))}\n    </>\n  );\n}\n\nexport function CursorOverlay<\n  TCursorData extends UnknownObject = UnknownObject,\n>(props: CursorOverlayProps<TCursorData>) {\n  const isMounted = useEditorMounted();\n\n  if (!isMounted) return null;\n\n  return <CursorOverlayContent {...props} />;\n}\n","import React from 'react';\n\nimport type { TRange, UnknownObject } from 'platejs';\n\nimport { useEditorRef, useIsomorphicLayoutEffect } from 'platejs/react';\n\nimport type { CursorOverlayProps } from '../components/CursorOverlay';\nimport type { CursorState, SelectionRect } from '../types';\n\nimport { getCursorOverlayState } from '../queries/getCursorOverlayState';\nimport { getSelectionRects } from '../queries/getSelectionRects';\nimport { useRefreshOnResize } from './useRefreshOnResize';\n\nexport const FROZEN_EMPTY_ARRAY = Object.freeze(\n  []\n) as unknown as SelectionRect[];\n\nexport const useCursorOverlayPositions = <TCursorData extends UnknownObject>({\n  containerRef,\n  cursors: cursorStates,\n  refreshOnResize = true,\n}: CursorOverlayProps<TCursorData> = {}) => {\n  const editor = useEditorRef();\n\n  const selectionRectCache = React.useRef<WeakMap<TRange, SelectionRect[]>>(\n    new WeakMap()\n  );\n\n  const [selectionRects, setSelectionRects] = React.useState<\n    Record<string, SelectionRect[]>\n  >({});\n\n  const updateSelectionRects = React.useCallback(() => {\n    // We have a container ref but the ref is null => container\n    // isn't mounted to we can't calculate the selection rects.\n    if (!containerRef?.current) return;\n    if (!cursorStates) return;\n\n    let xOffset = 0;\n    let yOffset = 0;\n\n    if (containerRef) {\n      const contentRect = containerRef.current!.getBoundingClientRect();\n      xOffset = contentRect.x;\n      yOffset = contentRect.y;\n      yOffset -= containerRef.current.scrollTop;\n    }\n\n    let selectionRectsChanged =\n      Object.keys(selectionRects).length !== Object.keys(cursorStates).length;\n\n    const getCachedSelectionRects = ({\n      cursor,\n    }: {\n      cursor: CursorState<TCursorData>;\n    }) => {\n      const range = cursor.selection;\n\n      if (!range) {\n        return FROZEN_EMPTY_ARRAY;\n      }\n\n      const cached = selectionRectCache.current.get(range);\n\n      if (cached) {\n        return cached;\n      }\n\n      const rects = getSelectionRects(editor, { range, xOffset, yOffset });\n      selectionRectsChanged = true;\n      selectionRectCache.current.set(range, rects);\n\n      return rects;\n    };\n\n    const updated: Record<string, SelectionRect[]> = Object.fromEntries(\n      Object.entries(cursorStates).map(([key, cursor]) => [\n        key,\n        getCachedSelectionRects({\n          cursor,\n        }),\n      ])\n    );\n\n    if (selectionRectsChanged) {\n      setSelectionRects(updated);\n    }\n  }, [containerRef, cursorStates, editor, selectionRects]);\n\n  // Update selection rects after paint\n\n  useIsomorphicLayoutEffect(() => {\n    updateSelectionRects();\n  });\n\n  const cursors = React.useMemo(\n    () =>\n      getCursorOverlayState({\n        cursors: cursorStates,\n        selectionRects,\n      }),\n    [cursorStates, selectionRects]\n  );\n\n  const { refresh } = useRefreshOnResize({\n    containerRef,\n    refreshOnResize,\n    selectionRectCache,\n  });\n\n  return { cursors, refresh };\n};\n","import React from 'react';\n\nimport type { TRange } from 'platejs';\n\nimport type { CursorOverlayProps } from '../components';\nimport type { SelectionRect } from '../types';\n\nimport { useRequestReRender } from './useRequestReRender';\n\nexport interface useRefreshOnResizeOptions\n  extends Pick<CursorOverlayProps, 'containerRef' | 'refreshOnResize'> {\n  selectionRectCache: React.MutableRefObject<WeakMap<TRange, SelectionRect[]>>;\n}\n\nexport const useRefreshOnResize = ({\n  containerRef,\n  refreshOnResize,\n  selectionRectCache,\n}: useRefreshOnResizeOptions) => {\n  const requestReRender = useRequestReRender();\n\n  // Reset the selection rect cache and request re-render.\n  const refresh = React.useCallback(\n    (sync = false) => {\n      selectionRectCache.current = new WeakMap();\n      requestReRender(sync);\n    },\n    [requestReRender, selectionRectCache]\n  );\n\n  // Refresh on container resize\n  React.useEffect(() => {\n    if (!refreshOnResize || !containerRef?.current) {\n      return;\n    }\n\n    const resizeObserver = new ResizeObserver(() => refresh());\n    resizeObserver.observe(containerRef.current);\n\n    return () => resizeObserver.disconnect();\n  }, [containerRef, refresh, refreshOnResize]);\n\n  return {\n    refresh,\n  };\n};\n","import React from 'react';\n\nexport const useRequestReRender = () => {\n  const [, setUpdateCounter] = React.useState(0);\n  const animationFrameRef = React.useRef<number | null>(null);\n\n  const requestReRender = React.useCallback((immediate = false) => {\n    if (animationFrameRef.current && !immediate) {\n      return;\n    }\n    if (!immediate) {\n      animationFrameRef.current = requestAnimationFrame(() => {\n        setUpdateCounter((state) => state + 1);\n        animationFrameRef.current = null;\n      });\n\n      return;\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n\n    setUpdateCounter((state) => state + 1);\n  }, []);\n\n  React.useEffect(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  });\n\n  React.useEffect(\n    () => () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    },\n    []\n  );\n\n  return requestReRender;\n};\n","import type { TRange } from 'platejs';\n\nimport { RangeApi } from 'platejs';\n\nimport type { CaretPosition, SelectionRect } from '../types';\n\n/** Get the caret position of a range from selectionRects. */\nexport const getCaretPosition = (\n  selectionRects: SelectionRect[],\n  range: TRange\n): CaretPosition | null => {\n  const isCollapsed = range && RangeApi.isCollapsed(range);\n  const isBackward = range && RangeApi.isBackward(range);\n  const anchorRect = selectionRects[isBackward ? 0 : selectionRects.length - 1];\n\n  if (!anchorRect) {\n    return null;\n  }\n\n  return {\n    height: anchorRect.height,\n    left: anchorRect.left + (isBackward || isCollapsed ? 0 : anchorRect.width),\n    top: anchorRect.top,\n  };\n};\n","import type { UnknownObject } from 'platejs';\n\nimport type { CursorOverlayProps } from '../components';\nimport type { CursorOverlayState, SelectionRect } from '../types';\n\nimport { FROZEN_EMPTY_ARRAY } from '../hooks';\nimport { getCaretPosition } from './getCaretPosition';\n\n/** Get cursor overlay state from selection rects. */\nexport const getCursorOverlayState = <\n  TCursorData extends UnknownObject = UnknownObject,\n>({\n  cursors: cursorStates,\n  selectionRects,\n}: {\n  selectionRects: Record<string, SelectionRect[]>;\n} & Pick<\n  CursorOverlayProps<TCursorData>,\n  'cursors'\n>): CursorOverlayState<TCursorData>[] => {\n  if (!cursorStates) return [];\n\n  return Object.entries(cursorStates).map(([key, cursorState]) => {\n    const selection = cursorState?.selection ?? null;\n    const rects = selectionRects[key] ?? FROZEN_EMPTY_ARRAY;\n\n    const caretPosition = selection ? getCaretPosition(rects, selection) : null;\n\n    return {\n      ...cursorState,\n      caretPosition,\n      selection,\n      selectionRects: rects,\n    };\n  });\n};\n","import { type Editor, type TRange, PathApi, RangeApi, TextApi } from 'platejs';\n\nimport type { SelectionRect } from '../types';\n\nexport const getSelectionRects = (\n  editor: Editor,\n  {\n    range,\n    xOffset,\n    yOffset,\n  }: {\n    range: TRange;\n    xOffset: number;\n    yOffset: number;\n  }\n): SelectionRect[] => {\n  const [start, end] = RangeApi.edges(range);\n  const domRange = editor.api.toDOMRange(range);\n\n  if (!domRange) {\n    return [];\n  }\n\n  const selectionRects: SelectionRect[] = [];\n  const textEntries = editor.api.nodes({\n    at: range,\n    match: TextApi.isText,\n  });\n\n  for (const [textNode, textPath] of textEntries) {\n    const domNode = editor.api.toDOMNode(textNode);\n\n    // Fix: failed to execute 'selectNode' on 'Range': the given Node has no parent\n    if (!domNode?.parentElement) {\n      return [];\n    }\n\n    const isStartNode = PathApi.equals(textPath, start.path);\n    const isEndNode = PathApi.equals(textPath, end.path);\n\n    let clientRects: DOMRectList | null = null;\n\n    if (isStartNode || isEndNode) {\n      const nodeRange = document.createRange();\n\n      nodeRange.selectNode(domNode);\n\n      if (isStartNode) {\n        nodeRange.setStart(domRange.startContainer, domRange.startOffset);\n      }\n      if (isEndNode) {\n        nodeRange.setEnd(domRange.endContainer, domRange.endOffset);\n      }\n\n      clientRects = nodeRange.getClientRects();\n    } else {\n      clientRects = domNode.getClientRects();\n    }\n\n    for (let i = 0; i < clientRects.length; i++) {\n      const clientRect = clientRects.item(i);\n\n      if (!clientRect) {\n        continue;\n      }\n\n      selectionRects.push({\n        height: clientRect.height,\n        left: clientRect.left - xOffset,\n        top: clientRect.top - yOffset,\n        width: clientRect.width,\n      });\n    }\n  }\n\n  return selectionRects;\n};\n"],"mappings":"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","names":["import_react","import_react","import_react","React","React","import_platejs","React","React"]}