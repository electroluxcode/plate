{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "plugin-methods-docs",
  "type": "registry:file",
  "title": "Plugin Methods",
  "description": "Explore the various methods available for extending Plate plugins.",
  "files": [
    {
      "path": "../../docs/(guides)/plugin-methods.mdx",
      "content": "---\ntitle: Plugin Methods\ndescription: Explore the various methods available for extending Plate plugins.\n---\n\n## Configuration Methods\n\nWhen extending plugins, all properties are deeply merged by default, with two exceptions: arrays are replaced entirely, and the `options` object is shallow merged.\n\n### .configure\n\nThe `.configure` method allows you to override the plugin's configuration.\n\n```ts\nconst ConfiguredPlugin = MyPlugin.configure({\n  options: {\n    myOption: 'new value',\n  },\n});\n```\n\nYou can also use a function to access the current configuration:\n\n```ts\nconst ConfiguredPlugin = MyPlugin.configure(({ getOptions }) => ({\n  options: {\n    ...getOptions(),\n    myOption: `${getOptions().myOption} + extra`,\n  },\n}));\n```\n\n- It's used to modify existing properties of the plugin.\n- It doesn't add new properties to the plugin.\n- The last configuration applied is the one used by the editor.\n- It doesn't return an extended type, maintaining the original plugin type.\n\n### .configurePlugin\n\nThe `.configurePlugin` method allows you to configure the properties of a nested plugin:\n\n```ts\nconst TablePlugin = createPlatePlugin({\n  key: 'table',\n  plugins: [TableCellPlugin],\n}).configurePlugin(TableCellPlugin, {\n  options: {\n    cellOption: 'modified',\n  },\n});\n```\n\n- It's used to configure nested plugins within a parent plugin.\n- Like `.configure`, it modifies existing properties but doesn't add new ones.\n- It's useful for adjusting the behavior of sub-plugins without extending their types.\n\n\n### .extend\n\nThe `.extend` method allows you to extend the plugin's configuration and functionality.\n\n```ts\nconst ExtendedPlugin = MyPlugin.extend({\n  options: {\n    newOption: 'new value',\n  },\n});\n```\n\nYou can also use a function to access the current configuration and editor:\n\n```ts\nconst ExtendedPlugin = MyPlugin.extend(({ editor, plugin }) => ({\n  options: {\n    newOption: 'new value',\n  },\n  handlers: {\n    onKeyDown: () => {\n      // Custom key down logic\n    },\n  },\n}));\n```\n\n- It's used to add new properties or modify existing ones in the plugin.\n- It returns a new plugin instance with extended types.\n- It's chainable, allowing multiple extensions to be applied sequentially.\n\n### .extendPlugin\n\nThe `.extendPlugin` method allows you to extend the configuration and functionality of a nested plugin:\n\n```ts\nconst TablePlugin = createPlatePlugin({\n  key: 'table',\n  plugins: [TableCellPlugin],\n}).extendPlugin(TableCellPlugin, {\n  options: {\n    newCellOption: 'added',\n  },\n  handlers: {\n    onKeyDown: () => {\n      // Custom key down logic for table cells\n    },\n  },\n});\n```\n\n- It's used to extend nested plugins within a parent plugin.\n- It can add new properties and modify existing ones in the nested plugin.\n- It returns a new parent plugin instance with the extended nested plugin.\n\n\n### Difference between .configure and .extend\n\nWhile both methods can be used to modify plugin configuration, they have some key differences:\n\n1. Chaining: `.extend` is chainable, while `.configure` is not.\n2. Type extension: `.extend` returns a new plugin instance with extended types, while `.configure` maintains the original type.\n3. New properties: `.extend` can add new properties to the plugin configuration, while `.configure` only modifies existing ones.\n\nChoose the appropriate method based on whether you need to extend the plugin's type and functionality (use `.extend`) or simply modify existing configuration (use `.configure`).\n\n### .extendSelectors\n\nThe `extendSelectors` method allows you to add subscribable selectors to your plugin:\n\n```ts\nconst CounterPlugin = createPlatePlugin({\n  key: 'counter',\n  options: {\n    count: 0,\n  },\n}).extendSelectors(({ getOptions }) => ({\n  doubleCount: () => getOptions().count * 2,\n  isEven: () => getOptions().count % 2 === 0,\n}));\n```\n\nYou can then use those selectors in your components or other plugin methods:\n\n```tsx\nconst CounterComponent = () => {\n  const count = usePluginOption(CounterPlugin, 'count');\n  const doubleCount = usePluginOption(CounterPlugin, 'doubleCount');\n  const isEven = usePluginOption(CounterPlugin, 'isEven');\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Double Count: {doubleCount}</p>\n      <p>Is Even: {isEven ? 'Yes' : 'No'}</p>\n    </div>\n  );\n};\n```\n\n- It allows you to create derived state or computed values from plugin options.\n- Read the value using `getOption`\n- Subscribe to the value using `usePluginOption`, recomputed whenever options change, re-rendering only when the result changes. **This is the main difference with `.extendApi`**.\n\n### .withComponent\n\nThe `withComponent` method allows you to set or replace the component associated with a plugin.\n\n```ts\nconst ParagraphPlugin = createPlatePlugin({\n  key: 'p',\n  node: {\n    isElement: true,\n    type: 'p',\n  },\n}).withComponent(ParagraphElement);\n```\n\n## API and Transforms\n\nPlugins can define their own API methods and transforms that will be merged into the editor's API and transforms. This is done using the `extendApi`, `extendEditorApi`, `extendTransforms`, and `extendEditorTransforms` methods.\n\n### .extendApi\n\nUse `extendApi` to add plugin-specific API methods:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n}).extendApi(() => ({\n  pluginMethod: () => 'plugin method result',\n}));\n\n// Access the plugin's API\neditor.api.myPlugin.api.pluginMethod();\n```\n\n### .extendEditorApi\n\nUse `extendEditorApi` to add root-level API methods:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n}).extendEditorApi(({ getOptions }) => ({\n  editorMethod: () => getOptions().someOption,\n}));\n\n// Access the plugin's API\neditor.api.editorMethod();\n```\n\n### .extendTransforms\n\nUse `extendTransforms` to add plugin-specific transform methods:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n}).extendTransforms(() => ({\n  pluginTransform: () => {\n    // Custom transform logic\n  },\n}));\n\n// Access the plugin's transform\neditor.tf.myPlugin.pluginTransform();\n\n// NOTE: `editor.tf` in a short alias to `editor.transforms`\neditor.transforms.myPlugin.pluginTransform();\n```\n\n### .extendEditorTransforms\n\nUse `extendEditorTransforms` to add root-level transform methods:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n}).extendEditorTransforms(({ editor }) => ({\n  editorTransform: () => {\n    // Custom editor transform logic\n  },\n}));\n\n// Access the plugin's transform\neditor.tf.editorTransform();\n```\n\n### .overrideEditor\n\nThe `overrideEditor` method is used specifically for overriding existing editor methods without altering the plugin's type:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n}).overrideEditor(({ editor, tf: { insertText }, api: { isInline } }) => ({\n  transforms: {\n    insertText(text, options) {\n      // Override insertText behavior\n      insertText(text, options);\n    },\n  },\n  api: {\n    isInline(element) {\n      // Override isInline behavior\n      return isInline(element);\n    },\n  },\n}));\n```\n\n- Used specifically for overriding existing editor methods\n- Returns the overridden methods wrapped in `transforms` or `api` objects\n- Cannot add new methods (use `extendEditorTransforms` or `extendEditorApi` instead)\n- Provides access to original methods through the context\n\n### Difference between API and Transforms\n\nWhile there is currently no core difference between API and Transforms in Plate, they serve distinct purposes and are designed with future extensibility in mind:\n\n- **Transforms:** \n  - Store all Slate transforms and editor operations here. Structured to potentially support middlewares in the future, allowing for more complex transform pipelines and devtools.\n  - Typically used for operations that modify the editor state, such as inserting, deleting, or transforming content.\n  - Example: `editor.tf.toggleBlock()`, `editor.tf.toggleMark('bold')`\n\n- **API:** \n  - Store all queries, utility functions, and other methods that don't directly modify the editor state.\n  - Example: `editor.api.save()`, `editor.api.debug.log()`\n\n### Chaining Extensions\n\nYou can chain these methods to create a comprehensive plugin:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n  options: {\n    baseValue: 5,\n  },\n})\n  .extendApi(() => ({\n    pluginMethod: () => 'plugin method',\n  }))\n  .extendEditorApi(({ getOptions }) => ({\n    multiply: (factor: number) => getOptions().baseValue * factor,\n  }))\n  .extendTransforms(() => ({\n    pluginTransform: () => {\n      // Plugin-specific transform\n    },\n  }))\n  .extendEditorTransforms(({ editor }) => ({\n    editorTransform: () => {\n      // Editor-specific transform\n    },\n  }));\n\neditor.api.myPlugin.api.pluginMethod();\neditor.api.multiply(3);\neditor.tf.myPlugin.pluginTransform();\neditor.tf.editorTransform();\n```\n\n## Convert a Slate Plugin to a Plate Plugin\n\nTo convert a typed Slate plugin to a Plate plugin, you can use `toPlatePlugin`:\n\n```ts\nconst CodeBlockPlugin = toPlatePlugin(createSlatePlugin({ key: 'code_block' }), {\n  handlers: {},\n  options: { hotkey: ['mod+opt+8', 'mod+shift+8'] },\n});\n```",
      "type": "registry:file",
      "target": "content/docs/plate/(guides)/plugin-methods.mdx"
    }
  ]
}