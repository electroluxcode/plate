{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "plugin-docs",
  "type": "registry:file",
  "title": "Plugin Configuration",
  "description": "How to configure and customize Plate plugins.",
  "files": [
    {
      "path": "../../docs/(guides)/plugin.mdx",
      "content": "---\ntitle: Plugin Configuration\ndescription: How to configure and customize Plate plugins.\n---\n\nPlate plugins are highly configurable, allowing you to customize their behavior to suit your needs. This guide will walk you through the most common configuration options and how to use them.\n\n- [Getting Started: Components](/docs/installation#components) - Instructions for adding plugins to your editor\n- [PlatePlugin API](/docs/api/core/plate-plugin) - The complete API reference for creating plugins\n\n## Basic Plugin Configuration\n\n### New Plugin\n\nThe most basic plugin configuration requires only a `key`:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'minimal',\n});\n```\n\nWhile this plugin doesn't do anything yet, it's a starting point for more complex configurations.\n\n### Existing Plugin\n\nThe `.configure` method allows you to configure an existing plugin:\n\n```ts\nconst ConfiguredPlugin = MyPlugin.configure({\n  options: {\n    myOption: 'new value',\n  },\n});\n```\n\n## Node Plugins\n\nNode plugins are used to define new types of nodes in your editor using the `node` property. These can be elements (either block or inline) or leaf nodes (for text-level formatting).\n\n\n### Elements\n\nTo create a new type of element, use the `node.isElement` option:\n\n```ts\nconst ParagraphPlugin = createPlatePlugin({\n  key: 'p',\n  node: {\n    isElement: true,\n    type: 'p',\n  },\n});\n```\n\nYou can associate a component with your element. See [Plugin Components](/docs/plugin-components) for more information.\n\n```ts\nconst ParagraphPlugin = createPlatePlugin({\n  key: 'p',\n  node: {\n    isElement: true,\n    type: 'p',\n    component: ParagraphElement,\n  },\n});\n```\n\n### Inline, Void, and Leaf Nodes\n\nFor inline elements, void elements, or leaf nodes, use the appropriate node options:\n\n```ts\nconst LinkPlugin = createPlatePlugin({\n  key: 'link',\n  node: {\n    isElement: true,\n    isInline: true,\n    type: 'a',\n  },\n});\n\nconst ImagePlugin = createPlatePlugin({\n  key: 'image',\n  node: {\n    isElement: true,\n    isVoid: true,\n    type: 'img',\n  },\n});\n\nconst BoldPlugin = createPlatePlugin({\n  key: 'bold',\n  node: {\n    isLeaf: true,\n  },\n});\n```\n\n## Behavioral Plugins\n\nRather than render an element or a mark, you may want to customize the behavior of your editor. Various plugin options are available to modify the behavior of Plate.\n\n### Plugin Rules\n\nThe `rules` property allows you to configure common editing behaviors like breaking, deleting, and merging nodes without overriding editor methods. This is a powerful way to define intuitive interactions for your custom elements.\n\nFor example, you can define what happens when a user presses `Enter` in an empty heading, or `Backspace` at the start of a blockquote.\n\n```ts\nimport { H1Plugin } from '@platejs/heading/react';\n\nH1Plugin.configure({\n  rules: {\n    break: { empty: 'reset' },\n  },\n});\n```\n\nSee the [Plugin Rules guide](/docs/plugin-rules) for a complete list of available rules and actions.\n\n### Event Handlers\n\nThe recommended way to respond to user-generated events from inside a plugin is with the `handlers` plugin option. A handler should be a function that takes a `PlatePluginContext & { event }` object.\n\nThe `onChange` handler, which is called when the editor value changes, is an exception to this rule; the context object includes the changed `value` instead of `event`.\n\n```ts showLineNumbers\nconst ExamplePlugin = createPlatePlugin({\n  key: 'example',\n  handlers: {\n    onChange: ({ editor, value })  => {\n      console.info(editor, value);\n    },\n    onKeyDown: ({ editor, event }) => {\n      console.info(`You pressed ${event.key}`);\n    },\n  },\n});\n```\n\n### Inject Props\n\nYou may want to inject a class name or CSS property into any node having a certain property. For example, the following plugin sets the `textAlign` CSS property on paragraphs with an `align` property.\n\n```ts showLineNumbers\nimport { KEYS } from 'platejs';\n\nconst TextAlignPlugin = createPlatePlugin({\n  key: 'align',\n  inject: {\n    nodeProps: {\n      defaultNodeValue: 'start',\n      nodeKey: 'align',\n      styleKey: 'textAlign',\n      validNodeValues: ['start', 'left', 'center', 'right', 'end', 'justify'],\n    },\n    targetPlugins: [KEYS.p],\n    // This is injected into all `targetPlugins`. In this example, ParagraphPlugin will be able to deserialize `textAlign` style.\n    targetPluginToInject: ({ editor, plugin }) => ({\n      parsers: {\n        html: {\n          deserializer: {\n            parse: ({ element, node }) => {\n              if (element.style.textAlign) {\n                node[editor.getType('align')] = element.style.textAlign;\n              }\n            },\n          },\n        },\n      },\n    }),\n  },\n});\n```\n\nA paragraph node affected by the above plugin would look like this:\n\n```ts showLineNumbers {3}\n{\n  type: 'p',\n  align: 'right',\n  children: [{ text: 'This paragraph is aligned to the right!' }],\n}\n```\n\n### Override Editor Methods\n\nThe `overrideEditor` method provides a way to override existing editor methods while maintaining access to the original implementations. This is particularly useful when you want to modify the behavior of core editor functionality.\n\n```ts\nconst CustomPlugin = createPlatePlugin({\n  key: 'custom',\n}).overrideEditor(({ editor, tf: { deleteForward }, api: { isInline } }) => ({\n  // Override transforms\n  transforms: {\n    deleteForward(options) {\n      // Custom logic before deletion\n      console.info('Deleting forward...');\n      \n      // Call original transform\n      deleteForward(options);\n      \n      // Custom logic after deletion\n      console.info('Deleted forward');\n    },\n  },\n  // Override API methods\n  api: {\n    isInline(element) {\n      // Custom inline element check\n      if (element.type === 'custom-inline') {\n        return true;\n      }\n      \n      // Fall back to original behavior\n      return isInline(element);\n    },\n  },\n}));\n```\n\n- Access to original methods via destructured `tf` (transforms) and `api` parameters\n- Type-safe overrides of existing methods\n- Clean separation between transforms and API methods\n- Plugin context and options access\n\nExample with typed options:\n\n```ts\ntype CustomConfig = PluginConfig<\n  'custom',\n  { allowDelete: boolean }\n>;\n\nconst CustomPlugin = createTPlatePlugin<CustomConfig>({\n  key: 'custom',\n  options: { allowDelete: true },\n}).overrideEditor(({ editor, tf: { deleteForward }, getOptions }) => ({\n  transforms: {\n    deleteForward(options) {\n      // Use typed options to control behavior\n      if (!getOptions().allowDelete) {\n        return;\n      }\n      \n      deleteForward(options);\n    },\n  },\n}));\n```\n\n### Extend Editor (Advanced)\n\nYou can extend the editor for complex functionality. To do this, you can use the `extendEditor` plugin option to directly mutate properties of the `editor` object after its creation.\n\n```ts showLineNumbers {20}\nconst CustomNormalizerPlugin = createPlatePlugin({\n  key: 'customNormalizer',\n  extendEditor: ({ editor }) => {\n    editor.customState = true;\n    \n    return editor;\n  },\n});\n```\n\n<Callout type=\"info\" title=\"Difference between extendEditor and overrideEditor\">\n- Use `extendEditor` when integrating legacy Slate plugins like `withYjs` that need direct editor mutation. There is only one `extendEditor` per plugin.\n- Prefer using `overrideEditor` for modifying editor behavior as it has single purpose responsibility and better type safety. It can be called multiple times to layer different overrides.\n</Callout>\n\n## Advanced Plugin Configuration\n\n### Plugin Store\n\nEach plugin has its own store, which can be used to manage plugin-specific state.\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n  options: {\n    count: 0,\n  },\n}).extend(({ editor, plugin, setOption }) => ({\n  handlers: {\n    onClick: () => {\n      setOption('count', 1);\n    },\n  },\n}));\n```\n\nYou can access and update the store using the following methods:\n\n```ts\n// Get the current value\nconst count = editor.getOption(MyPlugin, 'count');\n\n// Set a new value\neditor.setOption(MyPlugin, 'count', 5);\n\n// Update the value based on the previous state\neditor.setOption(MyPlugin, 'count', (prev) => prev + 1);\n```\n\nIn React components, you can use the `usePluginOption` or `usePluginOptions` hook to subscribe to store changes:\n\n```tsx\nconst MyComponent = () => {\n  const count = usePluginOption(MyPlugin, 'count');\n  return <div>Count: {count}</div>;\n};\n```\n\nSee more in [Plugin Context](/docs/plugin-context) and [Editor Methods](/docs/editor-methods) guides.\n\n\n### Dependencies\n\nYou can specify plugin dependencies using the `dependencies` property. This ensures that the required plugins are loaded before the current plugin.\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n  dependencies: ['paragraphPlugin', 'listPlugin'],\n});\n```\n\n### Enabled Flag\n\nThe `enabled` property allows you to conditionally enable or disable a plugin:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n  enabled: true, // or false to disable\n});\n```\n\n### Nested Plugins\n\nPlate supports nested plugins, allowing you to create plugin hierarchies. Use the `plugins` property to define child plugins:\n\n```ts\nconst ParentPlugin = createPlatePlugin({\n  key: 'parent',\n  plugins: [\n    createPlatePlugin({ key: 'child1' }),\n    createPlatePlugin({ key: 'child2' }),\n  ],\n});\n```\n\n### Plugin Priority\n\nThe `priority` property determines the order in which plugins are registered and executed. Plugins with higher priority values are processed first:\n\n```ts\nconst HighPriorityPlugin = createPlatePlugin({\n  key: 'highPriority',\n  priority: 100,\n});\n\nconst LowPriorityPlugin = createPlatePlugin({\n  key: 'lowPriority',\n  priority: 50,\n});\n```\n\nThis is particularly useful when you need to ensure certain plugins are initialized or run before others.\n\n### Custom Parsers\n\nThe `parsers` property accepts string keys to build your own parsers:\n\n```ts\nconst MyPlugin = createPlatePlugin({\n  key: 'myPlugin',\n  parsers: {\n    myCustomParser: {\n      deserializer: {\n        parse: // ...\n      },\n      serializer: {\n        parse: // ...\n      }\n    },\n  },\n});\n```\n\nCore plugins includes `html` and `htmlReact` parsers.\n\n## Typed Plugins\n\nUsing above methods, plugin types are automatically inferred from the given configuration.\n\nIf you need to pass an explicit type as generic, you can use `createTPlatePlugin`.\n\n### Using createTPlatePlugin\n\nThe `createTPlatePlugin` function allows you to create a typed plugin:\n\n```ts\ntype CodeBlockConfig = PluginConfig<\n  // key\n  'code_block',\n  // options\n  { syntax: boolean; syntaxPopularFirst: boolean },\n  // api\n  {\n    plugin: {\n      getSyntaxState: () => boolean;\n    };\n    toggleSyntax: () => void;\n  },\n  // transforms\n  {\n    insert: {\n      codeBlock: (options: { language: string }) => void;\n    }\n  }\n>;\n\nconst CodeBlockPlugin = createTPlatePlugin<CodeBlockConfig>({\n  key: 'code_block',\n  options: { syntax: true, syntaxPopularFirst: false },\n}).extendEditorApi<CodeBlockConfig['api']>(() => ({\n  plugin: {\n    getSyntaxState: () => true,\n  },\n  toggleSyntax: () => {},\n})).extendEditorTransforms<CodeBlockConfig['transforms']>(() => ({\n  insert: {\n    codeBlock: ({ editor, getOptions }) => {\n      editor.tf.insertBlock({ type: 'code_block', language: getOptions().language });\n    },\n  },\n}));\n```\n\n### Using Typed Plugins\n\nWhen using typed plugins, you get full type checking and autocompletion ✨\n\n```ts\nconst editor = createPlateEditor({\n  plugins: [ExtendedCodeBlockPlugin],\n});\n\n// Type-safe access to options\nconst options = editor.getOptions(ExtendedCodeBlockPlugin);\noptions.syntax;\noptions.syntaxPopularFirst;\noptions.hotkey;\n\n// Type-safe API\neditor.api.toggleSyntax();\neditor.api.plugin.getSyntaxState();\neditor.api.plugin2.setLanguage('python');\neditor.api.plugin.getLanguage();\n\n// Type-safe Transforms\neditor.tf.insert.codeBlock({ language: 'typescript' });\n```\n\n## See also\n\nSee the [PlatePlugin API](/docs/api/core/plate-plugin) for more plugin options.\n",
      "type": "registry:file",
      "target": "content/docs/plate/(guides)/plugin.mdx"
    }
  ]
}