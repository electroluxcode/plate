{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "api-core-plate-controller-docs",
  "type": "registry:file",
  "title": "Plate Controller",
  "description": "API reference for PlateController component.",
  "files": [
    {
      "path": "../../docs/api/core/plate-controller.mdx",
      "content": "---\ntitle: Plate Controller\ndescription: API reference for PlateController component.\n---\n\n**`PlateController`** is an optional provider component that facilitates accessing specific [Plate Stores](/docs/api/core/store) from outside their respective **`Plate`** components.\n\n## PlateController Store\n\n<API name=\"PlateController\">\nThe PlateController Store contains the information required to fetch a Plate Store based on its **`id`**, and to determine which **`id`** is currently active.\n\n<APIState>\n<APIItem name=\"activeId\" type=\"string | null\">\nThe **`id`** of the most recently focused Plate editor.\n\n- **Default:** `null`\n</APIItem>\n\n<APIItem name=\"primaryEditorIds\" type=\"string[]\">\nThe **`id`**'s of all primary Plate editors. By default, an editor is considered primary unless **`primary={false}`** was passed to its **`Plate`** component.\n\n- **Default:** `[]`\n</APIItem>\n\n<APIItem name=\"editorStores\" type=\"Record<string, JotaiStore | null>\">\nA map from the **`id`** of each mounted Plate editor to the **`JotaiStore`** corresponding to that editor's Plate Store.\n\n- **Default:** `{}`\n</APIItem>\n</APIState>\n</API>\n\n## Usage Patterns\n\n### Specific Editor by ID\n\n**`PlateController`** can be used to access the store of a specific editor using its **`id`**. Note that if a matching editor cannot be found, an immutable fallback editor will be returned instead.\n\n```tsx\nconst App = withHoc(PlateController, () => {\n  const mainEditor = useEditorRef('main');\n  \n  useEffect(() => {\n    if (!mainEditor.meta.isFallback) {\n      console.info('Editor mounted', mainEditor);\n    }\n  }, [mainEditor]);\n  \n  return (\n    <>\n      <Plate editor={createPlateEditor({ id: 'main' })}>\n        <PlateContent />\n      </Plate>\n    \n      <Plate editor={createPlateEditor({ id: 'secondary' })}>\n        <PlateContent />\n      </Plate>\n    </>\n  );\n});\n```\n\n### Active Editor\n\nIf hooks like **`useEditorRef`** are used inside a **`PlateController`** without an explicit **`id`**, they will resolve to the currently active editor.\n\nThe active editor is determined as follows:\n\n1. If some editor has been focused, return the last such editor.\n2. If some editor is primary, return the first-mounted such editor.\n3. Otherwise, return an immutable fallback editor.\n\n```tsx\nconst App = withHoc(PlateController, () => {\n  const activeEditorId = useEditorId();\n  const isFallback = !useEditorMounted();\n  \n  const message = isFallback\n    ? 'Please focus an editor'\n    : `Active editor: ${activeEditorId}`;\n  \n  return (\n    <main>\n      <p>{message}</p>\n      \n      <Plate editor={createPlateEditor({ id: 'main', primary: false })}>\n        <PlateContent />\n      </Plate>\n    \n      <Plate editor={createPlateEditor({ id: 'secondary', primary: false })}>\n        <PlateContent />\n      </Plate>\n    </main>\n  );\n});\n```\n\n## Dealing with Fallback Editors\n\nWhen a hook called inside a **`PlateController`** fails to locate a matching Plate Store, it will use Plate Store's default values. The default value for **`editor`** is **`createPlateFallbackEditor()`**. A fallback editor works like an empty Plate editor with no plugins, except it throws a runtime error if it receives a Slate operation (i.e. it is immutable and must not be used in transforms).\n\nThe rationale behind this is to ensure that code that queries the editor (such as determining whether toolbar buttons are active) fails silently with a sensible default value, while code that transforms the editor (such as pressing a toolbar button) fails loudly with an error.\n\nThere are two ways to determine if you're working with a fallback editor or a real editor:\n\n- **`useEditorMounted`** returns **`false`** if no mounted editor could be resolved\n- **`editor.meta.isFallback`** is **`true`** for fallback editors\n\nWhen using hooks like **`useEditorRef`** inside a **`PlateController`**, you should code defensively to ensure that fallback editors are handled appropriately should they arise. For example, you can disable toolbar buttons if **`useEditorMounted`** returns **`false`**, or ignore events if **`editor.meta.isFallback`** is **`true`**.\n\n```tsx\nimport { KEYS } from 'platejs';\n\nconst App = withHoc(PlateController, () => {\n  const activeEditor = useEditorRef();\n  \n  const toggleBold = () => {\n    if (activeEditor.meta.isFallback) return;\n    activeEditor.tf.toggleMark(KEYS.bold);\n  };\n  \n  return (\n    <main>\n      <button type=\"button\" onClick={toggleBold}>\n        Bold\n      </button>\n      \n      <Plate editor={createPlateEditor({ id: 'main', primary: false })}>\n        <PlateContent />\n      </Plate>\n    \n      <Plate editor={createPlateEditor({ id: 'secondary', primary: false })}>\n        <PlateContent />\n      </Plate>\n    </main>\n  );\n});\n```\n\n```tsx\nconst App = withHoc(PlateController, () => {\n  const activeEditor = useEditorRef();\n  const isFallback = !useEditorMounted();\n  \n  const toggleBold = () => {\n    activeEditor.tf.toggleMark(KEYS.bold);\n  };\n  \n  return (\n    <main>\n      <button\n        type=\"button\"\n        onClick={toggleBold}\n        disabled={isFallback}\n      >\n        Bold\n      </button>\n      \n      <Plate editor={createPlateEditor({ id: 'main', primary: false })}>\n        <PlateContent />\n      </Plate>\n    \n      <Plate editor={createPlateEditor({ id: 'secondary', primary: false })}>\n        <PlateContent />\n      </Plate>\n    </main>\n  );\n});\n```",
      "type": "registry:file",
      "target": "content/docs/plate/api/core/plate-controller.mdx"
    }
  ]
}